<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  <subtitle>顺境内敛 逆境不屈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://elijahyg.github.io/"/>
  <updated>2021-01-10T09:01:22.917Z</updated>
  <id>https://elijahyg.github.io/</id>
  
  <author>
    <name>Elijah Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PythonIO多路复用</title>
    <link href="https://elijahyg.github.io/2021/01/10/PythonIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://elijahyg.github.io/2021/01/10/PythonIO多路复用/</id>
    <published>2021-01-10T08:50:44.000Z</published>
    <updated>2021-01-10T09:01:22.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>此处所讲的I/O模型是参考Richard Stevens所著《UNIX网络编程 卷1：套接字联网API》（第3版）中的I/O模型为基础。列举了其中所讲的5中I/O网络模型并加以描述对比。</p><h4 id="网络I-O发生时系统涉及的操作"><a href="#网络I-O发生时系统涉及的操作" class="headerlink" title="网络I/O发生时系统涉及的操作"></a>网络I/O发生时系统涉及的操作</h4><ul><li>数据准备（等待数据通过网络送达）</li><li>将数据从内核复制到程序进程</li></ul><h4 id="阻塞I-O（blocking-I-O）"><a href="#阻塞I-O（blocking-I-O）" class="headerlink" title="阻塞I/O（blocking I/O）"></a>阻塞I/O（blocking I/O）</h4><ul><li>【Step 1】应用进程执行系统调用，阻塞直至数据准备完成</li><li>【Step 2】将数据从内核复制到用户空间</li><li>【Step 3】数据复制完成，返回成功指示，应用程序进程处理数据</li></ul><p><img src="/images/post_imgs/blocking.jpg" alt></p><h4 id="非阻塞I-O（non-blocking-I-O）"><a href="#非阻塞I-O（non-blocking-I-O）" class="headerlink" title="非阻塞I/O（non-blocking I/O）"></a>非阻塞I/O（non-blocking I/O）</h4><ul><li>【Step 1】应用进程执行系统调用，内核如果没有准备好数据不会阻塞，而是会以非阻塞方式返回错误码告知应用进程</li><li>【Step 2】应用进程收到错误码后依然会不断系统调用询问内核是否准备好数据，直至内核准备好数据，返回成功</li><li>【Step 3】将数据从内核复制到用户空间</li><li>【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据</li></ul><p><img src="/images/post_imgs/non-blocking.jpg" alt></p><h4 id="多路复用I-O（I-O-multiplexing）"><a href="#多路复用I-O（I-O-multiplexing）" class="headerlink" title="多路复用I/O（I/O multiplexing）"></a>多路复用I/O（I/O multiplexing）</h4><p>类似于非阻塞I/O的轮询系统调用方式，区别在于轮询的执行不是由用户线程调用，而是内核调用</p><ul><li>【Step 1】应用进程执行系统调用，内核如果没有准备好数据不会阻塞，而是会以非阻塞方式返回错误码告知应用进程</li><li>【Step 2】内核以轮询方式不断检查是否准备好数据，直至数据准备完成，返回成功</li><li>【Step 3】将数据从内核复制到用户空间</li><li>【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据</li></ul><p><img src="/images/post_imgs/multiplexing.jpg" alt></p><h4 id="信号驱动I-O（signal-driven-I-O）"><a href="#信号驱动I-O（signal-driven-I-O）" class="headerlink" title="信号驱动I/O（signal driven I/O）"></a>信号驱动I/O（signal driven I/O）</h4><p>使用信号，内核在数据准备就绪时通过信号来进行通知</p><ul><li>【Step 1】建立SIGIO的信号处理程序进行系统调用</li><li>【Step 2】内核准备好数据后通过递交SIGIO告知应用进程</li><li>【Step 3】将数据从内核复制到用户空间</li><li>【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据</li></ul><p><img src="/images/post_imgs/signal_driven.jpg" alt></p><h4 id="异步I-O（Asynchronous-I-O）"><a href="#异步I-O（Asynchronous-I-O）" class="headerlink" title="异步I/O（Asynchronous I/O）"></a>异步I/O（Asynchronous I/O）</h4><p>异步I/O通过信号处理程序告知应用进程，其告知应用进程的是I/O操作完成，而不是数据准备完成</p><ul><li>【Step 1】应用进程进行系统调用，内核通过非阻塞方式返回给应用程序</li><li>【Step 2】当数据准备好时内核将数据复制到用户空间</li><li>【Step 3】数据复制完成，递交再aio_read中指定的信号，应用程序进程处理数据</li></ul><p><img src="/images/post_imgs/Asynchronous.jpg" alt></p><h4 id="I-O模型比较分析"><a href="#I-O模型比较分析" class="headerlink" title="I/O模型比较分析"></a>I/O模型比较分析</h4><ul><li>阻塞I/O、非阻塞I/O、多路复用I/O、信号驱动I/O的相同点在于数据准备期间与数据从内核复制到用户空间这段过程中，都是阻塞状态。即上述这四种I/O模型都是同步I/O模型。</li><li>异步I/O操作不会讲进程阻塞。</li></ul><p><img src="/images/post_imgs/compare.jpg" alt></p><hr><h3 id="I-O多路复用的机制【TODO】"><a href="#I-O多路复用的机制【TODO】" class="headerlink" title="I/O多路复用的机制【TODO】"></a>I/O多路复用的机制【TODO】</h3><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）</p><h4 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h4><p>同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作</p><h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><p>用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;I-O多路复用&quot;&gt;&lt;a href=&quot;#I-O多路复用&quot; class=&quot;headerlink&quot; title=&quot;I/O多路复用&quot;&gt;&lt;/a&gt;I/O多路复用&lt;/h2&gt;&lt;h3 id=&quot;I-O模型&quot;&gt;&lt;a href=&quot;#I-O模型&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中协程</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%E5%8D%8F%E7%A8%8B/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python中协程/</id>
    <published>2021-01-10T08:50:31.000Z</published>
    <updated>2021-01-10T08:55:21.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中协程"><a href="#Python中协程" class="headerlink" title="Python中协程"></a>Python中协程</h2><h3 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>asyncio 是用来编写 并发 代码的库，使用 async/await 语法。<br>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。<br>asyncio 往往是构建 IO 密集型和高层级 结构化 网络代码的最佳选择。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p>提供<code>高层级API</code></p><ul><li>并发地运行 Python 协程并对其执行过程实现完全控制</li><li>执行 网络 IO 和 IPC</li><li>控制 子进程</li><li>通过 队列 实现分布式任务</li><li>同步 并发代码</li></ul></li><li><p>提供<code>低层级API</code></p><ul><li>创建和管理 事件循环，以提供异步 API 用于 网络化, 运行 子进程，处理 OS 信号 等等</li><li>使用 transports 实现高效率协议</li><li>通过 async/await 语法 桥接 基于回调的库和代码</li></ul></li></ul><hr><h3 id="asyncio模块之协程"><a href="#asyncio模块之协程" class="headerlink" title="asyncio模块之协程"></a>asyncio模块之协程</h3><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li><p>概念<br>使用async / await语法声明的协程是编写异步应用程序的首选方式。</p></li><li><p>三种运行协程的机制</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 一、asyncio.run() 函数用来运行最高层级的入口点 "main()" 函数</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 二、等待一个协程</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">started at <span class="number">17</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">13</span>:<span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 三、asyncio.create_task() 函数用来并发运行作为 asyncio 任务 的多个协程。</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">started at <span class="number">17</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">14</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure><h4 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h4><ul><li><p>概念<br>如果一个对象可以在 await 语句中使用，那么它就是 可等待 对象。</p></li><li><p>类型<br>可等待 对象有三种主要类型: <code>协程（包括协程函数、协程对象）</code>, <code>任务</code> 和 <code>Future</code></p></li></ul><h4 id="并发协程"><a href="#并发协程" class="headerlink" title="并发协程"></a>并发协程</h4><ul><li><p>语法<br>asyncio.gather(*aws, loop=None, return_exceptions=False)</p><ul><li>并发 运行 aws 序列中的 可等待对象。</li><li>如果 aws 中的某个可等待对象为协程，它将自动作为一个任务加入日程。</li><li>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。</li></ul></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Task A: Compute factorial(<span class="number">2</span>)...</span><br><span class="line">Task B: Compute factorial(<span class="number">2</span>)...</span><br><span class="line">Task C: Compute factorial(<span class="number">2</span>)...</span><br><span class="line">Task A: factorial(<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">Task B: Compute factorial(<span class="number">3</span>)...</span><br><span class="line">Task C: Compute factorial(<span class="number">3</span>)...</span><br><span class="line">Task B: factorial(<span class="number">3</span>) = <span class="number">6</span></span><br><span class="line">Task C: Compute factorial(<span class="number">4</span>)...</span><br><span class="line">Task C: factorial(<span class="number">4</span>) = <span class="number">24</span></span><br></pre></td></tr></table></figure><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><ul><li><p>语法<br>asyncio.wait_for(aw, timeout, *, loop=None)</p><ul><li>等待 aw 可等待对象 完成，指定 timeout 秒数后超时。</li><li>如果 aw 是一个协程，它将自动作为任务加入日程。</li><li>timeout 可以为 None，也可以为 float 或 int 型数值表示的等待秒数。如果 timeout 为 None，则等待直到完成。</li></ul></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">timeout!</span><br></pre></td></tr></table></figure><h4 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h4><ul><li>语法<br>asyncio.current_task(loop=None)：返回当前运行的 Task 实例，如果没有正在运行的任务则返回 None。<br>asyncio.all_tasks(loop=None)：返回事件循环所运行的未完成的 Task 对象的集合。</li></ul><h4 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a>Task 对象</h4><ul><li>概念<br>一个与 Future 类似 的对象，可运行 Python 协程。非线程安全。<br>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 完成，被打包的协程将恢复执行。</li></ul><hr><h3 id="支持协程的模块Greenlet-Gevent"><a href="#支持协程的模块Greenlet-Gevent" class="headerlink" title="支持协程的模块Greenlet/Gevent"></a>支持协程的模块Greenlet/Gevent</h3><h4 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h4><ul><li><p>概念<br>greenlet提供了一种简单的切换模式，当任务遇到I/O时可以出发阻塞。但是greenlet没有解决切换任务的目的。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># greenlet实现切换</span></span><br><span class="line">pip install greenlet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; at foo_1'</span>.format(x))</span><br><span class="line">    g2.switch(<span class="string">'Elijah'</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; at foo_2'</span>.format(x))</span><br><span class="line">    g2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(y)</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; at bar_1'</span>.format(y))</span><br><span class="line">    g1.switch()</span><br><span class="line">    print(<span class="string">'&#123;&#125; at bar_2'</span>.format(y))</span><br><span class="line"></span><br><span class="line">g1 = greenlet(foo)</span><br><span class="line">g2 = greenlet(bar)</span><br><span class="line"></span><br><span class="line">g1.switch(<span class="string">'yang'</span>)</span><br></pre></td></tr></table></figure><h4 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h4><ul><li><p>概念<br>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。<br>Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p></li><li><p>示例一</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 主动切换 ----------</span></span><br><span class="line">pip install gevent</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; at foo_1'</span>.format(x))</span><br><span class="line">    gevent.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; at foo_2'</span>.format(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(y)</span>:</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; at bar_1'</span>.format(y))</span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'&#123;&#125; at bar_2'</span>.format(y))</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(foo, <span class="string">'yang'</span>)</span><br><span class="line">g2 = gevent.spawn(bar, <span class="string">'Elijah'</span>)</span><br><span class="line">gevent.joinall([g1,g2])</span><br></pre></td></tr></table></figure><ul><li>示例二</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----------服务端 ----------</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不想用money.patch_all()打补丁,可以用gevent自带的socket</span></span><br><span class="line"><span class="comment"># from gevent import socket</span></span><br><span class="line"><span class="comment"># s=socket.socket()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(server_ip,port)</span>:</span></span><br><span class="line">    s=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    s.bind((server_ip,port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line">        gevent.spawn(talk,conn,addr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(conn,addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res=conn.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">'client %s:%s msg: %s'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],res))</span><br><span class="line">            conn.send(res.upper())</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------客户端 ----------</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    client.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    msg=client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------多个客户端并发 ----------</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(server_ip,port)</span>:</span></span><br><span class="line">    c=socket(AF_INET,SOCK_STREAM) <span class="comment">#套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了</span></span><br><span class="line">    c.connect((server_ip,port))</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c.send((<span class="string">'%s say hello %s'</span> %(threading.current_thread().getName(),count)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        msg=c.recv(<span class="number">1024</span>)</span><br><span class="line">        print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        t=Thread(target=client,args=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><hr><h3 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h3><h4 id="名字的由来"><a href="#名字的由来" class="headerlink" title="名字的由来"></a>名字的由来</h4><ul><li>说法一<br>这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。</li><li>说法二<br>由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。</li></ul><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在程序运行是，将原本的模块功能替换成另外模块的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python中协程&quot;&gt;&lt;a href=&quot;#Python中协程&quot; class=&quot;headerlink&quot; title=&quot;Python中协程&quot;&gt;&lt;/a&gt;Python中协程&lt;/h2&gt;&lt;h3 id=&quot;asyncio模块&quot;&gt;&lt;a href=&quot;#asyncio模块&quot; class
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中（多）线程</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%EF%BC%88%E5%A4%9A%EF%BC%89%E7%BA%BF%E7%A8%8B/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python中（多）线程/</id>
    <published>2021-01-10T08:49:41.000Z</published>
    <updated>2021-01-10T08:54:39.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中-多-线程"><a href="#Python中-多-线程" class="headerlink" title="Python中(多)线程"></a>Python中(多)线程</h2><h3 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h3><p>_thread模块提供了操作多个线程的底层原语，多个控制线程共享全局数据空间。threading 模块基于该模块提供了更易用的高级多线程 API。</p><hr><h3 id="threading-Thread类"><a href="#threading-Thread类" class="headerlink" title="threading.Thread类"></a>threading.Thread类</h3><ul><li>创建线程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 方式一 ----------</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'foo run'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=foo,args=())</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">主线程</span><br><span class="line">foo run</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 方式二 ----------</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'foo run'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = foo()</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">主线程</span><br><span class="line">foo run</span><br></pre></td></tr></table></figure><hr><h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><h4 id="threading-local"><a href="#threading-local" class="headerlink" title="threading.local"></a>threading.local</h4><ul><li><p>概念<br>线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 local （或者一个子类型）的实例并在实例中储存属性<br>在不同的线程中，实例的值会不同。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata = threading.local()</span><br><span class="line">mydata.x = <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>概念<br>是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。</li></ul><h4 id="互斥锁（Lock）"><a href="#互斥锁（Lock）" class="headerlink" title="互斥锁（Lock）"></a>互斥锁（Lock）</h4><ul><li><p>概念<br>实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">n=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n = temp<span class="number">-1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mutex = Lock()</span><br><span class="line">    l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t=Thread(target = f)</span><br><span class="line">        l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> l:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure><h4 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h4><ul><li><p>概念<br>递归锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在互斥锁的锁定/非锁定状态上附加了 “所属线程” 和 “递归等级” 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,RLock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexB = RLock()</span><br><span class="line">mutexA = RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f1()</span><br><span class="line">        self.f2()</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">'%s 拿到A锁 '</span>%self.name)</span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">'%s 拿到B锁 '</span>%self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line">        mutexA.release()</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">'%s 拿到B锁 '</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">'%s 拿到B锁 '</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Thread<span class="number">-1</span> 拿到A锁 </span><br><span class="line">Thread<span class="number">-1</span> 拿到B锁 </span><br><span class="line">Thread<span class="number">-1</span> 拿到B锁 </span><br><span class="line">Thread<span class="number">-2</span> 拿到A锁</span><br></pre></td></tr></table></figure><hr><h3 id="Join-amp-Daemon"><a href="#Join-amp-Daemon" class="headerlink" title="Join &amp; Daemon"></a>Join &amp; Daemon</h3><h4 id="Join-timeout"><a href="#Join-timeout" class="headerlink" title="Join(timeout)"></a>Join(timeout)</h4><ul><li>概念<br>等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 join() 的线程终结。</li></ul><h4 id="守护线程（Daemon）"><a href="#守护线程（Daemon）" class="headerlink" title="守护线程（Daemon）"></a>守护线程（Daemon）</h4><ul><li>概念<br>一个表示这个线程守护线程的布尔值。一定要在调用 start() 前设置好，不然会抛出 RuntimeError 。<br>初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 daemon = False。<br>当没有存活的非守护线程时，整个Python程序才会退出。</li></ul><hr><h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><h4 id="条件（Condition）"><a href="#条件（Condition）" class="headerlink" title="条件（Condition）"></a>条件（Condition）</h4><ul><li><p>概念<br>使线程等待，只有满足某条件时，才释放n个线程。<br>条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait()</span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> % n)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">        <span class="keyword">if</span> inp == <span class="string">'q'</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        con.acquire()</span><br><span class="line">        con.notify(int(inp))</span><br><span class="line">        con.release()</span><br><span class="line">        print(<span class="string">'****'</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><ul><li><p>概念<br>同进程的一样，Semaphore管理一个内置的计数器，每当调用acquire()时内置计数器-1；调用release()时内置计数器+1；计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    print(<span class="string">'%s get sm'</span> %threading.current_thread().getName())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    sm.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sm=Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t=threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Thread<span class="number">-1</span> get sm</span><br><span class="line">Thread<span class="number">-2</span> get sm</span><br><span class="line">Thread<span class="number">-3</span> get sm</span><br><span class="line">Thread<span class="number">-4</span> get sm</span><br><span class="line">Thread<span class="number">-5</span> get sm</span><br><span class="line">Thread<span class="number">-6</span> get sm</span><br><span class="line">Thread<span class="number">-9</span> get sm</span><br><span class="line">Thread<span class="number">-8</span> get sm</span><br><span class="line">Thread<span class="number">-7</span> get sm</span><br><span class="line">Thread<span class="number">-10</span> get sm</span><br></pre></td></tr></table></figure><hr><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h4><ul><li><p>概念<br>同进程的一样，线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    count=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> TimeoutError(<span class="string">'链接超时'</span>)</span><br><span class="line">        print(<span class="string">'&lt;%s&gt;第%s次尝试链接'</span> % (threading.current_thread().getName(), count))</span><br><span class="line">        event.wait(<span class="number">0.5</span>)</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">'&lt;%s&gt;链接成功'</span> %threading.current_thread().getName())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'\033[45m[%s]正在检查mysql\033[0m'</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(random.randint(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">    event.set()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event=Event()</span><br><span class="line">    conn1=Thread(target=conn_mysql)</span><br><span class="line">    conn2=Thread(target=conn_mysql)</span><br><span class="line">    check=Thread(target=check_mysql)</span><br><span class="line"></span><br><span class="line">    conn1.start()</span><br><span class="line">    conn2.start()</span><br><span class="line">    check.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;Thread<span class="number">-1</span>&gt;第<span class="number">1</span>次尝试链接</span><br><span class="line">&lt;Thread<span class="number">-2</span>&gt;第<span class="number">1</span>次尝试链接</span><br><span class="line">&lt;Thread<span class="number">-1</span>&gt;第<span class="number">2</span>次尝试链接</span><br><span class="line">&lt;Thread<span class="number">-2</span>&gt;第<span class="number">2</span>次尝试链接</span><br><span class="line">&lt;Thread<span class="number">-1</span>&gt;第<span class="number">3</span>次尝试链接</span><br><span class="line">&lt;Thread<span class="number">-2</span>&gt;第<span class="number">3</span>次尝试链接</span><br><span class="line">Exception <span class="keyword">in</span> thread Thread<span class="number">-1</span>:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"main.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> conn_mysql</span><br><span class="line">    <span class="keyword">raise</span> TimeoutError(<span class="string">'链接超时'</span>)</span><br><span class="line">TimeoutError: 链接超时</span><br></pre></td></tr></table></figure><hr><h3 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h3><h4 id="定时器（Timer）"><a href="#定时器（Timer）" class="headerlink" title="定时器（Timer）"></a>定时器（Timer）</h4><ul><li><p>概念<br>此类表示一个操作应该在等待一定的时间之后运行，相当于一个定时器。 Timer 类是 Thread 类的子类，因此可以像一个自定义线程一样工作。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">30.0</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># 30秒后输出'hello, world'</span></span><br></pre></td></tr></table></figure><hr><h3 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h3><h4 id="栅栏（Barrier）"><a href="#栅栏（Barrier）" class="headerlink" title="栅栏（Barrier）"></a>栅栏（Barrier）</h4><ul><li><p>概念<br>栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 wait() 方法后将阻塞，直到所有线程都调用了 wait() 方法。此时所有线程将被同时释放。<br>栅栏对象可以被多次使用，但进程的数量不能改变。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, logging</span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">"%(threadName)s %(message)s"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(barrier:threading.Barrier)</span>:</span></span><br><span class="line">    logging.info(<span class="string">"n_waiting = &#123;&#125;"</span>.format(barrier.n_waiting))</span><br><span class="line">    bid = barrier.wait()</span><br><span class="line">    logging.info(<span class="string">"after barrier &#123;&#125;"</span>.format(bid)) <span class="comment"># 栅栏之后</span></span><br><span class="line"> </span><br><span class="line">barrier = threading.Barrier(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>): </span><br><span class="line">    threading.Event().wait(<span class="number">1</span>)</span><br><span class="line">    threading.Thread(target=work,args=(barrier,),name=<span class="string">"Barrier-&#123;&#125;"</span>.format(x)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Barrier<span class="number">-1</span> n_waiting = <span class="number">0</span></span><br><span class="line">Barrier<span class="number">-2</span> n_waiting = <span class="number">1</span></span><br><span class="line">Barrier<span class="number">-3</span> n_waiting = <span class="number">2</span></span><br><span class="line">Barrier<span class="number">-3</span> after barrier <span class="number">2</span></span><br><span class="line">Barrier<span class="number">-2</span> after barrier <span class="number">1</span></span><br><span class="line">Barrier<span class="number">-1</span> after barrier <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python中-多-线程&quot;&gt;&lt;a href=&quot;#Python中-多-线程&quot; class=&quot;headerlink&quot; title=&quot;Python中(多)线程&quot;&gt;&lt;/a&gt;Python中(多)线程&lt;/h2&gt;&lt;h3 id=&quot;threading模块&quot;&gt;&lt;a href=&quot;#th
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中（多）进程</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%EF%BC%88%E5%A4%9A%EF%BC%89%E8%BF%9B%E7%A8%8B/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python中（多）进程/</id>
    <published>2021-01-10T08:49:32.000Z</published>
    <updated>2021-01-10T08:53:58.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中-多-进程"><a href="#Python中-多-进程" class="headerlink" title="Python中(多)进程"></a>Python中(多)进程</h2><h3 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h3><p>multiprocessing 是一个用于产生进程的包，具有与 threading 模块相似API。 multiprocessing 包同时提供本地和远程并发，使用子进程代替线程，有效避免 GIL锁（Global Interpreter Lock）带来的影响。因此，multiprocessing 模块允许程序员充分利用机器上的多核。可运行于 Unix 和 Windows 。</p><hr><h3 id="multiprocessing-Process类"><a href="#multiprocessing-Process类" class="headerlink" title="multiprocessing.Process类"></a>multiprocessing.Process类</h3><ul><li>创建进程<br>在 multiprocessing 中，通过创建一个 Process 对象然后调用它的 start() 方法来生成进程。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 创建进程 ----------</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 显示所涉及的各个进程ID ----------</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(title)</span>:</span></span><br><span class="line">    print(title)</span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__)</span><br><span class="line">    print(<span class="string">'parent process:'</span>, os.getppid())</span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info(<span class="string">'function f'</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info(<span class="string">'main line'</span>)</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><hr><h3 id="multiprocessing启动方式"><a href="#multiprocessing启动方式" class="headerlink" title="multiprocessing启动方式"></a>multiprocessing启动方式</h3><h4 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h4><p>父进程启动一个新的Python解释器进程。子进程只会继承那些运行进程对象的 run() 方法所需的资源。特别是父进程中非必须的文件描述符和句柄不会被继承。相对于使用 fork 或者 forkserver，使用这个方法启动进程相当慢。<br>可在Unix和Windows上使用。 Windows上的默认设置。3.8版本后，macOS上的默认方式。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>父进程使用 os.fork() 来产生 Python 解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。<br>只存在于Unix。Unix中的默认值。</p><h4 id="forkserver"><a href="#forkserver" class="headerlink" title="forkserver"></a>forkserver</h4><p>程序启动并选择* forkserver * 启动方法时，将启动服务器进程。从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。分叉服务器进程是单线程的，因此使用 os.fork() 是安全的。没有不必要的资源被继承。<br>可在Unix平台上使用，支持通过Unix管道传递文件描述符。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 启动示例 ----------</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mp.set_start_method(<span class="string">'spawn'</span>)</span><br><span class="line">    q = mp.Queue()</span><br><span class="line">    p = mp.Process(target=foo, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 获取上下文----------</span></span><br><span class="line"><span class="comment"># 在程序中 set_start_method() 不应该被多次调用。</span></span><br><span class="line"><span class="comment"># 可以使用 get_context() 来获取上下文对象。</span></span><br><span class="line"><span class="comment"># 上下文对象与 multiprocessing 模块具有相同的API，并允许在同一程序中使用多种启动方法。</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ctx = mp.get_context(<span class="string">'spawn'</span>)</span><br><span class="line">    q = ctx.Queue()</span><br><span class="line">    p = ctx.Process(target=foo, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><hr><h3 id="multiprocessing-进程间通信"><a href="#multiprocessing-进程间通信" class="headerlink" title="multiprocessing 进程间通信"></a>multiprocessing 进程间通信</h3><h4 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h4><ul><li><p>概念<br>Queue 类是一个近似 queue.Queue 的克隆。<code>队列是线程和进程安全的。</code></p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get()) <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><h4 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h4><ul><li><p>概念<br>Pipe() 函数返回一个由管道连接的连接对象，默认情况下是双工（双向）。如果两个进程/线程同时尝试读取或写入管道的同一端，则管道中的数据可能会损坏。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="literal">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv()) <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><hr><h3 id="multiprocessing-进程间同步"><a href="#multiprocessing-进程间同步" class="headerlink" title="multiprocessing 进程间同步"></a>multiprocessing 进程间同步</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>概念<br>是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</li></ul><h4 id="互斥锁（Lock）"><a href="#互斥锁（Lock）" class="headerlink" title="互斥锁（Lock）"></a>互斥锁（Lock）</h4><ul><li><p>概念<br>实现互斥锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。互斥锁有可能造成死锁问题。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(l, i)</span>:</span></span><br><span class="line">    l.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'hello world'</span>, i)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        l.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">hello world <span class="number">2</span></span><br><span class="line">hello world <span class="number">3</span></span><br><span class="line">hello world <span class="number">1</span></span><br><span class="line">hello world <span class="number">4</span></span><br><span class="line">hello world <span class="number">0</span></span><br><span class="line">hello world <span class="number">6</span></span><br><span class="line">hello world <span class="number">5</span></span><br><span class="line">hello world <span class="number">7</span></span><br><span class="line">hello world <span class="number">8</span></span><br><span class="line">hello world <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="递归锁（RLock）"><a href="#递归锁（RLock）" class="headerlink" title="递归锁（RLock）"></a>递归锁（RLock）</h4><ul><li>概念<br>递归锁必须由持有线程、进程亲自释放。如果某个进程或者线程拿到了递归锁，这个进程或者线程可以再次拿到这个锁而不需要等待。但是这个进程或者线程的拿锁操作和释放锁操作的次数必须相同。递归锁避免了互斥锁有可能会造成死锁的情况。</li></ul><hr><h3 id="进程间状态共享"><a href="#进程间状态共享" class="headerlink" title="进程间状态共享"></a>进程间状态共享</h3><h4 id="共享内存（Value-Array）"><a href="#共享内存（Value-Array）" class="headerlink" title="共享内存（Value/Array）"></a>共享内存（Value/Array）</h4><ul><li><p>概念<br>可以使用 Value 或 Array 将数据存储在共享内存映射中。<br>为了更灵活地使用共享内存，可以使用 multiprocessing.sharedctypes 模块，该模块支持创建从共享内存分配的任意ctypes对象。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    n.value = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        a[i] = -a[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = Value(<span class="string">'d'</span>, <span class="number">0.0</span>)</span><br><span class="line">    arr = Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(num.value)</span><br><span class="line">    print(arr[:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">3.1415927</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">-6</span>, <span class="number">-7</span>, <span class="number">-8</span>, <span class="number">-9</span>]</span><br></pre></td></tr></table></figure><h4 id="服务进程（Manager）"><a href="#服务进程（Manager）" class="headerlink" title="服务进程（Manager）"></a>服务进程（Manager）</h4><ul><li><p>概念<br>由 Manager() 返回的管理器对象控制一个服务进程，该进程保存Python对象并允许其他进程使用代理操作它们。<br>Manager() 返回的管理器支持类型： list 、 dict 、 Namespace 、 Lock 、 RLock 、 Semaphore 、 BoundedSemaphore 、 Condition 、 Event 、 Barrier 、 Queue 、 Value 和 Array 。<br>使用服务进程的管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l)</span>:</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="string">'2'</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="literal">None</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> manager:</span><br><span class="line">        d = manager.dict()</span><br><span class="line">        l = manager.list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">        p = Process(target=f, args=(d, l))</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="number">0.25</span>: <span class="literal">None</span>, <span class="number">1</span>: <span class="string">'1'</span>, <span class="string">'2'</span>: <span class="number">2</span>&#125;</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="使用工作进程"><a href="#使用工作进程" class="headerlink" title="使用工作进程"></a>使用工作进程</h3><h4 id="进程池（Pool）"><a href="#进程池（Pool）" class="headerlink" title="进程池（Pool）"></a>进程池（Pool）</h4><ul><li><p>概念<br>Pool 类表示一个工作进程池。它具有允许以几种不同方式将任务分配到工作进程的方法。<br><code>进程池的方法只能由创建它的进程使用</code></p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, TimeoutError</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># start 4 worker processes</span></span><br><span class="line">    <span class="keyword">with</span> Pool(processes=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print "[0, 1, 4,..., 81]"</span></span><br><span class="line">        print(pool.map(f, range(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print same numbers in arbitrary order</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pool.imap_unordered(f, range(<span class="number">10</span>)):</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># evaluate "f(20)" asynchronously</span></span><br><span class="line">        res = pool.apply_async(f, (<span class="number">20</span>,)) <span class="comment"># runs in *only* one process</span></span><br><span class="line">        print(res.get(timeout=<span class="number">1</span>)) <span class="comment"># prints "400"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># evaluate "os.getpid()" asynchronously</span></span><br><span class="line">        res = pool.apply_async(os.getpid, ()) <span class="comment"># runs in *only* one process</span></span><br><span class="line">        print(res.get(timeout=<span class="number">1</span>)) <span class="comment"># prints the PID of that process</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># launching multiple evaluations asynchronously *may* use more processes</span></span><br><span class="line">        multiple_results = [pool.apply_async(os.getpid, ()) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">        print([res.get(timeout=<span class="number">1</span>) <span class="keyword">for</span> res <span class="keyword">in</span> multiple_results])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make a single worker sleep for 10 secs</span></span><br><span class="line">        res = pool.apply_async(time.sleep, (<span class="number">10</span>,))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(res.get(timeout=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">except</span> TimeoutError:</span><br><span class="line">            print(<span class="string">"We lacked patience and got a multiprocessing.TimeoutError"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"For the moment, the pool remains available for more work"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># exiting the 'with'-block has stopped the pool</span></span><br><span class="line">    print(<span class="string">"Now the pool is closed and no longer available"</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="Join-amp-Daemon"><a href="#Join-amp-Daemon" class="headerlink" title="Join &amp; Daemon"></a>Join &amp; Daemon</h3><h4 id="Join-timeout"><a href="#Join-timeout" class="headerlink" title="Join(timeout)"></a>Join(timeout)</h4><ul><li><p>概念<br>使用join会将该方法阻塞，直到timeout时间或调用join的进程终止。一个进程可以被join多次，且进程无法join自身，join自身会导致死锁问题。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(time.time())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process '</span> + str(os.getpid()) + <span class="string">' at '</span> + str(now()))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'Stop child process '</span> + str(os.getpid()) + <span class="string">' at '</span> + str(now()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Parent process '</span> + str(os.getpid()))</span><br><span class="line">    p1 = Process(target=f, args=())</span><br><span class="line">    print(<span class="string">'Process start at '</span>+ str(now()))</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    print(<span class="string">'Process end at '</span>+ str(now()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 如果没p1.join()，则主进程会在子进程结束之前执行Process end 打印</span></span><br><span class="line">Parent process <span class="number">2</span></span><br><span class="line">Process start at <span class="number">1581322409.9711816</span></span><br><span class="line">Run child process <span class="number">3</span> at <span class="number">1581322409.975377</span></span><br><span class="line">Stop child process <span class="number">3</span> at <span class="number">1581322412.9764113</span></span><br><span class="line">Process end at <span class="number">1581322412.9770644</span></span><br></pre></td></tr></table></figure><h4 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h4><ul><li><p>概念<br>进程的守护标志，一个布尔值。这必须在 start() 被调用之前设置。当进程退出时，它会尝试终止其所有守护进程子进程。<br>不允许守护进程创建子进程。否则，守护进程会在子进程退出时终止其子进程。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"work start at &#123;&#125;"</span>.format(time.time()));</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"work end at &#123;&#125;"</span>.format(time.time()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p = multiprocessing.Process(target = f, args = ())</span><br><span class="line">    p.daemon = <span class="literal">True</span>  <span class="comment"># 设置是否为守护进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"Process end"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># 因为守护进程随主进程的结束而结束，所以如果加了p.daemon = True，则只会输出 Process end</span></span><br><span class="line">Process end</span><br><span class="line">work start at <span class="number">1581323384.468953</span>  <span class="comment"># 如果不加p.daemon = True，则输出该行</span></span><br><span class="line">work end at <span class="number">1581323387.4720087</span>  <span class="comment"># 如果不加p.daemon = True，则输出该行</span></span><br></pre></td></tr></table></figure><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h4><ul><li><p>概念<br>该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 release() 方法的调用次数减去 acquire() 的调用次数再加上一个初始值。如果需要， acquire() 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 value 的值时，默认为1。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(sem, num)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    print(<span class="string">'&#123;&#125; get semaphores'</span>.format(num))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sem = multiprocessing.Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = multiprocessing.Process(target=f, args=(sem, i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span> get semaphores</span><br><span class="line"><span class="number">2</span> get semaphores</span><br><span class="line"><span class="number">3</span> get semaphores</span><br><span class="line"><span class="number">4</span> get semaphores</span><br><span class="line"><span class="number">5</span> get semaphores</span><br></pre></td></tr></table></figure><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h4><ul><li><p>概念<br>实现事件对象的类。事件对象管理一个内部标志，调用 set() 方法可将其设置为true。调用 clear() 方法可将其设置为false。调用 wait() 方法将进入阻塞直到标志为true。这个标志初始时为false。</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traffic_light</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">'红灯亮'</span>)</span><br><span class="line">            e.clear()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">'绿灯亮'</span>)</span><br><span class="line">            e.set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(i, e)</span>:</span></span><br><span class="line">    e.wait()</span><br><span class="line">    print(<span class="string">'&#123;&#125;:车通过...'</span>.format(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = Event()</span><br><span class="line">    traffic = Process(target=traffic_light, args=(e,))</span><br><span class="line">    traffic.daemon = <span class="literal">True</span></span><br><span class="line">    traffic.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">6</span>:</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        car_obj = Process(target=car, args=(i, e))</span><br><span class="line">        car_obj.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">0</span>:车通过...</span><br><span class="line"><span class="number">1</span>:车通过...</span><br><span class="line"><span class="number">2</span>:车通过...</span><br><span class="line"><span class="number">4</span>:车通过...</span><br><span class="line"><span class="number">3</span>:车通过...</span><br><span class="line"><span class="number">5</span>:车通过...</span><br><span class="line"><span class="number">6</span>:车通过...</span><br><span class="line"><span class="number">7</span>:车通过...</span><br><span class="line"><span class="number">8</span>:车通过...</span><br></pre></td></tr></table></figure><hr><h3 id="CPython中GIL问题"><a href="#CPython中GIL问题" class="headerlink" title="CPython中GIL问题"></a>CPython中GIL问题</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>GIL全称为全局解释器锁，每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。它并不是python语言的特性，仅仅是由于历史的原因在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>多核环境下，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核优势，同时由于线程在多核上交替执行，反而又导致了核心切换时造成的资源消耗，会似的程序的运行更耗时。造成这样现象的原因就是因为CPython解释器中的GIL问题，即同一时刻一个进程只会有一把GIL，当多个线程需要执行任务时就会造成资源不足，进而线程等待GIL锁的释放，导致多核优势不能被利用。</p><h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><ul><li>计算密集型<br>CPython的GIL对于计算密集型的程序会有较大影响，因为同一时刻一个线程只会执行一个任务，所以对于计算密集型程序而言只能串行等待资源调用。</li><li>I/O密集型<br>对于I/O密集型程序而言，其瓶颈在于I/O，所以CPython的GIL对其影响并没有想象中的大。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>多进程<br>Python中的Multiprocessing库可以帮助实现多进程，从而在多核系统中利用多核资源。</li><li>Ctypes<br>CPython解释器的优势就是其可以调用C语言库来帮助实现程序对于多核系统的充分利用。</li><li>协程<br>协程又称微线程，是一种用户态的轻量级线程。python3.4之后内置了asyncio标准库，实现了内置协程，同时也可以通过第三方库类似Greenlet、Gevent实现协程。、</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python中-多-进程&quot;&gt;&lt;a href=&quot;#Python中-多-进程&quot; class=&quot;headerlink&quot; title=&quot;Python中(多)进程&quot;&gt;&lt;/a&gt;Python中(多)进程&lt;/h2&gt;&lt;h3 id=&quot;multiprocessing模块&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python进程线程初识</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%88%9D%E8%AF%86/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python进程线程初识/</id>
    <published>2021-01-10T08:43:47.000Z</published>
    <updated>2021-01-10T08:47:36.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程-amp-线程初识"><a href="#进程-amp-线程初识" class="headerlink" title="进程&amp;线程初识"></a>进程&amp;线程初识</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。<br>在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>进程的组成，通常包括：</p><ul><li>程序</li><li>数据</li><li>进程控制块</li></ul><p>进程有其自己的地址空间，通常包括：</p><ul><li>文本区域：存储处理器执行的代码</li><li>数据区域：存储变量和进程执行期间使用的动态分配的内存</li><li>堆栈：存储着活动过程调用的指令和本地变量。</li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>进程是对正在运行程序过程的一种抽象，进程的意义在于方便有效的管理、调度计算机的程序。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>动态性：进程是程序的执行过程，其产生和销毁都是动态产生的。</li><li>并发性：进程间完全独立，多个进程可以并发执行各自任务。</li><li>独立性：进程可以独立运行，其是独立运行的基本单位，也是系统分配资源和调度的独立单位。</li><li>异步性：进程间相互制约，使其执行具有间断性，即进程按各自独立的、不可预知的速度向前推进。</li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li><p>概念<br>进程调度是计算机的基本功能之一，其主要作用是将就绪队列中的程序进行调度，管理程序状态，使得多个程序都可以正常运行。<br>进程调度流程大致如下图：<br><img src="/images/post_imgs/process_schedule.jpg" alt></p></li><li><p>常见调度算法</p><ul><li>先来先服务调度算法（FCFS）<br>是最简单的调度算法，按先后顺序进行调度。<br>FCFS算法比较有利于长作业，而不利于短作业，适合于CPU密集型作业，而不适合I/O密集型作业。</li><li>短作业(进程)优先调度算法 (SPN)<br>是指对短作业(进程)优先调度的算法。<br>其调度算法是从就绪队列中依次选出预估运行时间最短的进程进行处理。</li><li>优先权调度算法的类型<br>是指对高权限的进程优先调度的算法。<br>其调度算法是从就绪队列中依次选出预设权限最高的进程进行处理。</li><li>高响应比优先调度算法 (HRRN)<br>高响应比优先调度算法相比短作业优先调度算法对长作业相对友好，其为每个作业分配了动态优先权，使得作业的优先权随等待时间的增加而增加，进而可以使长作业有机会得到优先处理。<br>其中，响应比 =（进程执行时间 + 进程等待时间）/ 进程执行时间。</li><li>时间片轮转法 (RR)<br>系统将所有就绪任务按照先来先服务的原则循序排列，每次调度则分配给任务一个固定的时间片，以此类推直至所有任务调度完成。</li><li>反馈调度算法 (Feedback)<br>设置多个就绪队列，多个就绪队列的优先级逐级降低，且优先级越高的队列执行时间片越小。就绪任务以先来先服务原则进入队列，首先将其放置优先级最高队列队尾，如果在该队列时间片时间内没有任务没有执行完成，便将其转入下一级队列队尾，以此类推。仅当上级队列空闲时才会执行下级队列。</li></ul></li></ul><p><img src="/images/post_imgs/Feedback.jpg" alt></p><h4 id="创建-终止进程"><a href="#创建-终止进程" class="headerlink" title="创建/终止进程"></a>创建/终止进程</h4><ul><li><p>创建进程<br>新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。<br>通常创建进程的方式包括：系统初始化进程、创建子进程、用户交互创建进程、任务创建进程</p></li><li><p>终止进程<br>终止进程包括主动终止和被动终止，大概包括以下几种方式：正常退出、异常退出、主动杀死进程</p></li></ul><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>线程是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。<br>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。<br>但同一进程中的多个线程有各自的调用栈（call stack）、寄存器环境（register context）、线程本地存储（thread-local storage）。</p><h4 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h4><ul><li>产生（spawn）</li><li>中断（block）</li><li>非中断（unblock）</li><li>结束（finish）</li></ul><h4 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h4><ul><li>线程内核对象</li><li>线程环境块(TEB)</li><li>用户模式栈</li><li>内核模式栈</li><li>DLL线程连接和线程分离通知</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>轻型实体：线程中拥有的资源可以最小化保证程序的独立运行</li><li>独立调度和分派的基本单位</li><li>共享进程资源</li><li>可并发运行</li></ul><h4 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h4><ul><li><p>内核线程</p><ul><li>内核线程可以独立运行任务，可以利用其处理异步事件。内核线程使用的资源是内核栈和上下文切换时保存寄存器的空间。</li><li>支持多线程的内核叫做多线程内核(Multi-Threads kernel )。</li><li>内核线程只运行在内核态，不受用户态上下文的拖累。</li><li>处理器竞争：可以在全系统范围内竞争处理器资源；</li><li>使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间</li><li>调度：调度的开销可能和进程自身差不多昂贵</li><li>同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。</li></ul></li><li><p>轻量级线程</p><ul><li>轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。</li><li>特点：轻量级线程只有一个最小的执行上下文和调度程序所需的统计信息。</li><li>处理器竞争：轻量级线程是由内核支持，所以可以在全系统范围竞争处理器资源。</li><li>使用资源：与父进程共享进程地址空间</li><li>局限：轻量级线程的创建、同步、销毁等操作都需要系统调用，即用户态与内核态切换，所以系统调用代价较高；每个轻量级线程都需要一个内核线程支持，所以消耗内核资源较多，不宜大量创建。</li></ul></li><li><p>用户线程</p><ul><li>用户线程是基于用户空间建立的线程，其创建、同步、销毁等操作都基于用户空间，不需要消耗内核资源，所以用户线程消耗资源低，线程高效。</li><li>处理器竞争：用户线程基于用户空间创建，其对于内核是透明的，所以用户线程所属的进程参与竞争处理器资源，所属进程下的所有线程竞争进程的资源。</li><li>使用资源：与所属进程共享进程地址空间和系统资源。</li><li>调度：用户线程在其所属进程内参数调度</li></ul></li></ul><hr><h3 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h3><ul><li>Erlang 之父 Joe Armstrong 用于解释并发与并行的图示<br><img src="/images/post_imgs/concurrent.jpg" alt></li></ul><h4 id="并发计算"><a href="#并发计算" class="headerlink" title="并发计算"></a>并发计算</h4><ul><li>概念<br>并发（Concurrent），是一种程序计算的形式，在系统中，至少有两个以上的计算在同时运作，计算结果可能同时发生。</li></ul><h4 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h4><ul><li>概念<br>并行计算（Parallel）一般是指许多指令得以同时进行的计算模式。在同时进行的前提下，可以将计算的过程分解成小部分，之后以并发方式来加以解决。所谓并发方式可以简单理解为多个任务交替运行，但是同一时刻只会有一个任务被执行。</li></ul><hr><h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>概念<br>同步（Synchronous）是指计算机在处理多个任务时，处理过程顺序执行，是线性执行方式。前一个任务执行完成并返回结果后才会执行下一个任务，以此类推。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>概念<br>异步（Asynchronous）是指计算机处理多个任务时，无需遵循顺序执行的方式，不需要等待任务返回结果即可开始其他任务，当任务执行完成时，使用回调的方式返回结果。</li></ul><hr><h3 id="阻塞-amp-非阻塞"><a href="#阻塞-amp-非阻塞" class="headerlink" title="阻塞&amp;非阻塞"></a>阻塞&amp;非阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>概念<br>进程/线程被操作系统挂起，需要等待当前任务执行完成后才可以执行其他任务。</li></ul><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul><li>概念<br>进程/线程被操作系统不被挂起，可以执行其他任务。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程-amp-线程初识&quot;&gt;&lt;a href=&quot;#进程-amp-线程初识&quot; class=&quot;headerlink&quot; title=&quot;进程&amp;amp;线程初识&quot;&gt;&lt;/a&gt;进程&amp;amp;线程初识&lt;/h2&gt;&lt;h3 id=&quot;进程（Process）&quot;&gt;&lt;a href=&quot;#进程（Pro
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>PythonSocketServer实现多并发</title>
    <link href="https://elijahyg.github.io/2021/01/10/PythonSocketServer%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B9%B6%E5%8F%91/"/>
    <id>https://elijahyg.github.io/2021/01/10/PythonSocketServer实现多并发/</id>
    <published>2021-01-10T08:36:33.000Z</published>
    <updated>2021-01-10T08:39:14.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socketserver"><a href="#Socketserver" class="headerlink" title="Socketserver"></a>Socketserver</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>socketserver模块简化了编写网络服务器的任务。</p><hr><h3 id="Socketserver实现服务端与多个客户端交互"><a href="#Socketserver实现服务端与多个客户端交互" class="headerlink" title="Socketserver实现服务端与多个客户端交互"></a>Socketserver实现服务端与多个客户端交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            recv_msg = self.request.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> recv_msg == <span class="string">'q'</span>:</span><br><span class="line">                self.request.send(<span class="string">b'q'</span>) <span class="comment"># 输入'q'退出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(recv_msg)</span><br><span class="line">            info = input(<span class="string">'服务端 &gt;&gt;&gt;'</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> info:</span><br><span class="line">                self.request.send(info.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'localhost'</span>, <span class="number">8889</span>), MyServer)</span><br><span class="line">    server.allow_reuse_address = <span class="literal">True</span></span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)</span><br><span class="line">sk.connect((<span class="string">'localhost'</span>, <span class="number">8889</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = input(<span class="string">'客户端 &gt;&gt;&gt;'</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> info == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">elif</span> info == <span class="string">'q'</span>:</span><br><span class="line">        sk.send(info.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 输入'q'退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sk.send(info.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        recv_msg = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        print(recv_msg)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Socketserver&quot;&gt;&lt;a href=&quot;#Socketserver&quot; class=&quot;headerlink&quot; title=&quot;Socketserver&quot;&gt;&lt;/a&gt;Socketserver&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python黏包问题</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E9%BB%8F%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python黏包问题/</id>
    <published>2021-01-10T08:36:07.000Z</published>
    <updated>2021-01-10T08:38:52.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="黏包问题"><a href="#黏包问题" class="headerlink" title="黏包问题"></a>黏包问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>黏包问题只存在于基于TCP协议的Socket通信过程中，其是指发送者将多个数据包一起发送给接收者，造成接收者不能区分每个数据包的分界。</p><hr><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><h4 id="发送者因素"><a href="#发送者因素" class="headerlink" title="发送者因素"></a>发送者因素</h4><p>基于TCP协议进行通信时，TCP协议默认会使用Nagle算法。Nagle算法是以减少数据包发送量来增进TCP/IP网络的性能。其工作方式是合并一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。<br>所以，基于TCP协议的Nagle算法，就引发了发送者所导致的黏包现象。</p><h4 id="接收者因素"><a href="#接收者因素" class="headerlink" title="接收者因素"></a>接收者因素</h4><p>接收者受到通信数据后，类似上面所说的Nagle算法，接收者也会首先将数据保存至缓存中，由应用层程序主动从缓存中获取数据进行读取。这样就会造成如果接收数据的速度大于读取数据的速度，数据会被暂存至缓存，也就是多个数据包的分界不能区分，造成黏包问题。</p><hr><h3 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h3><h4 id="发送者处理"><a href="#发送者处理" class="headerlink" title="发送者处理"></a>发送者处理</h4><p>由于发送者造成的黏包问题主要是因为Nagle算法所导致，所以我们解决的方式也就是将Nagle算法禁用，进而解决由于发送者所造成的的黏包问题。使用TCP_NODELAY选项来关闭Nagle算法。</p><h4 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h4><p>由于接收端没有可以处理黏包问题的方法，我们只能从应用程序进行逻辑上的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="comment"># 1、发送报头长度</span></span><br><span class="line"><span class="comment"># 2、发送编码后的报头内容</span></span><br><span class="line"><span class="comment"># 3、发送消息体</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="keyword">import</span> socket, struct, json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment"># 重复利用端口</span></span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sk.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> % cmd)</span><br><span class="line">        res = subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                               shell=<span class="literal">True</span>,</span><br><span class="line">                               stdin=subprocess.PIPE,</span><br><span class="line">                               stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE)</span><br><span class="line">        err = res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg = err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg = res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">'data_size'</span>:len(back_msg)&#125;  <span class="comment"># 使用dict整理报头</span></span><br><span class="line">        head_json=json.dumps(headers)  <span class="comment"># 将报头序列化</span></span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=<span class="string">'utf-8'</span>)  <span class="comment"># 编码序列化报头</span></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>, len(head_json_bytes)))  <span class="comment"># 发送报头长度</span></span><br><span class="line">        conn.send(head_json_bytes)  <span class="comment"># 发送编码后的报头内容</span></span><br><span class="line">        conn.sendall(back_msg)  <span class="comment"># 发送消息体</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="comment"># 1、接收报头长度</span></span><br><span class="line"><span class="comment"># 2、根据报头长度接收报头内容→解码→反序列化</span></span><br><span class="line"><span class="comment"># 3、根据报头内容获取消息体</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct, json</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd=input(<span class="string">'&gt;&gt;: '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(bytes(cmd,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">'i'</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data_len=head_json[<span class="string">'data_size'</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;黏包问题&quot;&gt;&lt;a href=&quot;#黏包问题&quot; class=&quot;headerlink&quot; title=&quot;黏包问题&quot;&gt;&lt;/a&gt;黏包问题&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>PythonSocket(套接字)</title>
    <link href="https://elijahyg.github.io/2021/01/10/PythonSocket-%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://elijahyg.github.io/2021/01/10/PythonSocket-套接字/</id>
    <published>2021-01-10T08:30:33.000Z</published>
    <updated>2021-01-10T08:34:32.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket（套接字）"><a href="#Socket（套接字）" class="headerlink" title="Socket（套接字）"></a>Socket（套接字）</h2><h3 id="客户端-服务器架构（C-S架构）"><a href="#客户端-服务器架构（C-S架构）" class="headerlink" title="客户端/服务器架构（C/S架构）"></a>客户端/服务器架构（C/S架构）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>主从式架构 (也称客户端/服务器架构、C/S架构），是一种网络架构，它把客户端（Client）与服务器（Server）区分开。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、游戏服务器等。</p><h3 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。为了简化计算机程序与TCP/IP协议族的复杂交互协议，封装了更方便的接口以便更快速的让用户组织数据，进行网络传输。<br>更形象的来说，套接字实际上是一个通信端点，每个套接字都有一个套接字序号，包括主机的IP地址与一个16位的主机端口号，即：主机IP地址：端口号。</p><h4 id="Socket种类"><a href="#Socket种类" class="headerlink" title="Socket种类"></a>Socket种类</h4><p>为满足不同情况下的通信需求，通常网络会提供三种Socket以供选择。</p><ul><li><p>流式套接字（SOCK-STREAM）<br>是一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。<br>通常使用TCP协议来实现字节流的传输，以满足需要发送大量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</p></li><li><p>数据报套接字（SOCK-DGRAM）<br>是一种无连接、不可靠的双向数据传输服务。<br>数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。<br>通常使用UDP协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</p></li><li><p>原始套接字（SOCK-RAW）<br>该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。 </p></li></ul><h4 id="伯克利套接字"><a href="#伯克利套接字" class="headerlink" title="伯克利套接字"></a>伯克利套接字</h4><ul><li>概念</li></ul><p>伯克利套接字，又称为BSD 套接字(BSD sockets)是一种应用程序接口（API），用于网络套接字与Unix域套接字，包括了一个用C语言写成的应用程序开发库，主要用于实现进程间通讯，在计算机网络通讯方面被广泛使用。</p><p>伯克利套接字应用程序接口形成了事实上的网络套接字的标准精髓。 大多数其他的编程语言使用与这套用C语言写成的应用程序接口类似的接口。 这套应用程序接口也被用于Unix域套接字（Unix domain sockets），后者可以在单机上为进程间通讯（IPC）的接口。</p><ul><li>使用伯克利套接字的系统<ul><li>Windows Sockets (Winsock) ，和Berkeley Sockets很相似，最初是为了便于移植Unix程序。</li><li>Java Sockets</li><li>Python sockets</li><li>Perl sockets</li></ul></li></ul><h3 id="Python语言下套接字（Socket）简单使用示例"><a href="#Python语言下套接字（Socket）简单使用示例" class="headerlink" title="Python语言下套接字（Socket）简单使用示例"></a>Python语言下套接字（Socket）简单使用示例</h3><h4 id="基于TCP协议的Socket"><a href="#基于TCP协议的Socket" class="headerlink" title="基于TCP协议的Socket"></a>基于TCP协议的Socket</h4><p>可靠的、面向连接的双向数据传输。</p><ul><li>单服务端、单客户端示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)  <span class="comment"># 此处作用解决Address already in use的情况，可以加入socket配置重用ip和端口</span></span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8088</span>))</span><br><span class="line">sk.listen()</span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    res = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(res)</span><br><span class="line">    info = input(<span class="string">'请输入：\n&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(info)</span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk= socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = input(<span class="string">'请输入：\n&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    sk.send(info)</span><br><span class="line">    res = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(res)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><ul><li>单服务端、多客户端示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="comment"># listen([backlog])中的[backlog]参数代表服务端允许多少客户端连接到服务端，即阻塞队列长度，所以一共能与服务器连接的客户端共有backlog+1个</span></span><br><span class="line">sk.listen(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sk.accept() <span class="comment"># sk.accept()放在循环内部是为了每次与同一个客户端交互结束后会重新建立conn连接，以便下一个客户端连入</span></span><br><span class="line">    res = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> res == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'收到'</span>,res)</span><br><span class="line">    info = input(<span class="string">'请输入&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(info)</span><br><span class="line">    conn.close() <span class="comment"># 同上面sk.accept()的作用</span></span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = input(<span class="string">'请输入&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">if</span> info == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sk.send(info)</span><br><span class="line">    res = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(res)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><h4 id="基于UDP协议的Socket"><a href="#基于UDP协议的Socket" class="headerlink" title="基于UDP协议的Socket"></a>基于UDP协议的Socket</h4><p>无连接、不可靠的双向数据传输</p><ul><li>单服务端、单客户端示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">udp_server_client.bind(ip_port)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(msg,addr)</span><br><span class="line">    udp_server_client.sendto(msg.upper(),addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line">    udp_server_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line">    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)</span><br><span class="line">    print(back_msg.decode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure><ul><li>单服务端、多客户端示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 服务端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg, addr = sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'消息地址：'</span> + addr)</span><br><span class="line">    <span class="keyword">if</span> msg.decode(<span class="string">'utf-8'</span>) == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    info = input(<span class="string">'&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    sk.sendto(info, addr)</span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 客户端 ----------</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = input(<span class="string">'client：'</span>)</span><br><span class="line">    info = (<span class="string">'\033[33m来自client的消息 ：%s\033[0m'</span> % info).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    sk.sendto(info, ip_port)</span><br><span class="line">    msg, addr = sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> msg.decode(<span class="string">'utf-8'</span>) == <span class="string">'bye'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Socket（套接字）&quot;&gt;&lt;a href=&quot;#Socket（套接字）&quot; class=&quot;headerlink&quot; title=&quot;Socket（套接字）&quot;&gt;&lt;/a&gt;Socket（套接字）&lt;/h2&gt;&lt;h3 id=&quot;客户端-服务器架构（C-S架构）&quot;&gt;&lt;a href=&quot;#客
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python网络编程初识.md</title>
    <link href="https://elijahyg.github.io/2021/01/10/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E8%AF%86/"/>
    <id>https://elijahyg.github.io/2021/01/10/Python网络编程初识/</id>
    <published>2021-01-10T08:17:17.000Z</published>
    <updated>2021-01-10T08:23:09.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程初识"><a href="#网络编程初识" class="headerlink" title="网络编程初识"></a>网络编程初识</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>网络协议，也称通信协议或传输协议。在电信中是指在任何物理介质中允许两个或多个在传输系统中的终端之间传播信息的系统标准，也是指计算机通信或网络设备的共同语言。通俗来讲，网络协议就是指信息在网络设备以何种语法规范进行传播，协议就是规定了通信时信息的格式以及如何进行处理。</p><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><ul><li><p>概念<br>开放式系统互联模型（Open System Interconnection Model，简称为OSI模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p></li><li><p>七层模型<br><img src="/images/post_imgs/7_osi.png" alt></p></li><li><p>五层模型</p></li></ul><p><img src="/images/post_imgs/5_osi.jpg" alt></p><hr><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>互联网协议套件（缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（TCP/IP Protocol Stack）。<br>TCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。</p><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><ul><li><p>概念<br>网际协议（IP,也称互联网协议）是用于分组交换数据网络的一种协议。<br>IP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，已有 30 多年历史。IPv4 地址的长度为 32 位，采用十进制，如 192.1.1.1，最多有 4,294,967,296 个 IPv4 地址可用。尽管世界各地正在积极部署IPv6，IPv6 相比 IPv4 最显著的变化在于地址长度增长到了 128 位，可用的地址数量大为增加，理论上有 340,282,366,920,938,463,463,374,607,431,768,211,456 个，即 340 万亿兆，通常采用十六进制表示，分为8组，每4个数为一组，以冒号分隔。</p></li><li><p>IPv4地址耗尽<br>2019-11-25 UTC+1 15:35 时，一封来自欧洲 RIPE NCC 的邮件中得到确认：全球的IPv4地址已经彻底耗尽。</p></li></ul><p><img src="/images/post_imgs/ipv4_email.jpg" alt></p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ul><li><p>概念<br>传输控制协议（TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议。<br>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p></li><li><p>基本原理<br>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认信息（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和。</p></li><li><p>TCP状态图</p></li></ul><p><img src="/images/post_imgs/TCP_status.png" alt></p><hr><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>网络编程最主要的工作就是在发送端把信息通过规定好的协议进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。换句话说，网络把不同的网络设备互联，让数据信息可以通过网络进行交换，对于我们而言就是计算机与计算机之间的通信交互，所以网络编程就是利用程序实现网络设备（如计算机）之间的通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络编程初识&quot;&gt;&lt;a href=&quot;#网络编程初识&quot; class=&quot;headerlink&quot; title=&quot;网络编程初识&quot;&gt;&lt;/a&gt;网络编程初识&lt;/h2&gt;&lt;h3 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python异常处理</title>
    <link href="https://elijahyg.github.io/2020/11/22/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://elijahyg.github.io/2020/11/22/Python异常处理/</id>
    <published>2020-11-22T15:39:21.000Z</published>
    <updated>2020-11-22T16:33:58.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h4><p>语法错误又称解析错误，语法错误是在语法层面出现的代码错误，python解释器可以在代码运行之前对语法错误进行检查，并输出出现语法错误的具体位置和错误原因。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul><li><p>概念<br>即使在语法上是正确的，但在尝试执行时，它仍可能会引发错误。在执行时检测到的错误被称为异常，异常不一定会导致严重后果，我们可以利用异常处理来解决异常。</p></li><li><p>基本语法</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>示例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义除法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        result = x / y</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:  <span class="comment"># 如果发生ZeroDivisionError异常，则进行下面的处理</span></span><br><span class="line">        print(<span class="string">"division by zero!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 如果程序正常执行，则输出除法结果</span></span><br><span class="line">        print(<span class="string">"result is"</span>, result)</span><br><span class="line">    <span class="keyword">finally</span>:  <span class="comment"># 定义清理操作，程序不论是否触发异常，一定会执行finally，通常进行清理操作</span></span><br><span class="line">        print(<span class="string">"executing finally clause"</span>)</span><br><span class="line"></span><br><span class="line">divide(<span class="number">1</span>,<span class="number">0</span>)  <span class="comment"># 函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">division by zero!</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="异常种类"><a href="#异常种类" class="headerlink" title="异常种类"></a>异常种类</h3><h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><table><thead><tr><th>异常名称</th><th>描述</th></tr></thead><tbody><tr><td>BaseException</td><td>所有异常的基类</td></tr><tr><td>SystemExit</td><td>解释器请求退出</td></tr><tr><td>KeyboardInterrupt</td><td>用户中断执行(通常是输入^C)</td></tr><tr><td>Exception</td><td>常规错误的基类</td></tr><tr><td>StopIteration</td><td>迭代器没有更多的值</td></tr><tr><td>GeneratorExit</td><td>生成器(generator)发生异常来通知退出</td></tr><tr><td>StandardError</td><td>所有的内建标准异常的基类</td></tr><tr><td>ArithmeticError</td><td>所有数值计算错误的基类</td></tr><tr><td>FloatingPointError</td><td>浮点计算错误</td></tr><tr><td>OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td>ZeroDivisionError</td><td>除(或取模)零(所有数据类型)</td></tr><tr><td>AssertionError</td><td>断言语句失败</td></tr><tr><td>AttributeError</td><td>对象没有这个属性</td></tr><tr><td>EOFError</td><td>没有内建输入,到达EOF标记</td></tr><tr><td>EnvironmentError</td><td>操作系统错误的基类</td></tr><tr><td>IOError</td><td>输入/输出操作失败</td></tr><tr><td>OSError</td><td>操作系统错误</td></tr><tr><td>WindowsError</td><td>系统调用失败</td></tr><tr><td>ImportError</td><td>导入模块/对象失败</td></tr><tr><td>LookupError</td><td>无效数据查询的基类</td></tr><tr><td>IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td>KeyError</td><td>映射中没有这个键</td></tr><tr><td>MemoryError</td><td>内存溢出错误(对于Python解释器不是致命的)</td></tr><tr><td>NameError</td><td>未声明/初始化对象(没有属性)</td></tr><tr><td>UnboundLocalError</td><td>访问未初始化的本地变量</td></tr><tr><td>ReferenceError</td><td>弱引用(Weakreference)试图访问已经垃圾回收了的对象</td></tr><tr><td>RuntimeError</td><td>一般的运行时错误</td></tr><tr><td>NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td>SyntaxError Python</td><td>语法错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>TabError</td><td>Tab和空格混用</td></tr><tr><td>SystemError</td><td>一般的解释器系统错误</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>UnicodeErrorUnicode</td><td>相关的错误</td></tr><tr><td>UnicodeDecodeErrorUnicode</td><td>解码时的错误</td></tr><tr><td>UnicodeEncodeErrorUnicode</td><td>编码时错误</td></tr><tr><td>UnicodeTranslateErrorUnicode</td><td>转换时错误</td></tr><tr><td>Warning</td><td>警告的基类</td></tr><tr><td>DeprecationWarning</td><td>关于被弃用的特征的警告</td></tr><tr><td>FutureWarning</td><td>关于构造将来语义会有改变的警告</td></tr><tr><td>OverflowWarning</td><td>旧的关于自动提升为长整型(long)的警告</td></tr><tr><td>PendingDeprecationWarning</td><td>关于特性将会被废弃的警告</td></tr><tr><td>RuntimeWarning</td><td>可疑的运行时行为(runtimebehavior)的警告</td></tr><tr><td>SyntaxWarning</td><td>可疑的语法的警告</td></tr><tr><td>UserWarning</td><td>用户代码生成的警告</td></tr></tbody></table><h4 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h4><p>由下图的异常层级结构我们可以看出，BaseException 所有内置异常的基类。但是官方不建议在实际使用时直接继承使用，而是建议继承Exception类，几乎所有的异常都是Exception的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      | +-- FloatingPointError</span><br><span class="line">      | +-- OverflowError</span><br><span class="line">      | +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      | +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      | +-- IndexError</span><br><span class="line">      | +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      | +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      | +-- BlockingIOError</span><br><span class="line">      | +-- ChildProcessError</span><br><span class="line">      | +-- ConnectionError</span><br><span class="line">      | | +-- BrokenPipeError</span><br><span class="line">      | | +-- ConnectionAbortedError</span><br><span class="line">      | | +-- ConnectionRefusedError</span><br><span class="line">      | | +-- ConnectionResetError</span><br><span class="line">      | +-- FileExistsError</span><br><span class="line">      | +-- FileNotFoundError</span><br><span class="line">      | +-- InterruptedError</span><br><span class="line">      | +-- IsADirectoryError</span><br><span class="line">      | +-- NotADirectoryError</span><br><span class="line">      | +-- PermissionError</span><br><span class="line">      | +-- ProcessLookupError</span><br><span class="line">      | +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      | +-- NotImplementedError</span><br><span class="line">      | +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      | +-- IndentationError</span><br><span class="line">      | +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      | +-- UnicodeError</span><br><span class="line">      | +-- UnicodeDecodeError</span><br><span class="line">      | +-- UnicodeEncodeError</span><br><span class="line">      | +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure><hr><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>raise 语句允许程序员强制发生指定的异常。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)  <span class="comment"># 主动抛出异常</span></span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    print(<span class="string">'An exception flew by!'</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><hr><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>程序可以通过创建新的异常类来命名它们自己的异常。异常通常应该直接或间接地从 Exception 类派生。自定义异常类通常要保持功能简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span>  <span class="comment"># 继承Exception</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span>  <span class="comment"># 继承Exception的子类Error</span></span><br><span class="line">    <span class="string">"""Raised when an operation attempts a state transition that's not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure><hr><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>assert 语句是在程序中插入调试性断言的简便方式</p><h4 id="断言的两种形式"><a href="#断言的两种形式" class="headerlink" title="断言的两种形式"></a>断言的两种形式</h4><ul><li>简单形式：<code>assert expression</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单形式断言，等价于</span></span><br><span class="line"><span class="keyword">if</span> __debug__:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression: <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure><ul><li>扩展形式：<code>assert expression1, expression2</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#扩展形式断言，等价于</span></span><br><span class="line"><span class="keyword">if</span> __debug__:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> expression1: <span class="keyword">raise</span> AssertionError(expression2)</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span> <span class="comment"># 断言1 == 1</span></span><br><span class="line">        print(<span class="string">'【NO·1】断言成功时执行'</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">        print(<span class="string">'【NO·2】断言失败时执行'</span>) <span class="comment"># 断言此处会失败，进而抛出AssertionError异常</span></span><br><span class="line">    <span class="keyword">except</span> Exception: <span class="comment"># 捕获AssertionError异常</span></span><br><span class="line">        print(<span class="string">"Catch AssertionError "</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line">【NO·<span class="number">1</span>】断言成功时执行</span><br><span class="line">Catch AssertionError</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python方法</title>
    <link href="https://elijahyg.github.io/2020/07/14/Python%E6%96%B9%E6%B3%95/"/>
    <id>https://elijahyg.github.io/2020/07/14/Python方法/</id>
    <published>2020-07-14T14:49:18.000Z</published>
    <updated>2020-07-14T14:50:18.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>属性方法即使用<code>@property</code>装饰器，将函数中的方法转化为”属性”，即可以直接使用访问属性的方式，即<code>属性名.方法</code>进行方法的调用。</p><h4 id="内置函数property及-property"><a href="#内置函数property及-property" class="headerlink" title="内置函数property及@property"></a>内置函数<code>property</code>及<code>@property</code></h4><ul><li><code>property</code>函数<br>property函数的作用是托管类的属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="string">'This is x'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line">print(c.x)  <span class="comment"># 调用getter</span></span><br><span class="line">c.x = <span class="string">'value'</span>  <span class="comment"># 调用setter</span></span><br><span class="line"><span class="keyword">del</span> c.x  <span class="comment"># 调用deleter</span></span><br></pre></td></tr></table></figure><ul><li><code>@property</code>装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面类与上述例子具有相同的效果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""I'm the 'x' property."""</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line">print(c.x)  <span class="comment"># 调用getter</span></span><br><span class="line">c.x = <span class="string">'value'</span>  <span class="comment"># 调用setter</span></span><br><span class="line"><span class="keyword">del</span> c.x  <span class="comment"># 调用deleter</span></span><br></pre></td></tr></table></figure><hr><h3 id="类方法-classmethod"><a href="#类方法-classmethod" class="headerlink" title="类方法(@classmethod)"></a>类方法(@classmethod)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>类方法的调用可以在类上进行也可以在实例上进行。<br>@classmethod装饰器将一个方法封装成类方法。</p><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ul><li>python中的类方法解决了python中不可以通过不同的参数来重载不同的构造函数的问题。即python可以通过类方法实现在实例化前进行某些操作，进而实现类似于多个构造函数的效果。</li><li>对于某些需要在类实例化之前做些交互操作提供实现方法。</li><li>在继承的时，保证了子类使用可选构造函数构造出来的类是子类的实例而不是父类的实例。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'this is bar_1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar_2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'this is bar_2'</span>)</span><br><span class="line">        cls().bar_1()</span><br><span class="line"></span><br><span class="line">Foo.bar_2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">this <span class="keyword">is</span> bar_2</span><br><span class="line">this <span class="keyword">is</span> bar_1</span><br></pre></td></tr></table></figure><hr><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>静态方法的调用可以在类上进行也可以在实例上进行。</p><h4 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h4><p>静态方法其本质是函数，虽然静态方法定义在类中，但是静态方法并不是类或者类实例的方法，而可以理解为与类没有直接关系的函数，那么静态方法定义在类中的意义是因为可以将一些功能性的工具函数放在类中，方便调用。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'this is bar_1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'this is bar_2'</span>)</span><br><span class="line"></span><br><span class="line">Foo.bar_2()</span><br></pre></td></tr></table></figure><hr><h3 id="特殊成员方法-魔术方法"><a href="#特殊成员方法-魔术方法" class="headerlink" title="特殊成员方法(魔术方法)"></a>特殊成员方法(魔术方法)</h3><h4 id="常用魔术方法"><a href="#常用魔术方法" class="headerlink" title="常用魔术方法"></a>常用魔术方法</h4><p><code>__new__(cls[, …])</code>：<br>python3中在类实例化过程中首先要调用<code>__new__(cls[, …])</code>方法，其第一个参数是当前类，其余参数在随后的过程中传递至<code>__init__</code>方法。</p><p><code>__init__(self[, …])</code>：<br>可以理解为python中的构造方法，当一个实例被创建时进行初始化的方法。</p><p><code>__del__(self)</code>：<br>python中的析构方法，当实例被销毁时调用该方法，可以执行清理相关功能。</p><p><code>__call__(self[, args…])</code>：<br>允许一个类的实例像函数一样被调用：foo(x, y) 调用 <code>foo.__ call__(x, y)</code></p><p><code>__len__(self)</code>：<br>调用len() 时的操作</p><p><code>__repr__(self)</code>：<br>调用repr() 时的操作</p><p><code>__str__(self)</code>：<br>调用str() 时的操作</p><p><code>__bytes__(self)</code>：<br>调用bytes() 时的操作</p><p><code>__hash__(self)</code>：<br>调用hash() 时的操作</p><p><code>__bool__(self)</code>：<br>调用bool() 时的操作，返回True或False</p><p><code>__format__(self, format_spec)</code>：<br>调用format() 时的操作</p><h4 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h4><p><code>__getattr__(self, name)</code>：<br>当尝试获取不存在的属性时的操作</p><p><code>__getattribute__(self, name)</code>：<br>当前类的属性被访问时的操作</p><p><code>__setattr__(self, name, value)</code>：<br>定义当一个属性被设置时的行为</p><p><code>__delattr__(self, name)</code>：<br>当属性被删除时的操作</p><p><code>__dir__(self)</code>：<br>调用dir()时的操作</p><p><code>__get__(self, instance, owner)</code>：<br>当获得描述符的值时的操作</p><p><code>__set__(self, instance, value)</code>：<br>当修改描述符的值时的操作</p><p><code>__delete__(self, instance)</code>：<br>当删除描述符的值时的操作</p><h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><p><code>__lt__(self, other)</code>：<br>调用小于号时的操作：即x &lt; y 调用 x.lt(y)<br><code>__le__(self, other)</code>：<br>调用小于等于号时的操作：即x &lt;= y 调用 x.le(y)<br><code>__eq__(self, other)</code>：<br>调用等于号时的操作：即x == y 调用 x.eq(y)<br><code>__ne__(self, other)</code>：<br>调用不等于号时的操作：即x != y 调用 x.ne(y)<br><code>__gt__(self, other)</code>：<br>调用大于号时的操作：即x &gt; y 调用 x.gt(y)<br><code>__ge__(self, other)</code>：<br>调用大于等于号时的操作：即x &gt;= y 调用 x.ge(y)</p><h4 id="算数运算符-amp-反运算"><a href="#算数运算符-amp-反运算" class="headerlink" title="算数运算符 &amp; 反运算"></a>算数运算符 &amp; 反运算</h4><blockquote><p>反运算：即当左操作数不存在对应方法时，则检查右操作数是否有相对应的反运算符，若有则进行对应运算，若没有则抛出异常</p></blockquote><p><code>__radd/add__(self, other)</code>：<br>调用加法时的操作：<code>+</code></p><p><code>__rsub/sub__(self, other)</code>：<br>调用减法时的操作：<code>-</code></p><p><code>__rmul/mul__(self, other)</code>：<br>调用乘法时的操作：<code>*</code></p><p><code>__rtruediv/truediv__(self, other)</code>：<br>调用除法时的操作：<code>/</code></p><p><code>__rfloordiv/floordiv__(self, other)</code>：<br>调用整除时的操作：<code>//</code></p><p><code>__rmod/mod__(self, other)</code>：<br>调用取模运算时的操作：<code>%</code></p><p><code>__rdivmod/divmod__(self, other)</code>：<br>调用 divmod() 时的操作</p><p><code>__rpow/pow__(self, other[, modulo])</code>：<br>调用 power() 或 <code>**</code> 时的操作</p><p><code>__rlshift/lshift__(self, other)</code>：<br>调用按位左移时的操作：<code>&lt;&lt;</code></p><p><code>__rrshift/rshift__(self, other)</code>：<br>调用按位右移时的操作：<code>&gt;&gt;</code></p><p><code>__rand/and__(self, other)</code>：<br>调用按位与时的操作：<code>&amp;</code></p><p><code>__rxor/xor__(self, other)</code>：<br>调用按位异或时的操作：<code>^</code></p><p><code>__ror/or__(self, other)</code>：<br>调用按位或时的操作：<code>|</code></p><h4 id="增量赋值运算"><a href="#增量赋值运算" class="headerlink" title="增量赋值运算"></a>增量赋值运算</h4><p>上述算数运算符前增加<code>i</code>，则转换为对应的增量赋值运算符，对应操作转换为赋值运算<br>例如：<code>__iadd__(self, other)</code>，则调用赋值加法时的操作，即<code>+=</code></p><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p><code>__pos__(self)</code>：<br>调用正号时的操作</p><p><code>__neg__(self)</code>：<br>调用负号时的操作</p><p><code>__abs__(self)</code>：<br>调用 abs() 时的操作</p><p><code>__invert__(self)</code>：<br>调用按位求反时的操作</p><h4 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h4><p><code>__complex__(self)</code>：<br>调用 complex() 时的操作</p><p><code>__int__(self)</code>：<br>调用 int() 时的操作</p><p><code>__float__(self)</code>：<br>调用 float() 时的操作</p><p><code>__round__(self[, n])</code>：<br>调用 round() 时的操作</p><p><code>__index__(self)</code>：<br>调用此方法以实现 operator.index() 以及 Python 需要无损地将数字对象转换为整数对象的场合（例如切片或是内置的 bin(), hex() 和 oct() 函数)。存在此方法表明数字对象属于整数类型。必须返回一个整数。</p><h4 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h4><p><code>__enter__(self)</code>：<br>当使用 with 语句时，返回值被 with 语句的目标或者 as 后的名字绑定。</p><p><code>__exit__(self, exc_type, exc_value, traceback)</code>：<br>退出关联到此对象的运行时上下文。通常用于处理异常、清除处理或做一些代码块执行完毕之后的日常工作。</p><h4 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h4><p><code>__len__(self)</code>：<br>调用 len() 时的操作</p><p><code>__getitem__(self, key)</code>：<br>获取容器中元素时的操作: self[key]</p><p><code>__setitem__(self, key, value)</code>：<br>设置容器中元素时的操作: self[key] = value</p><p><code>__delitem__(self, key)</code>：<br>删除容器中元素时的操作: del self[key]</p><p><code>__iter__(self)</code>：<br>对容器中元素进行迭代时的操作</p><p><code>__reversed__(self)</code>：<br>被 reversed() 调用时的操作</p><p><code>__contains__(self, item)</code>：<br>调用 in 时的操作</p><h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h4><ul><li><p>概念<br><code>__slots__</code> 允许我们显式地声明数据成员并禁止创建 <code>__dict__</code> 和 <code>__weakref__</code> (除非是在 <strong>slots</strong> 中显式地声明或是在父类中可用。)</p></li><li><p>意义及作用</p></li><li><p>相比使用 <strong>dict</strong> 此方式可以显著地节省空间。 </p></li><li><p>属性查找速度也可得到显著的提升。</p></li><li><p><code>__slots__</code>不可被继承，也不可动态添加属性</p></li><li><p>示例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">print(f.x) <span class="comment"># 输出 'a'</span></span><br><span class="line">print(f.y) <span class="comment"># 输出 'b'</span></span><br><span class="line">f.z = <span class="string">'new'</span> <span class="comment"># 抛出 AttributeError 异常</span></span><br></pre></td></tr></table></figure><hr><h3 id="反射（自省）"><a href="#反射（自省）" class="headerlink" title="反射（自省）"></a>反射（自省）</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。</p><h4 id="python中的反射"><a href="#python中的反射" class="headerlink" title="python中的反射"></a>python中的反射</h4><p>通过字符串的形式操作对象相关的属性，python中的一切事物都是对象（都可以使用反射）。</p><h4 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h4><ul><li><p>hasattr(obj, name)<br>返回obj对象是否具有name所描述的属性</p></li><li><p>getattr(obj, name)<br>从obj对象中获取到name所描述的属性</p></li><li><p>setattr(obj, name, value)<br>给obj对象设置一个名为name的属性，属性值为value</p></li><li><p>delattr(obj, name)<br>从obj对象中删除名为name的属性</p></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  反射示例中的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    static_var = <span class="string">'类的静态变量'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'this is bar'</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用hasattr函数检测是否含有某属性</span></span><br><span class="line">print(hasattr(foo, <span class="string">'x'</span>))</span><br><span class="line">print(hasattr(foo, <span class="string">'y'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用getattr获取属性</span></span><br><span class="line">print(getattr(foo, <span class="string">'x'</span>))</span><br><span class="line"></span><br><span class="line">func=getattr(foo, <span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">func() <span class="comment"># 输出'a'</span></span><br><span class="line"></span><br><span class="line">print(getattr(foo, <span class="string">'m'</span>, <span class="string">'不存在'</span>))  <span class="comment"># 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用setattr设置属性</span></span><br><span class="line">setattr(foo, <span class="string">'z'</span>, <span class="string">'c'</span>)</span><br><span class="line">setattr(foo, <span class="string">'new_attr'</span>, <span class="keyword">lambda</span> self:self.x + <span class="string">'_new_attr'</span>)</span><br><span class="line">print(foo.__dict__)</span><br><span class="line">print(foo.bar(foo))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用delattr删除属性</span></span><br><span class="line">delattr(foo, <span class="string">'x'</span>)</span><br><span class="line">delattr(foo, <span class="string">'y'</span>)</span><br><span class="line">delattr(foo, <span class="string">'not_exist_func'</span>) <span class="comment"># 不存在,报错</span></span><br><span class="line"></span><br><span class="line">print(foo.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射类的方法和属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    static_var = <span class="string">"类的静态属性"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'人身苦短'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'我用python'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'bar func...'</span></span><br><span class="line"></span><br><span class="line">print(getattr(Foo, <span class="string">'static_var'</span>))</span><br><span class="line">print(getattr(Foo, <span class="string">'func'</span>))</span><br><span class="line">print(getattr(Foo, <span class="string">'bar'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射模块的属性和方法(内置模块也是可以的)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">程序目录：</span></span><br><span class="line"><span class="string">    module_test.py</span></span><br><span class="line"><span class="string">    index.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当前文件：</span></span><br><span class="line"><span class="string">    index.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> module_test <span class="keyword">as</span> obj</span><br><span class="line"></span><br><span class="line">print(hasattr(obj, <span class="string">'test'</span>))</span><br><span class="line"></span><br><span class="line">print(getattr(obj, <span class="string">'test'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射自身模块中的函数</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'funx_1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funx_2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'funx_2'</span>)</span><br><span class="line"></span><br><span class="line">this_module = sys.modules[__name__]  <span class="comment"># 返回自己的模块</span></span><br><span class="line"></span><br><span class="line">print(hasattr(this_module, <span class="string">'func_1'</span>))</span><br><span class="line">print(getattr(this_module, <span class="string">'funx_2'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;h3 id=&quot;属性方法&quot;&gt;&lt;a href=&quot;#属性方法&quot; class=&quot;headerlink&quot; title=&quot;属性方法&quot;&gt;&lt;/a&gt;属性方法&lt;/h
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python面向对象的三大特征</title>
    <link href="https://elijahyg.github.io/2020/06/27/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
    <id>https://elijahyg.github.io/2020/06/27/Python面向对象的三大特征/</id>
    <published>2020-06-27T10:21:47.000Z</published>
    <updated>2020-06-27T10:23:03.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><p>封装、继承、多态作为面向对象编程的三大特征，其概念也是循序渐进的，首先需要有类的概念，随后将类进行封装，对外只暴露需要暴露的部分，简化对外交互；而后类与类之间会有继承关系；进而有了多态的概念。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>封装是指一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。同时，它也是一种防止外界调用端访问对象内部实现细节的手段。</p><h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>封装的目的是隐藏对象的属性和实现细节，仅对外公开访问方法，并且控制访问级别。所以对于封装的原则，大致可以归纳为高内聚，低耦合。<br>1、高内聚：高内聚是指一个模块中各个部分之间关联应该是紧密的。<br>2、低耦合：低耦合是指多个模块之间的关联应该是松散的。</p><h4 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h4><p>不同程序员对于同样的类也可能会有不同的封装方法，评价类是否较好的完成封装这一特征的标准大致包含以下几方面：</p><ul><li>功能单一性</li><li>可扩展性</li><li>明确的输入输出</li></ul><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类。</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>所谓抽象，与我们平时理解的抽象大致相同。就是将有共同特征的一类事物进行归纳，将其共有的、本质性的特征归纳抽象出来。</p><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>所谓继承，就是基于抽象出来的共同特征定义父类之后，需要定义和父类具有相同的属性和方法的子类，即称子类继承于父类，子类中仍可以重新定义、追加属性和方法等。</p><ul><li>继承与重用的区别<br>所谓代码重用是将已经编写完成的代码复制，在新的编码中重用之前程序已经完成的代码功能，代码重用可以虽然可以节省开发周期，简化编码难度。<br>而继承与重用的核心区别就是继承是基于对类进行抽象之后，对于类进行的抽象归纳之后认为其所具有的相同的方法/属性。对于编码而言，不需要将原有代码复制到新的编码之中，而只需要声明其继承于某个已经完成的类作为父类即可。相比重用，减少了代码量，增加了代码的可读性。</li></ul><h4 id="继承相关名词概念解释"><a href="#继承相关名词概念解释" class="headerlink" title="继承相关名词概念解释"></a>继承相关名词概念解释</h4><ul><li><p>父类 &amp; 子类<br>所谓父类即作为抽象的类可以产生相关子类的类。<br>所谓子类就是通过继承其他类所创建出来的类。</p></li><li><p>基类 &amp; 派生类<br>基类概念同父类，派生类概念同子类。</p></li><li><p>新式类 &amp; 经典类</p><ul><li><p>新式类：<br>1、在Python 3.x中取消了经典类，默认都是新式类，创建新式类时不必显式的继承object。<br>2、新式类多继承的原则是：广度优先。总结而言，即在新式类中对于子类继承多个父类的情况，如果继承的多个父类中有属性相同的，则越<code>靠后</code>继承的父类中的属性会覆盖靠前继承的父类的相同属性。<br>3、新式类中增加了<code>__slots__</code>内置属性, <code>__slots__</code>的作用是可以限定实例属性的种类。<br>4、新式类中增加了<code>__getattribute__</code>方法，对于访问类/实例中任何存在与否的方法/属性时都会调用<code>__getattribute__</code>方法。<br>5、新式类内置增加了<code>__new__</code>方法。</p></li><li><p>经典类：<br>1、在Python2.x中，默认都是经典类，只有显式继承了object创建的才是新式类。<br>2、经典类多继承的原则是：深度优先。总结而言，即在新式类中对于子类继承多个父类的情况，如果继承的多个父类中有属性相同的，则越<code>靠前</code>继承的父类中的属性会覆盖靠后继承的父类的相同属性。</p></li></ul></li><li><p>单继承 &amp; 多继承<br>单继承是指子类只可以继承自一个父类。<br>多继承是指一个子类同时继承自多个父类。</p></li></ul><h4 id="抽象类-amp-接口类"><a href="#抽象类-amp-接口类" class="headerlink" title="抽象类&amp;接口类"></a>抽象类&amp;接口类</h4><ul><li>抽象类<br>抽象类只能被继承，而不能被实例化。其作用在于规定继承它的子类需要实现什么方法，而不是其本身实现了什么功能。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc  <span class="comment"># 利用abc模块实现抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义父类Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">    all_type = <span class="string">'person'</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod  # 定义抽象方法，无需具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'子类需定义睡觉方法'</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod  # 定义抽象方法，无需具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'子类需定义吃饭方法'</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Student</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">student = Student()  <span class="comment"># 此处抛出异常，因为子类没有定义抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Worker睡觉方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Worker吃方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Teacher睡觉方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Teacher吃方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Farmer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Farmer睡觉方法'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Farmer吃方法'</span>)</span><br><span class="line"></span><br><span class="line">worker=Worker()</span><br><span class="line"></span><br><span class="line">teacher=Teacher()</span><br><span class="line"></span><br><span class="line">farmer=Farmer()</span><br><span class="line"></span><br><span class="line"><span class="comment">#  此处体现了归一化思想，即相同方法在不同子类中的具体实现不同，但是调用者的调用方式相同</span></span><br><span class="line">worker.sleep()</span><br><span class="line">worker.eat()</span><br><span class="line"></span><br><span class="line">teacher.sleep()</span><br><span class="line">teacher.eat()</span><br><span class="line"></span><br><span class="line">farmer.sleep()</span><br><span class="line">farmer.eat()</span><br></pre></td></tr></table></figure><ul><li>接口类<br>继承的作用可以大致分类两方面：代码复用和实现接口继承。<br>那么，什么是接口继承呢？接口继承的意义在于需要一种抽象类，该抽象类实现了一种兼容功能，使得调用者无需关心类的内部实现细节，便可以统一处理特定接口。这被称为”归一化”。归一化的意义在于外部功能的调用者不用关注细节，便可以统一的处理所有接口兼容的对象。<br>同时，便要引出编程的”依赖倒置”原则。即：<br>1、高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>2、抽象不应该应该依赖细节，细节应该依赖抽象。<br>总而言之，即程序要针对接口编程，而不是针对实现编程</li></ul><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>多态指的是一类事物具有多种形态，同时，多态是继承的具体展现形式。</p><h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><p>多态性是指在不考虑实例类型的情况下使用实例。</p><h4 id="鸭子类型（Duck-Type）"><a href="#鸭子类型（Duck-Type）" class="headerlink" title="鸭子类型（Duck Type）"></a>鸭子类型（Duck Type）</h4><ul><li>鸭子类型概念<br>If it walks like a duck and quacks like a duck, it must be a duck。(如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。)<br>鸭子类型是计算机领域中的一种设计风格，其意义即对象的特征不取决于其父类，而取决于对象本身的实现。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义父类Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'子类需定义吃饭方法'</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Worker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Worker吃方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Teacher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Teacher吃方法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类Farmer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Farmer吃方法'</span>)</span><br><span class="line"></span><br><span class="line">worker=Worker()</span><br><span class="line">teacher=Teacher()</span><br><span class="line">farmer=Farmer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处worker、teacher、farmer都有吃的方法，但是具体的实现不同，所以eat方法本身不取决于Person父类中的eat方法，而是由每个子类所产生的实例自己决定</span></span><br><span class="line">worker.eat()</span><br><span class="line">teacher.eat()</span><br><span class="line">farmer.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以进一步的统一调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">someone_eat</span><span class="params">(obj)</span>:</span></span><br><span class="line">    obj.eat()</span><br><span class="line"></span><br><span class="line">someone_eat(worker)</span><br><span class="line">someone_eat(teacher)</span><br><span class="line">someone_eat(farmer)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象三大特征&quot;&gt;&lt;a href=&quot;#面向对象三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特征&quot;&gt;&lt;/a&gt;面向对象三大特征&lt;/h2&gt;&lt;p&gt;封装、继承、多态作为面向对象编程的三大特征，其概念也是循序渐进的，首先需要有类的概念，随后将
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python面向对象初识</title>
    <link href="https://elijahyg.github.io/2020/06/07/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E8%AF%86/"/>
    <id>https://elijahyg.github.io/2020/06/07/Python面向对象初识/</id>
    <published>2020-06-07T12:19:28.000Z</published>
    <updated>2020-06-07T12:21:18.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面相对象初识"><a href="#面相对象初识" class="headerlink" title="面相对象初识"></a>面相对象初识</h2><ul><li><p>面向过程编程<br>面向过程编程即流程式编程，根据问题进行分析，抽象出解决问题所需要的步骤，并按步骤逐步进行函数调用解决问题。</p></li><li><p>函数式编程<br>函数式编程是一种编程范式，即给定输入值，经过函数处理后给出返回值，即为函数式编程。比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p></li><li><p>面向对象编程<br>面向对象编程是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。</p></li></ul><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li><p>概念<br>定义了一件事物的抽象特点，类的定义包含了数据的形式以及对数据的操作。</p></li><li><p>意义<br>类的出现，为面向对象编程的三个最重要的特性，即封装性、继承性、多态性，提供了实现的手段。</p></li><li><p>作用<br>属性引用、实例化</p></li></ul><ul><li>声明类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="string">"description of class"</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li><p>概念<br>对象即类的实例</p></li><li><p>意义<br>类相当于是蓝图，定义了一件特定事物的抽象特点，而对象则是类的真实实例，实现了类定义。</p></li><li><p>作用<br>属性引用</p></li><li><p>创建对象</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="string">"description of class"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">foo = Foo()  <span class="comment"># 类的实例化，python中类的实例化会自动调用类的__init__方法</span></span><br></pre></td></tr></table></figure><hr><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><ul><li><p>概念<br>在Python中 , 我们将静态属性 就称为<code>属性</code>, 将动态属性就称为<code>方法</code>, 以变量表示<code>属性</code>, 以函数表示<code>方法</code>。</p></li><li><p>调用<br>类/实例调用属性/方法的方式为：<code>类名/实例名 . 属性名/方法名</code></p></li><li><p>特殊的类属性</p></li></ul><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>_<em>dict_</em></td><td>查看类/实例成员, 返回字典</td></tr><tr><td>_<em>name_</em></td><td>查看类名</td></tr><tr><td>_<em>doc_</em></td><td>查看类的描述信息, 即类的注释</td></tr><tr><td>_<em>base_</em></td><td>查看当前类的第一个父类</td></tr><tr><td>_<em>bases_</em></td><td>查看当前类的所有父类, 返回元组</td></tr><tr><td>_<em>module_</em></td><td>查看当前类所在模块</td></tr><tr><td>_<em>class_</em></td><td>查看当前实例的父类</td></tr></tbody></table><hr><h3 id="构造方法-amp-析构方法"><a href="#构造方法-amp-析构方法" class="headerlink" title="构造方法 &amp; 析构方法"></a>构造方法 &amp; 析构方法</h3><ul><li><p>构造方法<br><code>\__init\__</code>被称作构造方法，其作用是用于对类进行初始化，如果需要对类设置属性，则可以在构造方法中进行初始化设置。</p></li><li><p>析构方法<br><code>\__del\__</code>被称作析构方法，当对象的生命周期结束时，它会自动地被调用运行。它最主要的目的在于，清空并释放对象先前创建或是占用的存储器资源。</p></li></ul><hr><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间它表示着一个标识符的可见范围，在定义类的时候会产生类的命名空间，同样在类实例化对象之后，对象也会对应产生命名空间。当调用类/实例的属性/方法时，Python解释器首先会到该实例的命名空间中去找对应属性/方法,如果没有找到则继续向上去类的命名空间去找,如果都没有找到对应调用的属性/方法，则抛出异常。</p><hr><h3 id="类-实例中的属性-方法绑定关系"><a href="#类-实例中的属性-方法绑定关系" class="headerlink" title="类/实例中的属性/方法绑定关系"></a>类/实例中的属性/方法绑定关系</h3><ul><li>Python作为一种动态语言，其所有的赋值机制都是通过动态绑定实现。</li><li>类中的属性/方法可供其创建的所有实例使用</li><li>实例中的属性/方法只适用于实例本身</li></ul><hr><h3 id="对象交互-amp-类的组合"><a href="#对象交互-amp-类的组合" class="headerlink" title="对象交互&amp;类的组合"></a>对象交互&amp;类的组合</h3><ul><li>对象交互</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interactive</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        print(<span class="string">"【&#123;&#125;】 interactive 【&#123;&#125;】"</span>.format(self.x, other.x))</span><br><span class="line"></span><br><span class="line">obj_a = Foo(<span class="string">'obj_a'</span>)</span><br><span class="line">obj_b = Foo(<span class="string">'obj_b'</span>)</span><br><span class="line">obj_a.interactive(obj_b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">【obj_a】 interactive 【obj_b】</span><br></pre></td></tr></table></figure><ul><li>类的组合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, person)</span>:</span></span><br><span class="line">        self.person = person</span><br><span class="line"></span><br><span class="line">person = Worker(Person(<span class="string">'Yang'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, person)</span>:</span></span><br><span class="line">        self.person = Person(<span class="string">'Yang'</span>)</span><br><span class="line"></span><br><span class="line">worker = Worker()</span><br></pre></td></tr></table></figure><hr><h3 id="metaclass（元类）"><a href="#metaclass（元类）" class="headerlink" title="metaclass（元类）"></a>metaclass（元类）</h3><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#metaclasses" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/reference/datamodel.html#metaclasses</a></p></blockquote><h4 id="概念及作用"><a href="#概念及作用" class="headerlink" title="概念及作用"></a>概念及作用</h4><ul><li>概念<br>一种用于创建类的类。<br>类定义包含类名、类字典和基类列表。<br>元类负责接受上述三个参数并创建相应的类。<br>大部分面向对象的编程语言都会提供一个默认实现。<br>Python 的特别之处在于可以创建自定义元类。<br>大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。</li><li>作用<br>它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</li></ul><h4 id="元类的原理及定义类的执行过程"><a href="#元类的原理及定义类的执行过程" class="headerlink" title="元类的原理及定义类的执行过程"></a>元类的原理及定义类的执行过程</h4><ul><li><p>元类的原理<br>默认情况下，类是使用 type() 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定到 type(name, bases, namespace) 的结果。<br>类创建过程可通过在定义行传入 metaclass 关键字参数，或是通过继承一个包含此参数的现有类来进行定制。</p></li><li><p>类定义的执行过程</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、解析 MRO 条目:</span><br><span class="line">如果在类定义中出现的基类不是 type 的实例，则使用 __mro_entries__ 方法对其进行搜索，当找到结果时，它会以原始基类元组做参数进行调用。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、确定适当的元类:</span><br><span class="line">在类定义时确定元类的流程：</span><br><span class="line">    ①如果没有基类且没有显式指定元类，则使用 type()；</span><br><span class="line">    ②如果给出一个显式元类且不是 type() 的实例，则其会被直接用作元类；</span><br><span class="line">    ③如果给出一个 type() 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、准备类命名空间:</span><br><span class="line">在类定义之时确定元类的命名空间原则：</span><br><span class="line">    ①如果元类具有 __prepare__ 属性，它会以 namespace = metaclass.__prepare__(name, bases, **kwds) 的形式被调用（其中如果有任何额外的关键字参数，则应来自类定义）。 __prepare__ 方法的实现应当为 classmethod()。</span><br><span class="line">    ②如果元类没有 __prepare__ 属性，则类命名空间将初始化为一个空的有序映射。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、执行类主体:</span><br><span class="line">    类主体会以（类似于） exec(body, globals(), namespace) 的形式被执行。普通调用与 exec() 的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当前和外部作用域的名称。</span><br><span class="line">    但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过隐式词法作用域的 __class__ 引用。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、创建类对象:</span><br><span class="line">一旦执行类主体完成填充类命名空间，将通过调用 metaclass(name, bases, namespace, **kwds) 创建类对象（此处的附加关键字参数与传入 __prepare__ 的相同）。</span><br><span class="line"></span><br><span class="line">如果类主体中有任何方法引用了 __class__ 或 super，这个类对象会通过零参数形式的 super(). __class__ 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 super() 能够正确标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第一个参数来标识的。</span><br><span class="line"></span><br><span class="line">当使用默认的元类 type 或者任何最终会调用 type.__new__ 的元类时，以下额外的自定义步骤将在创建类对象之后被发起调用:</span><br><span class="line">    ①首先，type.__new__ 将收集类命名空间中所有定义了 __set_name__() 方法的描述器；</span><br><span class="line">    ②接下来，所有这些 __set_name__ 方法将使用所定义的类和特定描述器所赋的名称进行调用；</span><br><span class="line">    ③最后，将在新类根据方法解析顺序所确定的直接父类上调用 __init_subclass__() 钩子。</span><br><span class="line"></span><br><span class="line">在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已定义的类绑定到局部命名空间。</span><br><span class="line"></span><br><span class="line">当通过 type.__new__ 创建一个新类时，提供以作为命名空间形参的对象会被复制到一个新的有序映射并丢弃原对象。这个新副本包装于一个只读代理中，后者则成为类对象的 __dict__ 属性。</span><br></pre></td></tr></table></figure><hr><h3 id="单例模式的四种方式"><a href="#单例模式的四种方式" class="headerlink" title="单例模式的四种方式"></a>单例模式的四种方式</h3><ul><li><code>__new__</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单例模式"""</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure><ul><li>模块导入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得单例对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的代码保存在文件 mysingleton.py 中，然后这样使用：</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><ul><li>装饰器（decorator）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>元类（metaclass）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Singleton"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args,**kwargs)</span>:</span></span><br><span class="line">        super(SingletonType, self).__init__(*args,**kwargs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = cls.__new__(cls,*args,**kwargs)</span><br><span class="line">        cls.__init__(obj,*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=SingletonType)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Foo"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">obj = Foo(<span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面相对象初识&quot;&gt;&lt;a href=&quot;#面相对象初识&quot; class=&quot;headerlink&quot; title=&quot;面相对象初识&quot;&gt;&lt;/a&gt;面相对象初识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向过程编程&lt;br&gt;面向过程编程即流程式编程，根据问题进行分析，抽象出解决问题所需要的步骤
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python常用的模块&amp;包</title>
    <link href="https://elijahyg.github.io/2020/05/10/Python%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97&amp;%E5%8C%85/"/>
    <id>https://elijahyg.github.io/2020/05/10/Python常用的模块&amp;包/</id>
    <published>2020-05-10T15:07:02.000Z</published>
    <updated>2020-05-10T15:09:13.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用模块-amp-包"><a href="#常用模块-amp-包" class="headerlink" title="常用模块&amp;包"></a>常用模块&amp;包</h2><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><h4 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h4><ul><li><p>概念<br>又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></li><li><p>字符组<br>在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用<code>[]</code>表示。</p></li></ul><table><thead><tr><th>正则表达式</th><th>待匹配字符串</th><th>解释</th></tr></thead><tbody><tr><td>[0123456789]</td><td>6</td><td>字符组里包含待匹配字符</td></tr><tr><td>[abcdefghij]</td><td>a</td><td>字符组里包含待匹配字符</td></tr><tr><td>[0-9]</td><td>a</td><td>字符组里使用-作为范围，包含待匹配字符</td></tr><tr><td>[a-z]</td><td>a</td><td>字符组里使用-作为范围，包含待匹配字符</td></tr><tr><td>[A-Za-z0-9]</td><td>a</td><td>字符组里使用-作为范围，可以包含多个范围，包含待匹配字符</td></tr></tbody></table><ul><li>字符</li></ul><table><thead><tr><th>元字符</th><th>解释</th></tr></thead><tbody><tr><td>.</td><td>可以匹配除换行符(\n)外的任意字符</td></tr><tr><td>\w</td><td>可以匹配数字、字母、下划线(_)</td></tr><tr><td>\s</td><td>可以匹配任何空白字符，包括空格、制表符、换页符等等。等价于字符组用法的：[\f\n\r\t\v]</td></tr><tr><td>\d</td><td>可以匹配数字</td></tr><tr><td>\n</td><td>可以匹配一个换行符</td></tr><tr><td>\t</td><td>可以匹配一个制表符</td></tr><tr><td>\b</td><td>定位符,可以匹配一个单词的边界,这个位置的一侧是构成单词的字符,另一侧为非单词字符、字符串的开始或结束位置,”\b”是零宽度的</td></tr><tr><td>^</td><td>可以匹配字符串的开始</td></tr><tr><td>$</td><td>可以匹配字符串的结尾</td></tr><tr><td>\W</td><td>可以匹配非字母或数字或下划线</td></tr><tr><td>\D</td><td>可以匹配非数字</td></tr><tr><td>\S</td><td>可以匹配非空白符</td></tr><tr><td>\B</td><td>定位符,可以匹配一个非单词的边界</td></tr><tr><td>a|b</td><td>可以匹配字符a或字符b</td></tr><tr><td>()</td><td>可以匹配括号内的表达式，也表示一个组</td></tr><tr><td>[…]</td><td>可以匹配字符组中的字符</td></tr><tr><td>[^…]</td><td>可以匹配除了字符组中字符的所有字符</td></tr></tbody></table><ul><li>量词</li></ul><table><thead><tr><th>量词</th><th>解释</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><ul><li>转义符<code>\</code>与r</li></ul><table><thead><tr><th>字符</th><th>解释</th></tr></thead><tbody><tr><td><code>\</code></td><td>元字符中很多都包括<code>\</code>，如果需要匹配反斜杠<code>\</code>的话，则需要对其转义，在<code>\</code>前增加一个<code>\</code>变为<code>\\</code></td></tr><tr><td>r</td><td>如果需要转义的<code>\</code>过多，或者觉得麻烦，可以在正则表达式中使用r，则正则表达式字符串中的<code>\</code>视为<code>\</code>，不当做元字符的一部分</td></tr></tbody></table><ul><li>贪婪匹配原则<br>在满足匹配条件时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</li></ul><h4 id="re模块介绍"><a href="#re模块介绍" class="headerlink" title="re模块介绍"></a>re模块介绍</h4><p>re模块使Python拥有全部的正则表达式功能,re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数</p><h4 id="re模块常用方法"><a href="#re模块常用方法" class="headerlink" title="re模块常用方法"></a>re模块常用方法</h4><ul><li>findall(): 返回所有满足匹配条件的结果至列表中</li><li>search(): 返回第一个包含匹配条件的信息对象，可以调用该对象的group()方法将匹配的字符输出，如果没有匹配到则调用group()方法会报错</li><li>match(): 与search()方法类似，但是仅在字符串开始出匹配，返回第一个包含匹配条件的信息对象，调用该对象的group()方法将匹配的字符输出，如果没有匹配到则调用group()方法会报错</li><li>split(): 逐个按符合条件的字符串对待匹配字符串进行切分，返回结果列表</li><li>sub(): 将待匹配字符串中满足匹配条件的内容进行替换，最后一个参数指定替换的次数，返回替换后的字符串</li><li>subn(): 与sub()方法类型，但是无法指定替换的次数，并且输出的是一个元组，包括替换后的字符串和替换的总次数</li><li>compile(): 将正则表达式编译成为一个正则表达式对象，之后可以用re模块中的方法对对象进行操作</li><li>finditer(): finditer返回一个存放匹配结果的迭代器，用next等方法取出存放结果的对象，再用group()方法取出结果</li><li>findall的优先级查询: 将findall()方法中匹配条件中加括号后，只会输出匹配到的字符串；可以在括号中加入?:取消权限</li><li>split的优先级查询: 将split()方法中的匹配条件加括号后，会将满足条件的切分字符也输出值最终列表中，同样可以在括号中加入?:取消权限</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">s = <span class="string">'life1is2short,I3use4python5'</span> <span class="comment"># 待匹配字符串</span></span><br><span class="line"></span><br><span class="line">res = re.findall(<span class="string">"\d"</span>, s)</span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">"1"</span>, s)</span><br><span class="line">print(res.group())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.match(<span class="string">"1"</span>, s)</span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.split(<span class="string">"\d"</span>, s)</span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'life'</span>, <span class="string">'is'</span>, <span class="string">'short,I'</span>, <span class="string">'use'</span>, <span class="string">'python'</span>, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.sub(<span class="string">"\d"</span>, <span class="string">"___"</span>, s, <span class="number">2</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"life___is___short,I3use4python5"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.subn(<span class="string">"\d"</span>, <span class="string">"___"</span>, s)</span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"life___is___short,I___use___python___"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prog = re.compile(<span class="string">"\d"</span>)</span><br><span class="line">res = prog.match(s)</span><br><span class="line"><span class="comment"># 等价于 res = re.match("\d", s)</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.finditer(<span class="string">"\d"</span>, s)</span><br><span class="line">print([i.group() <span class="keyword">for</span> i <span class="keyword">in</span> res]) <span class="comment"># 返回为一个迭代器 iterator 保存了 匹配对象 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h3><h4 id="collections模块介绍"><a href="#collections模块介绍" class="headerlink" title="collections模块介绍"></a>collections模块介绍</h4><p>这个模块实现了特定目标的容器，以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。</p><h4 id="collections模块常用方法"><a href="#collections模块常用方法" class="headerlink" title="collections模块常用方法"></a>collections模块常用方法</h4><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>namedtuple()</td><td>创建命名元组子类的工厂函数</td></tr><tr><td>deque</td><td>类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td></tr><tr><td>ChainMap</td><td>类似字典(dict)的容器类，将多个映射集合到一个视图里面</td></tr><tr><td>Counter</td><td>字典的子类，提供了可哈希对象的计数功能</td></tr><tr><td>OrderedDict</td><td>字典的子类，保存了他们被添加的顺序</td></tr><tr><td>defaultdict</td><td>字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td></tr><tr><td>UserDict</td><td>封装了字典对象，简化了字典子类化</td></tr><tr><td>UserList</td><td>封装了列表对象，简化了列表子类化</td></tr><tr><td>UserString</td><td>封装了列表对象，简化了字符串子类化</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># namedtuple</span></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"></span><br><span class="line">这个新的子类用于创建类元组的对象，可以通过域名来获取属性值，同样也可以通过索引和迭代获取值。</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line">p = Point(<span class="number">11</span>, y=<span class="number">22</span>)</span><br><span class="line">res = p[<span class="number">0</span>] + p[<span class="number">1</span>]</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># deque</span></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line">返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从迭代对象数据创建。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = deque(<span class="string">'ghi'</span>) <span class="comment"># 创建一个新的deque</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> elem <span class="keyword">in</span> d: <span class="comment"># 循环输出deque中的元素</span></span><br><span class="line"><span class="meta">... </span>print(elem.upper())</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">I</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.append(<span class="string">'j'</span>) <span class="comment"># 从右边插入新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.appendleft(<span class="string">'f'</span>) <span class="comment"># 从左边插入新元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># 输出deque所有元素</span></span><br><span class="line">deque([<span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop() <span class="comment"># 从右边推出最后一个元素</span></span><br><span class="line"><span class="string">'j'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popleft() <span class="comment"># 从左边推出最后一个元素</span></span><br><span class="line"><span class="string">'f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(d) <span class="comment"># 输出deque所有元素</span></span><br><span class="line">[<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">0</span>] <span class="comment"># 输出最左边元素</span></span><br><span class="line"><span class="string">'g'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">-1</span>] <span class="comment"># 输出最右边元素</span></span><br><span class="line"><span class="string">'i'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed(d)) <span class="comment"># 逆向输出deque所有元素</span></span><br><span class="line">[<span class="string">'i'</span>, <span class="string">'h'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'h'</span> <span class="keyword">in</span> d <span class="comment"># 在deque中查找元素</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extend(<span class="string">'jkl'</span>) <span class="comment"># 一次性添加多个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">deque([<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.rotate(<span class="number">1</span>) <span class="comment"># 所有元素向右移动</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">deque([<span class="string">'l'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.rotate(<span class="number">-1</span>) <span class="comment"># 所有元素向左移动</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">deque([<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deque(reversed(d)) <span class="comment"># 创建一个新的deque</span></span><br><span class="line">deque([<span class="string">'l'</span>, <span class="string">'k'</span>, <span class="string">'j'</span>, <span class="string">'i'</span>, <span class="string">'h'</span>, <span class="string">'g'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear() <span class="comment"># 清空deque</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop() <span class="comment"># 空deque不能推出元素</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;pyshell#6&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> -toplevel-</span><br><span class="line">        d.pop()</span><br><span class="line">IndexError: pop <span class="keyword">from</span> an empty deque</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.extendleft(<span class="string">'abc'</span>) <span class="comment"># 一次性添加多个元素，从左边开始插入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">deque([<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># ChainMap</span></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line">将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">baseline = &#123;<span class="string">'music'</span>: <span class="string">'bach'</span>, <span class="string">'art'</span>: <span class="string">'rembrandt'</span>&#125;</span><br><span class="line">adjustments = &#123;<span class="string">'art'</span>: <span class="string">'van gogh'</span>, <span class="string">'opera'</span>: <span class="string">'carmen'</span>&#125;</span><br><span class="line">print(list(ChainMap(adjustments, baseline)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'music'</span>, <span class="string">'opera'</span>, <span class="string">'art'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">baseline = &#123;<span class="string">'music'</span>: <span class="string">'bach'</span>, <span class="string">'art'</span>: <span class="string">'rembrandt'</span>&#125;</span><br><span class="line">adjustments = &#123;<span class="string">'art'</span>: <span class="string">'van gogh'</span>, <span class="string">'opera'</span>: <span class="string">'carmen'</span>&#125;</span><br><span class="line">combined = baseline.copy()</span><br><span class="line">combined.update(adjustments)</span><br><span class="line">print(list(combined))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'music'</span>, <span class="string">'art'</span>, <span class="string">'opera'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># Counter:</span></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line">是dict的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。</span><br><span class="line"></span><br><span class="line">c = Counter() <span class="comment"># 创建新的空Counter对象</span></span><br><span class="line">c = Counter(<span class="string">'gallahad'</span>) <span class="comment"># 创建字符串的Counter对象</span></span><br><span class="line">c = Counter(&#123;<span class="string">'red'</span>: <span class="number">4</span>, <span class="string">'blue'</span>: <span class="number">2</span>&#125;) <span class="comment"># 创建映射关系的Counter对象</span></span><br><span class="line">c = Counter(cats=<span class="number">4</span>, dogs=<span class="number">8</span>) <span class="comment"># 创建关键字的Counter对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># OrderedDict</span></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"></span><br><span class="line">它具有专门用于重新排列字典顺序的方法。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = OrderedDict.fromkeys(<span class="string">'abcde'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.move_to_end(<span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(d.keys())</span><br><span class="line"><span class="string">'acdeb'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.move_to_end(<span class="string">'b'</span>, last=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(d.keys())</span><br><span class="line"><span class="string">'bacde'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># defaultdict</span></span><br><span class="line"><span class="comment"># ------------------- </span></span><br><span class="line">一个新的类似字典的对象。它重载了一个方法并添加了一个可写的实例变量。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>d[k].append(v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># UserDict</span></span><br><span class="line"><span class="comment"># ------------------- </span></span><br><span class="line">模拟一个字典类。这个实例的内容保存为一个正常字典， 可以通过 UserDict 实例的 data 属性存取。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># UserList</span></span><br><span class="line"><span class="comment"># ------------------- </span></span><br><span class="line">这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------</span></span><br><span class="line"><span class="comment"># UserString</span></span><br><span class="line"><span class="comment"># ------------------- </span></span><br><span class="line">用作字符串对象的外包装。对这个类的需求已部分由直接创建 str 的子类的功能所替代</span><br></pre></td></tr></table></figure><hr><h3 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h3><h4 id="表示时间的三种方式"><a href="#表示时间的三种方式" class="headerlink" title="表示时间的三种方式"></a>表示时间的三种方式</h4><ul><li>时间戳：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1515570662.77503</span></span><br></pre></td></tr></table></figure><ul><li>结构化时间：结构化时间元组共有9个元素(年，月，日，时，分，秒，一年中第几周，一年中第几天等）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">1</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">16</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">33</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">10</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>时间字符串：以字符串表示年、月、日、时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.strftime(<span class="string">"%Y-%m-%d %H-%M-%S"</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2018</span><span class="number">-01</span><span class="number">-10</span> <span class="number">15</span><span class="number">-59</span><span class="number">-16</span></span><br></pre></td></tr></table></figure><h4 id="几种格式之间的转换"><a href="#几种格式之间的转换" class="headerlink" title="几种格式之间的转换"></a>几种格式之间的转换</h4><ul><li>时间戳–&gt;结构化时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.gmtime(时间戳) #UTC时间，与英国伦敦当地时间一致</span></span><br><span class="line"><span class="comment"># time.localtime(时间戳) #当地时间。例如当地时间为北京时间，与UTC时间相差8小时，UTC时间+8小时 = 北京时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timestamp = <span class="number">1515570662.77503</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 → 当地时间</span></span><br><span class="line">print(time.localtime(timestamp))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">1</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">15</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">2</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">10</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 → UTC时间</span></span><br><span class="line">print(time.gmtime(timestamp))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.struct_time(tm_year=<span class="number">2018</span>, tm_mon=<span class="number">1</span>, tm_mday=<span class="number">10</span>, tm_hour=<span class="number">7</span>, tm_min=<span class="number">51</span>, tm_sec=<span class="number">2</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">10</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>结构化时间–&gt;时间戳</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.mktime(结构化时间)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time_tuple  = time.localtime(<span class="number">1500000000</span>)</span><br><span class="line">print(time.mktime(time_tuple))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1500000000.0</span></span><br></pre></td></tr></table></figure><ul><li>字符串时间–&gt;结构化时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.strptime(时间字符串,字符串对应格式)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.strftime(<span class="string">"%Y-%m-%d %X"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2018</span><span class="number">-01</span><span class="number">-10</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">46</span></span><br><span class="line">print(time.strftime(<span class="string">"%Y-%m-%d"</span>,time.localtime(<span class="number">1515570662.77503</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2018</span><span class="number">-01</span><span class="number">-10</span></span><br></pre></td></tr></table></figure><ul><li>结构化时间–&gt;字符串时间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.strftime(“格式定义”,”结构化时间”) 结构化时间参数若不传，则现实当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.strptime(<span class="string">"2017-03-16"</span>,<span class="string">"%Y-%m-%d"</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">3</span>, tm_mday=<span class="number">16</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">75</span>, tm_isdst=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(time.strptime(<span class="string">"07/24/2017"</span>,<span class="string">"%m/%d/%Y"</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">24</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">205</span>, tm_isdst=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><h4 id="random模块介绍"><a href="#random模块介绍" class="headerlink" title="random模块介绍"></a>random模块介绍</h4><p>该模块实现了各种分布的伪随机数生成器。</p><h4 id="random模块常用方法"><a href="#random模块常用方法" class="headerlink" title="random模块常用方法"></a>random模块常用方法</h4><ul><li>随机小数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.random()) <span class="comment"># 随机输出在0-1之间的小数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.11828833626857149</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.uniform(<span class="number">1</span>,<span class="number">5</span>)) <span class="comment"># 随机输出在范围之间的小数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2.164732131520036</span></span><br></pre></td></tr></table></figure><ul><li>随机整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.randint(<span class="number">5</span>,<span class="number">10</span>)) <span class="comment"># randint中的范围包括首尾</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.randrange(<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>)) <span class="comment"># randrange中的范围顾首不顾尾，可以指定步长</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span></span><br></pre></td></tr></table></figure><ul><li>随机返回列表元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.choice([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>],(<span class="number">6</span>,<span class="number">7</span>)]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><ul><li>随机返回多个列表元素，可以指定返回的个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.sample([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>],(<span class="number">6</span>,<span class="number">7</span>)],<span class="number">2</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="number">6</span>, <span class="number">7</span>), <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li>打乱顺序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">item=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">random.shuffle(item)</span><br><span class="line">print(item)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><h4 id="os模块介绍"><a href="#os模块介绍" class="headerlink" title="os模块介绍"></a>os模块介绍</h4><p>本模块提供了一种使用与操作系统相关的功能的便捷式途径。</p><h4 id="os模块常用方法"><a href="#os模块常用方法" class="headerlink" title="os模块常用方法"></a>os模块常用方法</h4><ul><li>进程参数: 这些函数和数据项提供了操作当前进程和用户的信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">os.ctermid(): 返回与进程控制终端对应的文件名。</span><br><span class="line">os.environ: 一个表示字符串环境的 mapping 对象。</span><br><span class="line">os.environb:字节版本的 environ: 一个以字节串表示环境的 mapping 对象。</span><br><span class="line">os.fsencode(filename)：编码 路径类 文件名 为文件系统接受的形式，使用 <span class="string">'surrogateescape'</span> 代理转义编码错误处理器，在Windows系统上会使用 <span class="string">'strict'</span> ；返回 bytes 字节类型不变。</span><br><span class="line">os.fsdecode(filename)：从文件系统编码方式解码为 路径类 文件名，使用 <span class="string">'surrogateescape'</span> 代理转义编码错误处理器，在Windows系统上会使用 <span class="string">'strict'</span> ；返回 str 字符串不变。</span><br><span class="line">os.fspath(path):返回路径的文件系统表示。</span><br><span class="line">os.getenv(key, default=<span class="literal">None</span>):如果存在，返回环境变量 key 的值，否则返回 default。 key ， default 和返回值均为 str 字符串类型。</span><br><span class="line">os.getenvb(key, default=<span class="literal">None</span>):如果存在环境变量 key 那么返回其值，否则返回 default。 key ， default 和返回值均为bytes字节串类型。</span><br><span class="line">os.get_exec_path(env=<span class="literal">None</span>):返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。</span><br><span class="line">os.getegid():返回当前进程的有效组ID。</span><br><span class="line">os.geteuid():返回当前进程的有效用户ID。</span><br><span class="line">os.getgid():返回当前进程的实际组ID。</span><br><span class="line">os.getgrouplist(user, group):返回该用户所在的组 ID 列表。</span><br><span class="line">os.getgroups(): 返回当前进程对应的组ID列表</span><br><span class="line">os.getlogin():返回通过控制终端进程进行登录的用户名。</span><br><span class="line">os.getpgid(pid):根据进程id pid 返回进程的组 ID 列表。</span><br><span class="line">os.getpgrp():返回当时进程组的ID</span><br><span class="line">os.getpid():返回当前进程ID</span><br><span class="line">os.getppid():返回父进程ID。</span><br><span class="line">os.getpriority(which, who):获取程序调度优先级。</span><br><span class="line">os.getresuid():返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和甲暂存用户ID。</span><br><span class="line">os.getresgid():返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。</span><br><span class="line">os.getuid():返回当前进程的真实用户ID。</span><br><span class="line">os.initgroups(username, gid):调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID</span><br><span class="line">os.putenv(key, value):将名为 key 的环境变量值设置为 value。</span><br><span class="line">os.setegid(egid):设置当前进程的有效组ID。</span><br><span class="line">os.seteuid(euid):设置当前进程的有效用户ID。</span><br><span class="line">os.setgid(gid):设置当前进程的组ID。</span><br><span class="line">os.setgroups(groups):将 group 参数值设置为与当进程相关联的附加组ID列表</span><br><span class="line">os.setpgrp():根据已实现的版本（如果有）来调用系统 setpgrp() 或 setpgrp(<span class="number">0</span>, <span class="number">0</span>) 。</span><br><span class="line">os.setpgid(pid, pgrp):使用系统调用 setpgid()，将 pid 对应进程的组ID设置为 pgrp。</span><br><span class="line">os.setpriority(which, who, priority):设置程序调度优先级。</span><br><span class="line">os.setregid(rgid, egid):设置当前进程的真实和有效组ID。</span><br><span class="line">os.setresgid(rgid, egid, sgid):设置当前进程的真实，有效和暂存组ID。</span><br><span class="line">os.setresuid(ruid, euid, suid):设置当前进程的真实，有效和暂存用户ID。</span><br><span class="line">os.setreuid(ruid, euid):设置当前进程的真实和有效用户ID。</span><br><span class="line">os.getsid(pid):调用系统调用 getsid()。</span><br><span class="line">os.setsid():使用系统调用 getsid()。</span><br><span class="line">os.setuid(uid):设置当前进程的用户ID。</span><br><span class="line">os.strerror(code):根据 code 中的错误码返回错误消息。</span><br><span class="line">os.supports_bytes_environ:如果操作系统上原生环境类型是字节型则为 <span class="literal">True</span> (例如在 Windows 上为 <span class="literal">False</span>)。</span><br><span class="line">os.umask(mask):设定当前数值掩码并返回之前的掩码。</span><br><span class="line">os.uname():返回当前操作系统的识别信息。</span><br><span class="line">os.unsetenv(key):取消设置（删除）名为 key 的环境变量。</span><br></pre></td></tr></table></figure><ul><li>创建文件对象: 这些函数创建新的 file objects。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.fdopen(fd, *args, **kwargs)：返回打开文件描述符 fd 对应文件的对象。</span><br></pre></td></tr></table></figure><ul><li>文件描述符操作: 这些函数对文件描述符所引用的 I/O 流进行操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> os.close(fd):关闭文件描述符 fd</span><br><span class="line"> os.closerange(fd_low, fd_high):关闭从 fd_low （包括）到 fd_high （排除）间的文件描述符，并忽略错误。</span><br><span class="line"> os.copy_file_range(src, dst, count, offset_src=<span class="literal">None</span>, offset_dst=<span class="literal">None</span>):从文件描述符 src 复制 count 字节，从偏移量 offset_src 开始读取，到文件描述符 dst，从偏移量 offset_dst 开始写入。</span><br><span class="line"> os.device_encoding(fd):如果连接到终端，则返回一个与 fd 关联的设备描述字符，否则返回 <span class="literal">None</span>。</span><br><span class="line"> os.dup(fd):返回一个文件描述符 fd 的副本。</span><br><span class="line"> os.dup2(fd, fd2, inheritable=<span class="literal">True</span>):把文件描述符 fd 复制为 fd2，必要时先关闭后者。</span><br><span class="line"> os.fchmod(fd, mode):将 fd 指定文件的权限状态修改为 mode。</span><br><span class="line"> os.fchown(fd, uid, gid):分别将 fd 指定文件的所有者和组 ID 修改为 uid 和 gid 的值。</span><br><span class="line"> os.fdatasync(fd):强制将文件描述符 fd 指定文件写入磁盘。</span><br><span class="line"> os.fpathconf(fd, name):返回与打开的文件有关的系统配置信息。</span><br><span class="line"> os.fstat(fd):获取文件描述符 fd 的状态. 返回一个 stat_result 对象。</span><br><span class="line"> os.fstatvfs(fd):返回文件系统的信息，该文件系统是文件描述符 fd 指向的文件所在的文件系统，与 statvfs() 一样。从 Python <span class="number">3.3</span> 开始，它等效于 os.statvfs(fd)。</span><br><span class="line"> os.fsync(fd):强制将文件描述符 fd 指向的文件写入磁盘。</span><br><span class="line"> os.ftruncate(fd, length):将文件描述符 fd 指向的文件切分开，以使其最大为 length 字节。从 Python <span class="number">3.3</span> 开始，它等效于 os.truncate(fd, length)。</span><br><span class="line"> os.get_blocking(fd):获取文件描述符的阻塞模式：如果设置了 O_NONBLOCK 标志位，返回 <span class="literal">False</span>，如果该标志位被清除，返回 <span class="literal">True</span>。</span><br><span class="line"> os.isatty(fd):如果文件描述符 fd 打开且已连接至 tty 设备（或类 tty 设备），返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。</span><br><span class="line"> os.lockf(fd, cmd, len):在打开的文件描述符上，使用、测试或删除 POSIX 锁。</span><br><span class="line"> os.lseek(fd, pos, how):将文件描述符 fd 的当前位置设置为 pos，</span><br><span class="line"> os.open(path, flags, mode=<span class="number">0o777</span>, *, dir_fd=<span class="literal">None</span>):打开文件 path，根据 flags 设置各种标志位，并根据 mode 设置其权限模式。</span><br><span class="line"> os.openpty():打开一对新的伪终端，返回一对文件描述符``（主，从）``，分别为 pty 和 tty。</span><br><span class="line"> os.pipe():创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)。</span><br><span class="line"> os.pipe2(flags):创建带有 flags 标志位的管道。</span><br><span class="line"> os.posix_fallocate(fd, offset, len):确保为 fd 指向的文件分配了足够的磁盘空间，该空间从偏移量 offset 开始，到 len 字节为止。</span><br><span class="line"> os.posix_fadvise(fd, offset, len, advice):声明即将以特定模式访问数据，使内核可以提前进行优化。</span><br><span class="line"> os.pread(fd, n, offset):从文件描述符 fd 所指向文件的偏移位置 offset 开始，读取至多 n 个字节，而保持文件偏移量不变。</span><br><span class="line"> os.preadv(fd, buffers, offset, flags=<span class="number">0</span>):从文件描述符 fd 所指向文件的偏移位置 offset 开始，将数据读取至可变 字节类对象 缓冲区 buffers 中，保持文件偏移量不变。</span><br><span class="line"> os.RWF_NOWAIT:不要等待无法立即获得的数据。</span><br><span class="line"> os.RWF_HIPRI:高优先级读/写。</span><br><span class="line"> os.pwrite(fd, str, offset):将 str 中的字节串 (bytestring) 写入文件描述符 fd 的偏移位置 offset 处，保持文件偏移量不变。</span><br><span class="line"> os.pwritev(fd, buffers, offset, flags=<span class="number">0</span>):将缓冲区 buffers 的内容写入文件描述符 fd 的偏移位置 offset 处，保持文件偏移量不变。</span><br><span class="line"> os.RWF_DSYNC:提供立即写入功能，等效于 O_DSYNC open(<span class="number">2</span>) 标志</span><br><span class="line"> os.RWF_SYNC:提供立即写入功能，等效于 O_SYNC open(<span class="number">2</span>) 标志。</span><br><span class="line"> os.read(fd, n):从文件描述符 fd 中读取至多 n 个字节。</span><br><span class="line"> os.sendfile(out, <span class="keyword">in</span>, offset, count, [headers, ][trailers, ]flags=<span class="number">0</span>):将文件描述符 <span class="keyword">in</span> 中的 count 字节复制到文件描述符 out 的偏移位置 offset 处。返回复制的字节数，如果到达 EOF，返回 <span class="number">0</span>。</span><br><span class="line"> os.set_blocking(fd, blocking):设置指定文件描述符的阻塞模式：如果 blocking 为 <span class="literal">False</span>，则为该描述符设置 O_NONBLOCK 标志位，反之则清除该标志位。</span><br><span class="line"> os.readv(fd, buffers):从文件描述符 fd 将数据读取至多个可变的 字节类对象 缓冲区 buffers 中。</span><br><span class="line"> os.tcgetpgrp(fd):返回与 fd 指定的终端相关联的进程组（fd 是由 os.open() 返回的已打开的文件描述符）</span><br><span class="line"> os.tcsetpgrp(fd, pg):设置与 fd 指定的终端相关联的进程组为 pg*（*fd 是由 os.open() 返回的已打开的文件描述符）。</span><br><span class="line"> os.ttyname(fd):返回一个字符串，该字符串表示与文件描述符 fd 关联的终端。</span><br><span class="line"> os.write(fd, str):将 str 中的字节串 (bytestring) 写入文件描述符 fd。</span><br><span class="line"> os.writev(fd, buffers):将缓冲区 buffers 的内容写入文件描述符 fd。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询终端的尺寸</span></span><br><span class="line"> os.get_terminal_size(fd=STDOUT_FILENO):返回终端窗口的尺寸，格式为 (columns, lines)，它是类型为 terminal_size 的元组。</span><br><span class="line"> os.terminal_size:元组的子类，存储终端窗口尺寸 (columns, lines)。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件描述符的继承</span></span><br><span class="line"> os.get_inheritable(fd):获取指定文件描述符的“可继承”标志位（为布尔值）。</span><br><span class="line"> os.set_inheritable(fd, inheritable):设置指定文件描述符的“可继承”标志位。</span><br><span class="line"> os.get_handle_inheritable(handle):获取指定句柄的“可继承”标志位（为布尔值）。</span><br><span class="line"> os.set_handle_inheritable(handle, inheritable):设置指定句柄的“可继承”标志位。</span><br></pre></td></tr></table></figure><ul><li>文件和目录</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">os.access(path, mode, *, dir_fd=<span class="literal">None</span>, effective_ids=<span class="literal">False</span>, follow_symlinks=<span class="literal">True</span>):使用 实际用户ID/用户组ID 测试对 path 的访问。</span><br><span class="line">os.chdir(path):将当前工作目录更改为 path。</span><br><span class="line">os.chflags(path, flags, *, follow_symlinks=<span class="literal">True</span>):将 path 的 flags 设置为其他由数字表示的 flags。</span><br><span class="line">os.chmod(path, mode, *, dir_fd=<span class="literal">None</span>, follow_symlinks=<span class="literal">True</span>):将 path 的 mode 更改为其他由数字表示的 mode。 </span><br><span class="line">os.chown(path, uid, gid, *, dir_fd=<span class="literal">None</span>, follow_symlinks=<span class="literal">True</span>):将 path 的用户和组 ID 分别修改为数字形式的 uid 和 gid。 </span><br><span class="line">os.chroot(path):将当前进程的根目录更改为 path。 </span><br><span class="line">os.fchdir(fd):将当前工作目录更改为文件描述符 fd 指向的目录。fd 必须指向打开的目录而非文件。从 Python <span class="number">3.3</span> 开始，它等效于 os.chdir(fd)。</span><br><span class="line">os.getcwd():返回表示当前工作目录的字符串。</span><br><span class="line">os.getcwdb():返回表示当前工作目录的字节串 (bytestring)。</span><br><span class="line">os.lchflags(path, flags):将 path 的 flags 设置为其他由数字表示的 flags，与 chflags() 类似，但不跟踪符号链接。</span><br><span class="line">os.lchmod(path, mode):将 path 的权限状态修改为 mode。</span><br><span class="line">os.lchown(path, uid, gid):将 path 的用户和组 ID 分别修改为数字形式的 uid 和 gid，本函数不跟踪符号链接。从 Python <span class="number">3.3</span> 开始，它等效于 os.chown(path, uid, gid, follow_symlinks=<span class="literal">False</span>)。</span><br><span class="line">os.link(src, dst, *, src_dir_fd=<span class="literal">None</span>, dst_dir_fd=<span class="literal">None</span>, follow_symlinks=<span class="literal">True</span>):创建一个指向 src 的硬链接，名为 dst。</span><br><span class="line">os.listdir(path=<span class="string">'.'</span>):返回一个列表，该列表包含了 path 中所有文件与目录的名称。</span><br><span class="line">os.lstat(path, *, dir_fd=<span class="literal">None</span>)：在给定路径上执行本函数，其操作相当于 lstat() 系统调用，类似于 stat() 但不跟踪符号链接。返回值是 stat_result 对象。</span><br><span class="line">os.mkdir(path, mode=<span class="number">0o777</span>, *, dir_fd=<span class="literal">None</span>):创建目录path，并使用数字定义模式。</span><br><span class="line">os.makedirs(name, mode=<span class="number">0o777</span>, exist_ok=<span class="literal">False</span>):Recursive directory creation function. Like mkdir(), but makes all intermediate-level directories needed to contain the leaf directory.</span><br><span class="line">os.rmdir(path, *, dir_fd=<span class="literal">None</span>):Remove (delete) the directory path.</span><br><span class="line">os.stat(path, *, dir_fd=<span class="literal">None</span>, follow_symlinks=<span class="literal">True</span>): Get the status of a file <span class="keyword">or</span> a file descriptor.</span><br><span class="line">os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>):Generate the file names <span class="keyword">in</span> a directory tree by walking the tree either top-down <span class="keyword">or</span> bottom-up. For each directory <span class="keyword">in</span> the tree rooted at directory top (including top itself), it yields a <span class="number">3</span>-tuple (dirpath, dirnames, filenames).</span><br></pre></td></tr></table></figure><ul><li>进程管理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">os.abort():Generate a SIGABRT signal to the current process.</span><br><span class="line">os.add_dll_directory(path):Add a path to the DLL search path.</span><br><span class="line"></span><br><span class="line">These functions all execute a new program, replacing the current process; they do <span class="keyword">not</span> <span class="keyword">return</span>.</span><br><span class="line">   os.execl(path, arg0, arg1, ...)</span><br><span class="line">   os.execle(path, arg0, arg1, ..., env)</span><br><span class="line">   os.execlp(file, arg0, arg1, ...)</span><br><span class="line">   os.execlpe(file, arg0, arg1, ..., env)</span><br><span class="line">   os.execv(path, args)</span><br><span class="line">   os.execve(path, args, env)</span><br><span class="line">   os.execvp(file, args)</span><br><span class="line">   os.execvpe(file, args, env)</span><br><span class="line"></span><br><span class="line">Execute the program path <span class="keyword">in</span> a new process.</span><br><span class="line">   os.spawnl(mode, path, ...)</span><br><span class="line">   os.spawnle(mode, path, ..., env)</span><br><span class="line">   os.spawnlp(mode, file, ...)</span><br><span class="line">   os.spawnlpe(mode, file, ..., env)</span><br><span class="line">   os.spawnv(mode, path, args)</span><br><span class="line">   os.spawnve(mode, path, args, env)</span><br><span class="line">   os.spawnvp(mode, file, args)</span><br><span class="line">   os.spawnvpe(mode, file, args, env)</span><br></pre></td></tr></table></figure><ul><li>调度器接口</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.sched_get_priority_min(policy):获取 policy 的最小优先级数值。 policy 是以上调度策略常量之一。</span><br><span class="line">os.sched_get_priority_max(policy):获取 policy 的最高优先级数值。 policy 是以上调度策略常量之一。</span><br></pre></td></tr></table></figure><ul><li>杂项系统信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.confstr(name):Return string-valued system configuration values.</span><br><span class="line">os.cpu_count():Return the number of CPUs <span class="keyword">in</span> the system.该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 len(os.sched_getaffinity(<span class="number">0</span>)) 方法获得。</span><br><span class="line">os.curdir:The constant string used by the operating system to refer to the current directory.</span><br><span class="line">os.pardir:The constant string used by the operating system to refer to the parent directory.</span><br><span class="line">os.sep:The character used by the operating system to separate pathname components.</span><br></pre></td></tr></table></figure><ul><li>随机数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.getrandom(size, flags=<span class="number">0</span>):Get up to size random bytes.</span><br><span class="line">os.urandom(size):Return a string of size random bytes suitable <span class="keyword">for</span> cryptographic use.</span><br></pre></td></tr></table></figure><hr><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><h4 id="sys模块介绍"><a href="#sys模块介绍" class="headerlink" title="sys模块介绍"></a>sys模块介绍</h4><p>该模块提供了一些变量和函数。这些变量可能被解释器使用，也可能由解释器提供。</p><h4 id="sys模块常用方法"><a href="#sys模块常用方法" class="headerlink" title="sys模块常用方法"></a>sys模块常用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.argv: 命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n): 退出程序，正常退出时exit(<span class="number">0</span>),错误退出sys.exit(<span class="number">1</span>)</span><br><span class="line">sys.version: 获取Python解释程序的版本信息</span><br><span class="line">sys.path: 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform: 返回操作系统平台名称</span><br></pre></td></tr></table></figure><hr><h3 id="序列化相关模块"><a href="#序列化相关模块" class="headerlink" title="序列化相关模块"></a>序列化相关模块</h3><h4 id="序列化概念"><a href="#序列化概念" class="headerlink" title="序列化概念"></a>序列化概念</h4><p>wiki中对于序列化的解释：在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。<br>简而言之，将原本的字典、列表等内容转换成一个字符串的过程叫做序列化，其反过程叫反序列化。</p><h4 id="序列化目的"><a href="#序列化目的" class="headerlink" title="序列化目的"></a>序列化目的</h4><ul><li>以某种存储形式使自定义对象持久化</li><li>将对象从一个地方传递到另一个地方</li><li>使程序更具维护性</li></ul><h4 id="序列化相关模块介绍"><a href="#序列化相关模块介绍" class="headerlink" title="序列化相关模块介绍"></a>序列化相关模块介绍</h4><ul><li>json: 由 RFC 7159 (which obsoletes RFC 4627) 和 ECMA-404 指定，是一个受 JavaScript 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。</li><li>pickle: 模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。</li><li>shelve: “Shelf” 是一种持久化的类似字典的对象。 与 “dbm” 数据库的区别在于 Shelf 中的值（不是键！）实际上可以为任意 Python 对象, 即 pickle 模块能够处理的任何东西。</li><li>marshal: 此模块包含一此能以二进制格式来读写 Python 值的函数。这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 pickle 和 shelve 等模块。</li></ul><h4 id="序列化相关模块常用方法"><a href="#序列化相关模块常用方法" class="headerlink" title="序列化相关模块常用方法"></a>序列化相关模块常用方法</h4><ul><li>json: 用于字符串(包括其他支持json的语言)和python数据类型间进行转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 序列化dumps</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化列表list</span></span><br><span class="line">print(json.dumps([<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: (<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>)&#125;]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'["foo", &#123;"bar": ["baz", null, 1.0, 2]&#125;]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化字符串string</span></span><br><span class="line">print(json.dumps(<span class="string">"\"foo\bar"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\"foo\bar"</span></span><br><span class="line"></span><br><span class="line">print(json.dumps(<span class="string">'\u1234'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\u1234"</span></span><br><span class="line"></span><br><span class="line">print(json.dumps(<span class="string">'\\'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\\"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化字典dict</span></span><br><span class="line">print(json.dumps(&#123;<span class="string">"c"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"a"</span>: <span class="number">0</span>&#125;, sort_keys=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;"a": 0, "b": 0, "c": 0&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 反序列化loads</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">print(json.loads(<span class="string">'["foo", &#123;"bar":["baz", null, 1.0, 2]&#125;]'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: [<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>]&#125;]</span><br><span class="line"></span><br><span class="line">json.loads(<span class="string">'"\\"foo\\bar"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"foo\x08ar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 序列化dump(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'json_file'</span>,mode=<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic_fd=json.dump(dic,f)</span><br><span class="line"><span class="comment"># 文件中的内容：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">"k3"</span>: <span class="string">"v3"</span>, <span class="string">"k2"</span>: <span class="string">"v2"</span>, <span class="string">"k1"</span>: <span class="string">"v1"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 反序列化load(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'json_file'</span>,mode=<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic_fs=json.load(f)</span><br><span class="line">print(dic_fs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k3'</span>: <span class="string">'v3'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>shelve: 只提供一个open方法，用key来访问，使用起来与字典类似</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 序列化(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="keyword">with</span> shelve.open(<span class="string">'shelve_file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f[<span class="string">'key'</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 反序列化(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="keyword">with</span> shelve.open(<span class="string">'shelve_file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f[<span class="string">'key'</span>]</span><br><span class="line">print(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 额外支持的两个方法</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line">Shelf.sync(): 如果 Shelf 打开时将 writeback 设为 <span class="literal">True</span> 则写回缓存中的所有条目。 如果可行还会清空缓存并将持久化字典同步到磁盘。 此方法会在使用 close() 关闭 Shelf 时自动被调用。</span><br><span class="line">Shelf.close():同步并关闭持久化 dict 对象。 对已关闭 Shelf 的操作将失败并引发 ValueError。</span><br></pre></td></tr></table></figure><ul><li>pickle: 用于python特有的类型和python的数据类型间进行转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 序列化dumps</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化列表list</span></span><br><span class="line">print(pickle.dumps([<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: (<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>)&#125;]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x80\x03]q\x00(X\x03\x00\x00\x00fooq\x01&#125;q\x02X\x03\x00\x00\x00barq\x03(X\x03\x00\x00\x00bazq\x04NG?\xf0\x00\x00\x00\x00\x00\x00K\x02tq\x05se.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化字符串string</span></span><br><span class="line">print(pickle.dumps(<span class="string">"\"foo\bar"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x80\x03X\x07\x00\x00\x00"foo\x08arq\x00.'</span></span><br><span class="line"></span><br><span class="line">print(pickle.dumps(<span class="string">'\u1234'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x80\x03X\x03\x00\x00\x00\xe1\x88\xb4q\x00.'</span></span><br><span class="line"></span><br><span class="line">print(pickle.dumps(<span class="string">'\\'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x80\x03X\x01\x00\x00\x00\\q\x00.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化字典dict</span></span><br><span class="line">print(pickle.dumps(&#123;<span class="string">"c"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"a"</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x80\x03&#125;q\x00(X\x01\x00\x00\x00cq\x01K\x00X\x01\x00\x00\x00bq\x02K\x00X\x01\x00\x00\x00aq\x03K\x00u.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 反序列化loads</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">print(pickle.loads(<span class="string">b'\x80\x03]q\x00(X\x03\x00\x00\x00fooq\x01&#125;q\x02X\x03\x00\x00\x00barq\x03(X\x03\x00\x00\x00bazq\x04NG?\xf0\x00\x00\x00\x00\x00\x00K\x02tq\x05se.'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: [<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>]&#125;]</span><br><span class="line"></span><br><span class="line">print(pickle.loads(<span class="string">b'\x80\x03X\x07\x00\x00\x00"foo\x08arq\x00.'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"foo\x08ar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 序列化dump(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'pickle_file'</span>,mode=<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic_fd=pickle.dump(dic,f)</span><br><span class="line"><span class="comment"># 文件中的内容：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8003</span> <span class="number">7</span>d71 <span class="number">0028</span> <span class="number">5802</span> <span class="number">0000</span> <span class="number">006</span>b <span class="number">3171</span> <span class="number">0158</span></span><br><span class="line"><span class="number">0200</span> <span class="number">0000</span> <span class="number">7631</span> <span class="number">7102</span> <span class="number">5802</span> <span class="number">0000</span> <span class="number">006</span>b <span class="number">3271</span></span><br><span class="line"><span class="number">0358</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">7632</span> <span class="number">7104</span> <span class="number">5802</span> <span class="number">0000</span> <span class="number">006</span>b</span><br><span class="line"><span class="number">3371</span> <span class="number">0558</span> <span class="number">0200</span> <span class="number">0000</span> <span class="number">7633</span> <span class="number">7106</span> <span class="number">752</span>e </span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># 反序列化load(文件)</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'pickle_file'</span>,mode=<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    dic_fs=pickle.load(f)</span><br><span class="line">print(dic_fs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>, <span class="string">'k3'</span>: <span class="string">'v3'</span>, <span class="string">'k2'</span>: <span class="string">'v2'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>marshal：Python 有一个更原始的序列化模块称为 marshal，但一般地 pickle 应该是序列化 Python 对象时的首选。marshal 存在主要是为了支持 Python 的 <code>.pyc</code> 文件.</li></ul><h4 id="Pickle-vs-Json-vs-Marshal"><a href="#Pickle-vs-Json-vs-Marshal" class="headerlink" title="Pickle vs Json vs Marshal"></a><code>Pickle</code> vs <code>Json</code> vs <code>Marshal</code></h4><ul><li><p><code>pickle</code> vs <code>json</code></p><ul><li>pickle 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。marshal 不会这么做。</li><li>这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。pickle 只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。</li><li>marshal 不能被用于序列化用户定义类及其实例。pickle 能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。</li><li>同样用于序列化的 marshal 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 .pyc 文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。pickle 序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python 3 之间跨越传递，封存和解封的代码在 2 和 3 之间也是不同的。</li></ul></li><li><p><code>pickle</code> vs <code>marshal</code></p><ul><li>JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 utf-8 编码），而 pickle 是一个二进制序列化格式；</li><li>JSON 是我们可以直观阅读的，而 pickle 不是；</li><li>JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；</li><li>默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。</li><li>不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。</li></ul></li></ul><hr><h3 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h3><h4 id="hashlib模块介绍"><a href="#hashlib模块介绍" class="headerlink" title="hashlib模块介绍"></a>hashlib模块介绍</h4><p>该模块为许多不同的安全哈希和消息摘要算法实现了一个通用接口。包括FIPS安全哈希算法SHA1，SHA224，SHA256，SHA384和SHA512以及RSA的MD5算法。术语“安全哈希”和“消息摘要”是等价的，旧称消息摘要，现在称安全哈希。</p><h4 id="hashlib的作用"><a href="#hashlib的作用" class="headerlink" title="hashlib的作用"></a>hashlib的作用</h4><p>它通过一个函数，把任意长度的数据转换为一个长度固定的数据串，用以验证原始数据是否被篡改，保证数据的一致性。</p><h4 id="hashlib模块应用场景"><a href="#hashlib模块应用场景" class="headerlink" title="hashlib模块应用场景"></a>hashlib模块应用场景</h4><ul><li>摘要算法</li><li>密码的密文存储</li><li>文件的一致性验证</li></ul><h4 id="hashlib模块示例"><a href="#hashlib模块示例" class="headerlink" title="hashlib模块示例"></a>hashlib模块示例</h4><ul><li>MD5</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用md5进行哈希</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">b'life is short'</span>)</span><br><span class="line">print(md5.hexdigest())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">617</span>d2b938b9b59b347b92f19f84436bd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sha256进行哈希</span></span><br><span class="line">m = hashlib.sha256()</span><br><span class="line">m.update(<span class="string">b"Nobody inspects"</span>)</span><br><span class="line">m.update(<span class="string">b" the spammish repetition"</span>)</span><br><span class="line">m.digest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\x03\x1e\xdd&#125;Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sha224进行哈希</span></span><br><span class="line">hashlib.sha224(<span class="string">b"Nobody inspects the spammish repetition"</span>).hexdigest()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'</span></span><br></pre></td></tr></table></figure><hr><h3 id="configparser模块"><a href="#configparser模块" class="headerlink" title="configparser模块"></a>configparser模块</h3><h4 id="configparser模块介绍"><a href="#configparser模块介绍" class="headerlink" title="configparser模块介绍"></a>configparser模块介绍</h4><p>该模块提供了ConfigParser类，该类实现了一种基本配置语言，该语言提供的结构类似于Microsoft Windows INI文件中的结构。您可以使用它来编写可由最终用户轻松定制的Python程序。</p><h4 id="configparser模块示例"><a href="#configparser模块示例" class="headerlink" title="configparser模块示例"></a>configparser模块示例</h4><ul><li>常见配置文档格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = <span class="number">45</span></span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = <span class="number">9</span></span><br><span class="line">ForwardX11 = yes</span><br><span class="line"></span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line"></span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = <span class="number">50022</span></span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure><ul><li>configparser创建Python配置文档</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用configparser实现上述配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config[<span class="string">'DEFAULT'</span>] = &#123;</span><br><span class="line">                        <span class="string">'ServerAliveInterval'</span>: <span class="string">'45'</span>,</span><br><span class="line">                        <span class="string">'Compression'</span>: <span class="string">'yes'</span>,</span><br><span class="line">                        <span class="string">'CompressionLevel'</span>: <span class="string">'9'</span></span><br><span class="line">                    &#125;</span><br><span class="line">config[<span class="string">'bitbucket.org'</span>] = &#123;&#125;</span><br><span class="line">config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>] = <span class="string">'hg'</span></span><br><span class="line">config[<span class="string">'topsecret.server.com'</span>] = &#123;&#125;</span><br><span class="line">topsecret = config[<span class="string">'topsecret.server.com'</span>]</span><br><span class="line">topsecret[<span class="string">'Port'</span>] = <span class="string">'50022'</span></span><br><span class="line">topsecret[<span class="string">'ForwardX11'</span>] = <span class="string">'no'</span></span><br><span class="line">config[<span class="string">'DEFAULT'</span>][<span class="string">'ForwardX11'</span>] = <span class="string">'yes'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.ini'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> configfile:</span><br><span class="line">    config.write(configfile)</span><br></pre></td></tr></table></figure><ul><li>增删改查CURD操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用set方法增加配置</span></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.add_section(<span class="string">'new_added'</span>)</span><br><span class="line">config.set(<span class="string">'new_added'</span>,<span class="string">'config_key_1'</span>,<span class="string">'Value'</span>)</span><br><span class="line">config.write(open(<span class="string">'sample_add.ini'</span>, <span class="string">"w"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用remove_section/remove_option方法删除</span></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'sample.ini'</span>)</span><br><span class="line">config.remove_section(<span class="string">'new_added'</span>)</span><br><span class="line">config.remove_option(<span class="string">'new_added_2'</span>,<span class="string">"config_key_2"</span>)</span><br><span class="line">config.write(open(<span class="string">'sample_del.ini'</span>, <span class="string">"w"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用read读取，set方法进行覆盖修改操作</span></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'sample.ini'</span>)</span><br><span class="line">config.set(<span class="string">'config_section_2'</span>,<span class="string">'user'</span>,<span class="string">'python'</span>)</span><br><span class="line">config.write(open(<span class="string">'sample_modi.ini'</span>, <span class="string">"w"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于字典的方式进行查询操作</span></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">print(config.sections())</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">'example.ini'</span>)</span><br><span class="line"></span><br><span class="line">print(config.sections())</span><br><span class="line">print(<span class="string">'bitbucket.org'</span> <span class="keyword">in</span> config) <span class="comment"># True</span></span><br><span class="line">print(config[<span class="string">'bitbucket.org'</span>][<span class="string">"user"</span>])</span><br></pre></td></tr></table></figure><hr><h3 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h3><h4 id="logging模块介绍"><a href="#logging模块介绍" class="headerlink" title="logging模块介绍"></a>logging模块介绍</h4><p>logging模块为应用与库定义了实现灵活的事件日志系统的函数与类。</p><h4 id="logging模块详解"><a href="#logging模块详解" class="headerlink" title="logging模块详解"></a>logging模块详解</h4><ul><li>日志级别</li></ul><table><thead><tr><th>级别</th><th>数值</th></tr></thead><tbody><tr><td>CRITICAL</td><td>50</td></tr><tr><td>ERROR</td><td>40</td></tr><tr><td>WARNING</td><td>30</td></tr><tr><td>INFO</td><td>20</td></tr><tr><td>DEBUG</td><td>10</td></tr><tr><td>NOTSET</td><td>0</td></tr></tbody></table><ul><li>Log相关对象</li></ul><table><thead><tr><th>对象类型</th><th>说明</th></tr></thead><tbody><tr><td>Logger</td><td>日志，暴露函数给应用程序，基于日志记录器和过滤器级别决定哪些日志有效。</td></tr><tr><td>LogRecord</td><td>日志记录器，将日志传到相应的处理器处理。</td></tr><tr><td>Handler</td><td>处理器, 将(日志记录器产生的)日志记录发送至合适的目的地。</td></tr><tr><td>Filter</td><td>过滤器, 提供了更好的粒度控制,它可以决定输出哪些日志记录。</td></tr><tr><td>Formatter</td><td>格式化器, 指明了最终输出中日志记录的布局。</td></tr></tbody></table><ul><li>basicConfig()方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">"logging.log"</span>, filemode=<span class="string">"w"</span>, format=<span class="string">"%(asctime)s %(name)s:%(levelname)s:%(message)s"</span>, datefmt=<span class="string">"%d-%M-%Y %H:%M:%S"</span>, level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">'This is a debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'This is an info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'This is a warning message'</span>)</span><br><span class="line">logging.error(<span class="string">'This is an error message'</span>)</span><br><span class="line">logging.critical(<span class="string">'This is a critical message'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出至logging.log文件中</span></span><br><span class="line"><span class="number">19</span><span class="number">-10</span><span class="number">-18</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">57</span> root:DEBUG:This <span class="keyword">is</span> a debug message</span><br><span class="line"><span class="number">19</span><span class="number">-10</span><span class="number">-18</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">57</span> root:INFO:This <span class="keyword">is</span> an info message</span><br><span class="line"><span class="number">19</span><span class="number">-10</span><span class="number">-18</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">57</span> root:WARNING:This <span class="keyword">is</span> a warning message</span><br><span class="line"><span class="number">19</span><span class="number">-10</span><span class="number">-18</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">57</span> root:ERROR:This <span class="keyword">is</span> an error message</span><br><span class="line"><span class="number">19</span><span class="number">-10</span><span class="number">-18</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">57</span> root:CRITICAL:This <span class="keyword">is</span> a critical message</span><br></pre></td></tr></table></figure><ul><li>logging对象方式：解决了basicconfig方式的中文支持问题和终端、文本同时输出的问题，推荐使用</li></ul><blockquote><p>注意永远不要直接实例化Loggers，应当通过模块级别的函数 logging.getLogger(name)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别定义终端、文件中的日志输出级别，可以设置 Logger 对象为最低级别，之后设置两个不同级别的Handler 对象来实现。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">"logger"</span>)</span><br><span class="line"></span><br><span class="line">handler_console = logging.StreamHandler()</span><br><span class="line">handler_file = logging.FileHandler(filename=<span class="string">"logging.log"</span>)</span><br><span class="line"></span><br><span class="line">logger.setLevel(logging.DEBUG)  <span class="comment"># 级别为30</span></span><br><span class="line">handler_console.setLevel(logging.WARNING)  <span class="comment"># 级别为10</span></span><br><span class="line">handler_file.setLevel(logging.DEBUG)  <span class="comment"># 级别为30</span></span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(<span class="string">"%(asctime)s %(name)s %(levelname)s %(message)s"</span>)</span><br><span class="line">handler_console.setFormatter(formatter)</span><br><span class="line">handler_file.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">logger.addHandler(handler_console)</span><br><span class="line">logger.addHandler(handler_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(handler1.level)  # 10</span></span><br><span class="line"><span class="comment"># print(handler2.level)  # 30</span></span><br><span class="line"><span class="comment"># print(logger.level)  # 30</span></span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">'This is a customer debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'This is an customer info message'</span>)</span><br><span class="line">logger.warning(<span class="string">'This is a customer warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'This is an customer error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'This is a customer critical message'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台输出结果</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">54</span>,<span class="number">392</span> logger WARNING This <span class="keyword">is</span> a customize warning message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">54</span>,<span class="number">392</span> logger ERROR This <span class="keyword">is</span> an customize error message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">54</span>,<span class="number">392</span> logger CRITICAL This <span class="keyword">is</span> a customize critical message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件输出结果</span></span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">13</span>,<span class="number">417</span> logger DEBUG This <span class="keyword">is</span> a customize debug message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">13</span>,<span class="number">417</span> logger INFO This <span class="keyword">is</span> an customize info message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">13</span>,<span class="number">417</span> logger WARNING This <span class="keyword">is</span> a customize warning message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">13</span>,<span class="number">417</span> logger ERROR This <span class="keyword">is</span> an customize error message</span><br><span class="line"><span class="number">2019</span><span class="number">-10</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">13</span>,<span class="number">417</span> logger CRITICAL This <span class="keyword">is</span> a customize critical message</span><br></pre></td></tr></table></figure><hr><h3 id="pymysql模块"><a href="#pymysql模块" class="headerlink" title="pymysql模块"></a>pymysql模块</h3><h4 id="pymysql模块介绍"><a href="#pymysql模块介绍" class="headerlink" title="pymysql模块介绍"></a>pymysql模块介绍</h4><p>该软件包包含一个基于PEP 249的纯Python MySQL客户端库。</p><h4 id="pymysql模块使用示例"><a href="#pymysql模块使用示例" class="headerlink" title="pymysql模块使用示例"></a>pymysql模块使用示例</h4><ul><li>版本要求 &amp; 安装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本要求</span></span><br><span class="line">Python – one of the following:</span><br><span class="line">    CPython &gt;= <span class="number">2.7</span> <span class="keyword">or</span> &gt;= <span class="number">3.5</span></span><br><span class="line">    Latest PyPy</span><br><span class="line">MySQL Server – one of the following:</span><br><span class="line">    MySQL &gt;= <span class="number">5.5</span></span><br><span class="line">    MariaDB &gt;= <span class="number">5.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">python3 -m pip install PyMySQL</span><br></pre></td></tr></table></figure><ul><li>基本使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库插入数据</span></span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">    `id` int(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `email` varchar(<span class="number">255</span>) COLLATE utf8_bin NOT NULL,</span><br><span class="line">    `password` varchar(<span class="number">255</span>) COLLATE utf8_bin NOT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin</span><br><span class="line">AUTO_INCREMENT=<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用PyMySQL连接数据库</span></span><br><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to the database</span></span><br><span class="line">connection = pymysql.connect(host=<span class="string">'localhost'</span>,</span><br><span class="line">                             user=<span class="string">'user'</span>,</span><br><span class="line">                             password=<span class="string">'passwd'</span>,</span><br><span class="line">                             db=<span class="string">'db'</span>,</span><br><span class="line">                             charset=<span class="string">'utf8mb4'</span>,</span><br><span class="line">                             cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        <span class="comment"># Create a new record</span></span><br><span class="line">        sql = <span class="string">"INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)"</span></span><br><span class="line">        cursor.execute(sql, (<span class="string">'webmaster@python.org'</span>, <span class="string">'very-secret'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># connection is not autocommit by default. So you must commit to save</span></span><br><span class="line">    <span class="comment"># your changes.</span></span><br><span class="line">    connection.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        <span class="comment"># Read a single record</span></span><br><span class="line">        sql = <span class="string">"SELECT `id`, `password` FROM `users` WHERE `email`=%s"</span></span><br><span class="line">        cursor.execute(sql, (<span class="string">'webmaster@python.org'</span>,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    connection.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&#123;<span class="string">'password'</span>: <span class="string">'very-secret'</span>, <span class="string">'id'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="redis模块"><a href="#redis模块" class="headerlink" title="redis模块"></a>redis模块</h3><h4 id="redis模块介绍"><a href="#redis模块介绍" class="headerlink" title="redis模块介绍"></a>redis模块介绍</h4><p>Redis键值存储的Python接口。</p><h4 id="redis模块使用示例"><a href="#redis模块使用示例" class="headerlink" title="redis模块使用示例"></a>redis模块使用示例</h4><ul><li>版本要求 &amp; 安装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本要求</span></span><br><span class="line">redis-py <span class="number">3.0</span> supports Python <span class="number">2.7</span> <span class="keyword">and</span> Python <span class="number">3.5</span>+.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure><ul><li>基本使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line">r.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">r.get(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bar'</span></span><br></pre></td></tr></table></figure><hr><h3 id="PyMongo模块"><a href="#PyMongo模块" class="headerlink" title="PyMongo模块"></a>PyMongo模块</h3><h4 id="PyMongo模块介绍"><a href="#PyMongo模块介绍" class="headerlink" title="PyMongo模块介绍"></a>PyMongo模块介绍</h4><p>PyMongo是一个Python发行版，其中包含用于MongoDB的工具，并且是从Python使用MongoDB的推荐方式。</p><h4 id="PyMongo模块使用示例"><a href="#PyMongo模块使用示例" class="headerlink" title="PyMongo模块使用示例"></a>PyMongo模块使用示例</h4><ul><li>版本要求 &amp; 安装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本要求</span></span><br><span class="line">PyMongo supports MongoDB <span class="number">2.6</span>, <span class="number">3.0</span>, <span class="number">3.2</span>, <span class="number">3.4</span>, <span class="number">3.6</span>, <span class="number">4.0</span> <span class="keyword">and</span> <span class="number">4.2</span>.</span><br><span class="line">PyMongo supports CPython <span class="number">2.7</span>, <span class="number">3.4</span>+, PyPy, <span class="keyword">and</span> PyPy3<span class="number">.5</span>+.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">python -m pip install pymongo[snappy,gssapi,srv,tls,zstd]</span><br></pre></td></tr></table></figure><ul><li>基本使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>)</span><br><span class="line">db = client.test</span><br><span class="line">db.name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'test'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Collection(Database(MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>), <span class="string">u'test'</span>), <span class="string">u'my_collection'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection.insert_one(&#123;<span class="string">"x"</span>: <span class="number">10</span>&#125;).inserted_id</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectId(<span class="string">'4aba15ebe23f6b53b0000000'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection.insert_one(&#123;<span class="string">"x"</span>: <span class="number">8</span>&#125;).inserted_id</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectId(<span class="string">'4aba160ee23f6b543e000000'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection.insert_one(&#123;<span class="string">"x"</span>: <span class="number">11</span>&#125;).inserted_id</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectId(<span class="string">'4aba160ee23f6b543e000002'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection.find_one()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">u'x'</span>: <span class="number">10</span>, <span class="string">u'_id'</span>: ObjectId(<span class="string">'4aba15ebe23f6b53b0000000'</span>)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> db.my_collection.find():</span><br><span class="line">    print(item[<span class="string">"x"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.my_collection.create_index(<span class="string">"x"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'x_1'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> db.my_collection.find().sort(<span class="string">"x"</span>, pymongo.ASCENDING):</span><br><span class="line">    print(item[<span class="string">"x"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[item[<span class="string">"x"</span>] <span class="keyword">for</span> item <span class="keyword">in</span> db.my_collection.find().limit(<span class="number">2</span>).skip(<span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">8</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用模块-amp-包&quot;&gt;&lt;a href=&quot;#常用模块-amp-包&quot; class=&quot;headerlink&quot; title=&quot;常用模块&amp;amp;包&quot;&gt;&lt;/a&gt;常用模块&amp;amp;包&lt;/h2&gt;&lt;h3 id=&quot;re模块&quot;&gt;&lt;a href=&quot;#re模块&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python包</title>
    <link href="https://elijahyg.github.io/2020/04/14/Python%E5%8C%85/"/>
    <id>https://elijahyg.github.io/2020/04/14/Python包/</id>
    <published>2020-04-14T14:06:48.000Z</published>
    <updated>2020-04-14T14:07:24.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>包是一种通过使用<code>.模块名</code>来组织python模块名称空间的方式。</p><h3 id="导入包的本质"><a href="#导入包的本质" class="headerlink" title="导入包的本质"></a>导入包的本质</h3><p>import 包，产生的名称空间的名字同样来源于文件，即包下的<code>__init__.py</code>文件，导入包本质就是在导入该文件</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在导入语句中包含有<code>.</code>，说明是包导入。</li><li>包是目录级的，包是一种包含<code>__init__.py</code>文件的目录。</li><li>import导入文件时，产生名称空间中的名字来源于文件；import导入包，产生的名称空间的名字同样来源于文件，即包下的<code>__init__.py</code>文件，导入包本质就是在导入该文件。</li><li>在python3中，即使包下没有<code>__init__.py</code>文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import导入包报错。</li><li>创建包的目的不是为了运行，而是被导入使用，包只是模块的一种形式而已，包即模块。</li><li>凡是在导入时带<code>.</code>的，<code>.</code>的左边都必须是一个包，否则非法。可以带有一连串的<code>.</code>,但都必须遵循这个原则。</li><li>对于导入包之后，<code>.</code>的左边可以是包,模块，函数，类等,它们都可以用<code>.</code>的方式调用自己的属性。</li><li>对比<code>import item</code> 和<code>from item import name</code>，如果想直接使用<code>name</code>则必须使用后者的导入方式。</li></ul><h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><h4 id="import用法"><a href="#import用法" class="headerlink" title="import用法"></a>import用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试python文件与包同目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> package.nextpackage.models</span><br><span class="line">package.nextpackage.models.models_function(<span class="string">'func_1'</span>)</span><br></pre></td></tr></table></figure><h4 id="from-…-import-…用法"><a href="#from-…-import-…用法" class="headerlink" title="from … import …用法"></a>from … import …用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：from ... import ... 中import后面必须是类、方法等，且不能包含点(.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试python文件与包同目录</span></span><br><span class="line"><span class="comment"># 1、导入某个模块</span></span><br><span class="line"><span class="keyword">from</span> package.nextpackage <span class="keyword">import</span> models</span><br><span class="line">models.models_function(<span class="string">'func_1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、导入模块中的某个方法</span></span><br><span class="line"><span class="keyword">from</span> package.nextpackage.models <span class="keyword">import</span> models_function</span><br><span class="line">models_function(<span class="string">'func_1'</span>)</span><br></pre></td></tr></table></figure><h4 id="init-py文件"><a href="#init-py文件" class="headerlink" title="__init__.py文件"></a><code>__init__.py</code>文件</h4><p>不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的<code>__init__.py</code>文件，这个文件可以为空，也可以进行一些初始化的工作。</p><h4 id="from-import-用法"><a href="#from-import-用法" class="headerlink" title="from ... import *用法"></a><code>from ... import *</code>用法</h4><ul><li><code>from ... import *</code>意在导入包中所有类、方法等，实际上该语句只会导入包下<code>__init__.py</code>文件中定义的名字，我们可以在这个文件中定义<code>__all__</code>变量</li></ul><h4 id="绝对导入和相对导入"><a href="#绝对导入和相对导入" class="headerlink" title="绝对导入和相对导入"></a>绝对导入和相对导入</h4><ul><li>绝对导入：以项目根路径作为起始</li><li>相对导入：用<code>.</code>或者<code>..</code>的方式最为起始（只能在一个包中使用，不能用于不同目录内）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件路径</span></span><br><span class="line">package/nextpackage/models.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对导入</span></span><br><span class="line"><span class="keyword">from</span> package.nextpackage <span class="keyword">import</span> models</span><br><span class="line">models.models_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对导入</span></span><br><span class="line"><span class="keyword">from</span> ..nextpackage <span class="keyword">import</span> models</span><br><span class="line">models.models_function()</span><br></pre></td></tr></table></figure><h4 id="单独导入包"><a href="#单独导入包" class="headerlink" title="单独导入包"></a>单独导入包</h4><ul><li>单独导入包名称时不会导入包中所有包含的所有子模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试python文件与包同目录，在py程序中直接引入方法</span></span><br><span class="line"><span class="keyword">import</span> package</span><br><span class="line">package.nextpackage.models.models_function()</span><br><span class="line"><span class="comment"># 输出报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>AttributeError: module <span class="string">'package'</span> has no attribute <span class="string">'nextpackage'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="comment">#package/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> nextpackage</span><br><span class="line"></span><br><span class="line"><span class="comment">#package/nextpackage/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="comment"># 测试python文件与包同目录</span></span><br><span class="line"><span class="keyword">import</span> package</span><br><span class="line">package.nextpackage.models.models_function()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;包&quot;&gt;&lt;a href=&quot;#包&quot; class=&quot;headerlink&quot; title=&quot;包&quot;&gt;&lt;/a&gt;包&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;包是一种通过使
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python模块</title>
    <link href="https://elijahyg.github.io/2020/04/07/Python%E6%A8%A1%E5%9D%97/"/>
    <id>https://elijahyg.github.io/2020/04/07/Python模块/</id>
    <published>2020-04-07T14:41:44.000Z</published>
    <updated>2020-04-07T14:43:12.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><ul><li>已经被编译为共享库或DLL的C/C++扩展</li><li>使用C编写并链接到python解释器的内置模块</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li>模块的意义在于方便功能的复用，在系统以及</li></ul><h3 id="模块导入规范"><a href="#模块导入规范" class="headerlink" title="模块导入规范"></a>模块导入规范</h3><ul><li>导入的内置模块应该写在前面：内置模块 -&gt; 扩展模块 -&gt; 自定义模块</li><li>模块不会被重复导入</li><li>模块导入的根路径: sys.path</li><li>import用法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、import 模块名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、import 模块名.变量名：与代码文件中的变量名完全不冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、import 模块名 as 重命名的模块名：提高代码的兼容性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、import 模块1，模块2</span></span><br></pre></td></tr></table></figure><ul><li><code>from ... import ...</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、from 模块名 import 变量名</span></span><br><span class="line">  - 直接使用 变量名 就可以完成操作</span><br><span class="line">  - 如果代码文件中有相同的变量名会发生冲突</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、from 模块名 import 变量名字 as 重命名变量名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、from 模块名 import 变量名1，变量名2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、from 模块名 import *</span></span><br><span class="line"> - 将模块中的所有变量名都放到内存中</span><br><span class="line"> - 如果代码文件中有相同的变量名会发生冲突</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、from 模块名 import * 和 __all__变量搭配使用</span></span><br><span class="line"> - 如果没有__all__变量，就会导入该模块的所有变量名</span><br><span class="line"> - 如果有__all__变量则只导入__all__变量列表中的名字</span><br></pre></td></tr></table></figure><ul><li><code>__name__</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、在模块中 有一个变量__name__，</span></span><br><span class="line"><span class="comment"># 2、当我们直接执行这个模块的时候，__name__ == '__main__'</span></span><br><span class="line"><span class="comment"># 3、当我们执行其他模块，在其他模块中引用这个模块的时候，这个模块中的__name__ == '模块的名字'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;h3 id=&quot;什么是模块&quot;&gt;&lt;a href=&quot;#什么是模块&quot; class=&quot;headerlink&quot; title=&quot;什么是模块&quot;&gt;&lt;/a&gt;什么是模
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python迭代器&amp;生成器</title>
    <link href="https://elijahyg.github.io/2020/03/28/Python%E8%BF%AD%E4%BB%A3%E5%99%A8&amp;%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://elijahyg.github.io/2020/03/28/Python迭代器&amp;生成器/</id>
    <published>2020-03-28T07:59:44.000Z</published>
    <updated>2020-03-28T08:07:11.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>内部实现了<code>__iter__()</code>方法</p><h4 id="验证方法"><a href="#验证方法" class="headerlink" title="验证方法"></a>验证方法</h4><ul><li>使用dir()方法查看数据类型中的方法是否包含<code>__iter__()</code></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>可迭代对象执行<code>__iter__()</code>方法后会生成一个迭代器对象</li></ul><h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><ul><li>拥有<code>__iter__()</code>方法的对象 </li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'abc'</span> <span class="comment"># 可迭代对象</span></span><br><span class="line">it = iter(s) <span class="comment"># 调用迭代方法，等同于 s.__iter__()</span></span><br><span class="line"></span><br><span class="line">print(it)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;str_iterator object at <span class="number">0x7f0234b10eb8</span>&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>迭代器是一个有状态的对象，它能在调用next()方法的时候返回容器中的下一个值，任何实现了<code>__iter__()</code>和<code>__next__()</code>方法的对象都是迭代器，<code>__iter__</code>返回迭代器自身，<code>__next__</code>返回容器中的下一个值，如果容器中没有下一个值则抛出<code>StopIteration</code>异常。</p><h4 id="迭代器-vs-可迭代对象区别"><a href="#迭代器-vs-可迭代对象区别" class="headerlink" title="迭代器 vs 可迭代对象区别"></a>迭代器 vs 可迭代对象区别</h4><ul><li><p>迭代器拥有<code>__length_hint__</code>: 获取迭代器中元素的长度 </p></li><li><p>迭代器拥有<code>__setstate__</code>: 根据索引值指定从哪里开始迭代</p></li><li><p>迭代器拥有<code>__next__</code>: 获取迭代器对象的下一个值</p></li></ul><h4 id="标识-1"><a href="#标识-1" class="headerlink" title="标识"></a>标识</h4><ul><li>拥有<code>__iter__()</code>和<code>__next__()</code>方法的对象 </li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'abc'</span></span><br><span class="line">it = iter(s)</span><br><span class="line">print(it) <span class="comment"># 输出迭代器对象</span></span><br><span class="line"></span><br><span class="line">print(next(it)) <span class="comment"># 输出'a'</span></span><br><span class="line">print(next(it)) <span class="comment"># 输出'b'</span></span><br><span class="line">print(next(it)) <span class="comment"># 输出'c'</span></span><br><span class="line">print(next(it)) <span class="comment"># 没有下一个值，抛出StopIteration异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;str_iterator object at <span class="number">0x7fbe85382f60</span>&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"main.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(next(it))</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><hr><h3 id="生成器（本质是迭代器）"><a href="#生成器（本质是迭代器）" class="headerlink" title="生成器（本质是迭代器）"></a>生成器（本质是迭代器）</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>生成器是一种特殊的迭代器，它用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用<code>yield</code>语句。 每次对生成器调用<code>next()</code>时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>惰性运算，开发者自定义</li><li>本质是迭代器</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>生成器函数<br>一个包含<code>yield</code>关键字的函数就是一个生成器函数。<code>yield</code>可以为我们从函数中返回值，但是<code>yield</code>又不同于<code>return</code>，<code>return</code>的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。</p></li><li><p>生成器函数进阶：<code>send()</code></p><ul><li>send和next的作用相同</li><li>第一次不能用send</li><li>函数中的最后一个yield不能接受新的值</li></ul></li><li><p>生成器表达式<br>类似于列表推导，但是生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。</p></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ul><li>简单应用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genrator_fun1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'现在定义了a变量'</span>)</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    print(<span class="string">'现在又定义了b变量'</span>)</span><br><span class="line">    <span class="keyword">yield</span> b</span><br><span class="line"></span><br><span class="line">g1 = genrator_fun1()</span><br><span class="line">print(<span class="string">'g1 : '</span>,g1) <span class="comment">#打印g1可以发现g1就是一个生成器</span></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">20</span>) <span class="comment">#我是华丽的分割线</span></span><br><span class="line">print(next(g1))</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment">#sleep一秒看清执行过程</span></span><br><span class="line">print(next(g1))</span><br></pre></td></tr></table></figure><ul><li>避免一次性读取数据到内存中导致内存溢出</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename)</span><br><span class="line">    f.seek(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">#从文件末尾算起</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = f.readline() <span class="comment"># 读取文件中新的文本行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line">tail_g = tail(<span class="string">'tmp'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> tail_g:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure><ul><li>yield from</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">print(list(gen1()))</span><br><span class="line"></span><br><span class="line">以上是将生成器中的数据以列表的方式打印</span><br><span class="line">以下的执行效果与上面相同，运用了<span class="keyword">yield</span> <span class="keyword">from</span> 语法</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(list(gen2()))</span><br></pre></td></tr></table></figure><ul><li>生成器函数进阶：<code>send()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算移动平均值的例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">()</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    avg = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num = <span class="keyword">yield</span> avg</span><br><span class="line">        sum += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        avg = sum / count</span><br><span class="line"></span><br><span class="line">avg_g = average()</span><br><span class="line">avg_g.__next__()</span><br><span class="line"></span><br><span class="line">print(avg_g.send(<span class="number">20</span>))</span><br><span class="line">print(avg_g.send(<span class="number">40</span>))</span><br><span class="line">print(avg_g.send(<span class="number">60</span>))</span><br></pre></td></tr></table></figure><ul><li>预激生成器的装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预激生成器的装饰器——在装饰器中首先调用了__next__方法，方便用户直接进行调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        g = func(*args,**kwargs)</span><br><span class="line">        g.__next__()</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average</span><span class="params">()</span>:</span></span><br><span class="line">    sum,avg,count = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num = <span class="keyword">yield</span> avg</span><br><span class="line">        sum += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        avg = sum/count</span><br><span class="line"></span><br><span class="line">avg_g = average()</span><br><span class="line">print(avg_g.send(<span class="number">10</span>))</span><br><span class="line">print(avg_g.send(<span class="number">20</span>))</span><br><span class="line">print(avg_g.send(<span class="number">30</span>))</span><br></pre></td></tr></table></figure><ul><li>推导式汇总</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -------------列表推导-------------</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型] #遍历之后挨个处理</span></span><br><span class="line"><span class="string">[满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件] #筛选功能</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># -------------简单的列表推导-------------</span></span><br><span class="line">l = [i ** <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(l)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------带筛选的列表推导-------------</span></span><br><span class="line">l = [i ** <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">print(l)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">27</span>, <span class="number">216</span>, <span class="number">729</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------多层列表推导-------------</span></span><br><span class="line">double_l = [[<span class="string">'Tom'</span>, <span class="string">'Billy'</span>, <span class="string">'Jefferson'</span>, <span class="string">'Andrew'</span>, <span class="string">'Wesley'</span>, <span class="string">'Steven'</span>, <span class="string">'Joe'</span>],</span><br><span class="line">            [<span class="string">'Alice'</span>, <span class="string">'Jill'</span>, <span class="string">'Ana'</span>, <span class="string">'Wendy'</span>, <span class="string">'Jennifer'</span>, <span class="string">'Sherry'</span>, <span class="string">'Eva'</span>]]</span><br><span class="line">l = [name <span class="keyword">for</span> lst <span class="keyword">in</span> double_l <span class="keyword">for</span> name <span class="keyword">in</span> lst <span class="keyword">if</span> name.count(<span class="string">'e'</span>) &gt;= <span class="number">2</span>]</span><br><span class="line">print(l)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Jefferson'</span>, <span class="string">'Wesley'</span>, <span class="string">'Steven'</span>, <span class="string">'Jennifer'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------字典推导-------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例一：将一个字典的key和value对调</span></span><br><span class="line">mcase = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">34</span>&#125;</span><br><span class="line">mcase_frequency = &#123;mcase[k]: k <span class="keyword">for</span> k <span class="keyword">in</span> mcase&#125;</span><br><span class="line">print(mcase_frequency)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">34</span>: <span class="string">'b'</span>, <span class="number">10</span>: <span class="string">'a'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例二：合并大小写对应的value值，将k统一成小写</span></span><br><span class="line">mcase = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">34</span>, <span class="string">'A'</span>: <span class="number">7</span>, <span class="string">'Z'</span>: <span class="number">3</span>&#125;</span><br><span class="line">mcase_frequency = &#123;k.lower(): mcase.get(k.lower(), <span class="number">0</span>) + mcase.get(k.upper(), <span class="number">0</span>) <span class="keyword">for</span> k <span class="keyword">in</span> mcase.keys()&#125;</span><br><span class="line">print(mcase_frequency)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'b'</span>: <span class="number">34</span>, <span class="string">'a'</span>: <span class="number">17</span>, <span class="string">'z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------集合推导-------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算列表中每个值的平方，自带去重功能</span></span><br><span class="line">squared = &#123;x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">print(squared)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="/images/post_imgs/iterator.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可迭代对象&quot;&gt;&lt;a href=&quot;#可迭代对象&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象&quot;&gt;&lt;/a&gt;可迭代对象&lt;/h3&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python闭包&amp;装饰器</title>
    <link href="https://elijahyg.github.io/2020/03/14/Python%E9%97%AD%E5%8C%85&amp;%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://elijahyg.github.io/2020/03/14/Python闭包&amp;装饰器/</id>
    <published>2020-03-14T08:42:22.000Z</published>
    <updated>2020-03-14T08:43:40.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包-amp-装饰器"><a href="#闭包-amp-装饰器" class="headerlink" title="闭包 &amp; 装饰器"></a>闭包 &amp; 装饰器</h2><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><ul><li>开放：对于添加新功能是开放的</li><li>封闭：对于修改原功能是封闭的</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>内部函数包含对外部作用域而非全剧作用域变量的引用，则称该内部函数称为闭包函数。</p><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>输出的<code>__closure__</code>是否有cell元素</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>为函数增加功能</li><li>为函数提前赋值</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></table></figure><hr><h3 id="装饰器（闭包应用）"><a href="#装饰器（闭包应用）" class="headerlink" title="装饰器（闭包应用）"></a>装饰器（闭包应用）</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在不更改原函数调用方式的前提下对原函数添加新功能</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用闭包原理，通过在内部函数中调用外部函数的变量，实现在不改变原函数调用方式的前提下对原函数添加新功能。</p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li>简单装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        f()</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数！'</span>)</span><br><span class="line"></span><br><span class="line">func = deco(func)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><ul><li>装饰器的语法糖</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        f()</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco # ——&gt;此处效果等同于 func = deco(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><ul><li>带返回值的装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        res = f()</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><ul><li>带参数、带返回值的装饰器（标准格式）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        res = f(*args,**kwargs)</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line">func(*args,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>多层装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer_wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">            res = f(*args,**kwargs)</span><br><span class="line">            <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> outer_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line">func(*args,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>多个装饰器修饰同一个函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco1</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        res = f(*args,**kwargs)</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco2</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""原函数前添加的功能"""</span></span><br><span class="line">        res = f(*args,**kwargs)</span><br><span class="line">        <span class="string">"""原函数后添加的功能"""</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco1  # 其次执行</span></span><br><span class="line"><span class="meta">@deco2  # 首先执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line">func(*args,**kwargs)</span><br></pre></td></tr></table></figure><ul><li>装饰器wraps版本（标准格式）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func) #加在最内层函数正上方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">origin_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    这是原函数的注释</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">'这是原函数'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然已经执行了装饰器，origin_func已经指向wrapper，但是如果用了@wraps(func)装饰器之后调用origin_func的双下划线方法依然是原函数origin_func的</span></span><br><span class="line">print(origin_func.__name__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>origin_func</span><br><span class="line"></span><br><span class="line">print(origin_func.__doc__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>这是原函数的注释</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>:<span class="keyword">return</span>:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闭包-amp-装饰器&quot;&gt;&lt;a href=&quot;#闭包-amp-装饰器&quot; class=&quot;headerlink&quot; title=&quot;闭包 &amp;amp; 装饰器&quot;&gt;&lt;/a&gt;闭包 &amp;amp; 装饰器&lt;/h2&gt;&lt;h3 id=&quot;开放封闭原则&quot;&gt;&lt;a href=&quot;#开放封闭原则&quot; cla
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python各种函数</title>
    <link href="https://elijahyg.github.io/2020/03/14/Python%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://elijahyg.github.io/2020/03/14/Python各种函数/</id>
    <published>2020-03-14T08:33:42.000Z</published>
    <updated>2020-03-14T08:34:49.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种函数"><a href="#各种函数" class="headerlink" title="各种函数"></a>各种函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><h4 id="内置函数概念"><a href="#内置函数概念" class="headerlink" title="内置函数概念"></a>内置函数概念</h4><p>内置函数就是Python解释器已经写好可以提供给用户直接使用的函数。目前Python的内置函数一共是69个。</p><h4 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h4><table><thead><tr><th align="center"></th><th align="center"></th><th align="center">内置函数</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#abs" title="abs" target="_blank" rel="noopener">abs()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#delattr" title="delattr" target="_blank" rel="noopener">delattr()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" title="hash" target="_blank" rel="noopener">hash()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#func-memoryview" target="_blank" rel="noopener">memoryview()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#func-set" target="_blank" rel="noopener">set()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#all" title="all" target="_blank" rel="noopener">all()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#func-dict" target="_blank" rel="noopener">dict()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#help" title="help" target="_blank" rel="noopener">help()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" title="min" target="_blank" rel="noopener">min()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#setattr" title="setattr" target="_blank" rel="noopener">setattr()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#any" title="any" target="_blank" rel="noopener">any()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#dir" title="dir" target="_blank" rel="noopener">dir()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#hex" title="hex" target="_blank" rel="noopener">hex()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#next" title="next" target="_blank" rel="noopener">next()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#slice" title="slice" target="_blank" rel="noopener">slice()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#ascii" title="ascii" target="_blank" rel="noopener">ascii()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#divmod" title="divmod" target="_blank" rel="noopener">divmod()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#id" title="id" target="_blank" rel="noopener">id()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#object" title="object" target="_blank" rel="noopener">object()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#sorted" title="sorted" target="_blank" rel="noopener">sorted()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#bin" title="bin" target="_blank" rel="noopener">bin()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#enumerate" title="enumerate" target="_blank" rel="noopener">enumerate()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#input" title="input" target="_blank" rel="noopener">input()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#oct" title="oct" target="_blank" rel="noopener">oct()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#staticmethod" title="staticmethod" target="_blank" rel="noopener">staticmethod()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#bool" title="bool" target="_blank" rel="noopener">bool()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#eval" title="eval" target="_blank" rel="noopener">eval()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#int" title="int" target="_blank" rel="noopener">int()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#open" title="open" target="_blank" rel="noopener">open()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-str" target="_blank" rel="noopener">str()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#breakpoint" title="breakpoint" target="_blank" rel="noopener">breakpoint()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#exec" title="exec" target="_blank" rel="noopener">exec()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#isinstance" title="isinstance" target="_blank" rel="noopener">isinstance()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#ord" title="ord" target="_blank" rel="noopener">ord()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#sum" title="sum" target="_blank" rel="noopener">sum()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-bytearray" target="_blank" rel="noopener">bytearray()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#filter" title="filter" target="_blank" rel="noopener">filter()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#issubclass" title="issubclass" target="_blank" rel="noopener">issubclass()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#pow" title="pow" target="_blank" rel="noopener">pow()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#super" title="super" target="_blank" rel="noopener">super()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-bytes" target="_blank" rel="noopener">bytes()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#float" title="float" target="_blank" rel="noopener">float()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#iter" title="iter" target="_blank" rel="noopener">iter()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#print" title="print" target="_blank" rel="noopener">print()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-tuple" target="_blank" rel="noopener">tuple()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#callable" title="callable" target="_blank" rel="noopener">callable()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#format" title="format" target="_blank" rel="noopener">format()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#len" title="len" target="_blank" rel="noopener">len()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#property" title="property" target="_blank" rel="noopener">property()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#type" title="type" target="_blank" rel="noopener">type()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#chr" title="chr" target="_blank" rel="noopener">chr()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-frozenset" target="_blank" rel="noopener">frozenset()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-list" target="_blank" rel="noopener">list()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#func-range" target="_blank" rel="noopener">range()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#vars" title="vars" target="_blank" rel="noopener">vars()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#classmethod" title="classmethod" target="_blank" rel="noopener">classmethod()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#getattr" title="getattr" target="_blank" rel="noopener">getattr()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#locals" title="locals" target="_blank" rel="noopener">locals()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#repr" title="repr" target="_blank" rel="noopener">repr()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#zip" title="zip" target="_blank" rel="noopener">zip()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#compile" title="compile" target="_blank" rel="noopener">compile()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#globals" title="globals" target="_blank" rel="noopener">globals()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#map" title="map" target="_blank" rel="noopener">map()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#reversed" title="reversed" target="_blank" rel="noopener">reversed()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#__import__" title="__import__" target="_blank" rel="noopener">__import__()</a></td></tr><tr><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#complex" title="complex" target="_blank" rel="noopener">complex()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#hasattr" title="hasattr" target="_blank" rel="noopener">hasattr()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#max" title="max" target="_blank" rel="noopener">max()</a></td><td align="center"><a href="https://docs.python.org/zh-cn/3/library/functions.html?#round" title="round" target="_blank" rel="noopener">round()</a></td><td align="center"></td></tr></tbody></table><h4 id="内置函数分类"><a href="#内置函数分类" class="headerlink" title="内置函数分类"></a>内置函数分类</h4><ul><li>数据类型相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一、基础数据类型</span></span><br><span class="line">bool(): 用于将给定参数转换为布尔类型，如果没有参数，返回 <span class="literal">False</span>。</span><br><span class="line">int(): 用于将一个字符串或数字转换为整型。</span><br><span class="line">float(): 用于将整数和字符串转换成浮点数。</span><br><span class="line">complex(): 用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数</span><br><span class="line">str(): 将对象转化为字符串形式</span><br><span class="line">list(): 用于将元组转换为列表。</span><br><span class="line">tuple(): 将列表转换为元组。</span><br><span class="line">dict(): 用于创建一个字典</span><br><span class="line">set(): 用于创建一个集合</span><br><span class="line">frozenset(): 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、进制转换</span></span><br><span class="line">bin(): 返回一个整数 int 或者长整数 long int 的二进制表示。</span><br><span class="line">oct(): 将一个整数转换成<span class="number">8</span>进制字符串。</span><br><span class="line">hex(): 于将<span class="number">10</span>进制整数转换成<span class="number">16</span>进制，以字符串形式表示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三、数学运算</span></span><br><span class="line">abs(): 返回数字的绝对值。</span><br><span class="line">divmod(): 把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)</span><br><span class="line">min(): 返回给定参数的最小值，参数可以为序列</span><br><span class="line">max(): 返回给定参数的最大值，参数可以为序列</span><br><span class="line">sum(): 对可迭代对象进行求和计算</span><br><span class="line">round(): 返回浮点数的四舍六入五留双</span><br><span class="line">pow(): 返回 xy（x的y次方）的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 四、字符串操作</span></span><br><span class="line">ascii(): 类似 repr() 函数, 返回一个表示对象的字符串</span><br><span class="line">ord(): 以一个字符（长度为<span class="number">1</span>的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值</span><br><span class="line">chr(): 用一个范围在 range（<span class="number">256</span>）内的（就是<span class="number">0</span>～<span class="number">255</span>）整数作参数，返回一个对应的字符</span><br><span class="line">format(): 格式化编辑字符串</span><br><span class="line">repr(): 将对象转化为供解释器读取的形式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 五、序列操作（包含二进制序列）</span></span><br><span class="line">bytes(): 返回一个新的数组对象，这个数组对象不能对数组元素进行修改。</span><br><span class="line">bytearray(): 返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围:</span><br><span class="line">memoryview(): 返回给定参数的内存查看对象(Momory view)。</span><br><span class="line">reversed(): 反转一个序列对象，将其元素从后向前颠倒构建成一个新的迭代器</span><br><span class="line">slice(): 实现切片对象，主要用在切片操作函数里的参数传递</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 六、功能性方法</span></span><br><span class="line">len(): 返回对象（字符、列表、元组等）长度或项目个数。</span><br><span class="line">sorted(): 对所有可迭代的对象进行排序操作；内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</span><br><span class="line">enumerate(): 用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 <span class="keyword">for</span> 循环当中。</span><br><span class="line">all(): 用于判断给定的可迭代参数 iterable 中的所有元素是否不为 <span class="number">0</span>、<span class="string">''</span>、<span class="literal">False</span> 或者 iterable 为空，如果是返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。</span><br><span class="line">any(): 用于判断给定的可迭代参数 iterable 是否全部为空对象，如果都为空、<span class="number">0</span>、false，则返回 <span class="literal">False</span>，如果不都为空、<span class="number">0</span>、false，则返回 <span class="literal">True</span>。</span><br><span class="line">zip(): 用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</span><br><span class="line">filter(): 用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</span><br><span class="line">map(): 根据提供的函数对指定序列做映射。</span><br></pre></td></tr></table></figure><ul><li>作用域相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">globals(): 获取全局变量的字典。</span><br><span class="line">locals(): 获取执行本方法所在命名空间内的局部变量的字典。</span><br></pre></td></tr></table></figure><ul><li>迭代器、生成器相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range(): 创建一个整数列表，一般用在 <span class="keyword">for</span> 循环中。</span><br><span class="line">next(): 调用可迭代对象或迭代器的next方法，取到一个元素。</span><br><span class="line">iter(): 将可迭代对象转化称迭代器。</span><br></pre></td></tr></table></figure><ul><li>面向对象相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一、对象</span></span><br><span class="line">object(): 返回一个没有特征的新对象。object 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。</span><br><span class="line">id(): 返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。</span><br><span class="line">hash(): 返回该对象的哈希值（如果它有的话）。</span><br><span class="line">open(): 打开 file 并返回对应的 file object。</span><br><span class="line">callable(): 如果参数 object 是可调用的就返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。 </span><br><span class="line">type(): 传入一个参数时，返回 object 的类型。 返回值是一个 type 对象，通常与 object.__class__ 所返回的对象相同。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二、类</span></span><br><span class="line">classmethod(): 把一个方法封装成类方法。一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。</span><br><span class="line">staticmethod(): 将方法转换为静态方法。静态方法不会接收隐式的第一个参数。</span><br><span class="line">isinstance(): 如果参数 object 是参数 classinfo 的实例或者是其 (直接、间接或 虚拟) 子类则返回 <span class="literal">True</span>。 如果 object 不是给定类型的对象，函数将总是返回 <span class="literal">False</span>。 </span><br><span class="line">issubclass(): 如果 <span class="class"><span class="keyword">class</span> 是 <span class="title">classinfo</span> 的 <span class="params">(直接、间接或 虚拟)</span> 子类则返回 <span class="title">True</span>。 </span></span><br><span class="line"><span class="class"><span class="title">super</span><span class="params">()</span>:</span> 返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。</span><br><span class="line">property(): 返回 property 属性。fget 是获取属性值的函数。 fset 是用于设置属性值的函数。 fdel 是用于删除属性值的函数。并且 doc 为属性对象创建文档字符串。</span><br><span class="line">vars(): 返回模块、类、实例或任何其它具有 __dict__ 属性的对象的 __dict__ 属性。</span><br></pre></td></tr></table></figure><ul><li>反射相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hasattr(): 该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <span class="literal">True</span>，否则返回 <span class="literal">False</span>。</span><br><span class="line">setattr(): 此函数与 getattr() 两相对应。 其参数为一个对象、一个字符串和一个任意值。 字符串指定一个现有属性或者新增属性。 函数会将值赋给该属性，只要对象允许这种操作。 </span><br><span class="line">getattr(): 返回对象命名属性的值。name 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。</span><br><span class="line">delattr(): setattr() 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。</span><br></pre></td></tr></table></figure><ul><li>代码执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(): 数据字符串形式的表达式，python解释器可以直接执行。</span><br><span class="line">exec(): 这个函数支持动态执行 Python 代码。object 必须是字符串或者代码对象。</span><br><span class="line">compile(): 将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。</span><br></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">help(): 启动内置的帮助系统（此函数主要在交互式中使用）。</span><br><span class="line">print(): 将 objects 打印到 file 指定的文本流，以 sep 分隔并在末尾加上 end。 </span><br><span class="line">input(): 如果存在 prompt 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。</span><br><span class="line">dir(): 如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</span><br><span class="line">breakpoint(): 此函数会在调用时将你陷入调试器中。（<span class="number">3.7</span> 新版功能）</span><br><span class="line">__import__(): 此函数会由 <span class="keyword">import</span> 语句发起调用。（不建议使用）</span><br></pre></td></tr></table></figure><hr><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="定义函数的流程"><a href="#定义函数的流程" class="headerlink" title="定义函数的流程"></a>定义函数的流程</h4><ul><li><p>函数定义<br>关键字<code>def</code>引入一个函数定义。<br>它必须后跟函数名称和带括号的形式参数列表。<br>构成函数体的语句从下一行开始，并且必须缩进。</p></li><li><p>函数体<br>函数体的第一个语句可以（可选的）是字符串文字；<br>这个字符串文字是函数的文档字符串或 docstring 。<br>有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；<br>在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。</p></li><li><p>函数执行<br>函数的执行会引入一个用于函数局部变量的新符号表。<br>更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。<br>因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 global 语句中定义的全局变量，或者是在 nonlocal 语句中定义的外层函数的变量），尽管它们可以被引用。</p></li><li><p>函数调用<br>在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；<br>因此，实参是通过按值调用传递的（其中值始终是对象 引用而不是对象的值）。<br>当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。</p></li><li><p>函数的使用<br>函数定义会把函数名引入当前的符号表中。<br>函数名称的值具有解释器将其识别为用户定义函数的类型。<br>这个值可以分配给另一个名称，该名称也可以作为一个函数使用。</p></li><li><p>函数返回值<br>事实上，即使没有 return 语句的函数也会返回一个值, 称为 None（内置名称）。</p></li></ul><h4 id="定义函数举例"><a href="#定义函数举例" class="headerlink" title="定义函数举例"></a>定义函数举例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write Fibonacci series up to n</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Print a Fibonacci series up to n."""</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        print(a, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure><hr><h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>嵌套函数（Nested function）是在另一个函数（封闭函数）中定义的函数。</p><h4 id="原理依据"><a href="#原理依据" class="headerlink" title="原理依据"></a>原理依据</h4><p>函数属于一类对象。在一个函数内部执行的<code>def</code>语句会定义一个局部函数并可被返回或传递。在嵌套函数中使用的自由变量可以访问包含该<code>def</code>语句的函数的局部变量。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    x=<span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        y=<span class="number">2</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> x+y</span><br><span class="line"><span class="meta">... </span>    bar()</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>python支持嵌套函数。</li><li>内层函数可以访问外层函数中定义的变量，但不能重新赋值。</li><li>内层函数的local namespace不包含外层函数定义的变量。</li></ul><hr><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>递归函数就是函数里调用其自身。</li><li>递归函数必须有一个明确的递归结束条件，称之为递归出口，否则递归深度过深会发生堆栈溢出。</li><li>递归的最大深度在python中也有限制，可以通过<code>sys.setrecursionlimit()</code>函数进行调整，除非很清楚应如何调整，否则不建议修改默认的最大递归深度。</li></ul><h4 id="递归函数示例"><a href="#递归函数示例" class="headerlink" title="递归函数示例"></a>递归函数示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现阶乘：n! = 1 × 2 × 3 × … × n，或n! = (n-1)! × n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------迭代的实现方式----------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    result = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>        result *= i</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">10</span>)</span><br><span class="line"><span class="number">3628800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------递归的实现方式----------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">10</span>)</span><br><span class="line"><span class="number">3628800</span></span><br></pre></td></tr></table></figure><h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><ul><li>理论上，所有的递归函数都可以写成循环的方式。</li><li>解决递归调用栈溢出的方法是通过尾递归优化。尾递归是指在函数返回的时候，调用其自身，并且return语句不能包含表达式。这样解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</li></ul><hr><h3 id="匿名函数-Lambda"><a href="#匿名函数-Lambda" class="headerlink" title="匿名函数 Lambda"></a>匿名函数 Lambda</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>可以用lambda关键字来创建匿名函数。Lambda函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量。</p><h4 id="Lambda函数语法"><a href="#Lambda函数语法" class="headerlink" title="Lambda函数语法"></a>Lambda函数语法</h4><p><code>函数名 = lambda 参数 ：返回值</code></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----------示例一----------</span></span><br><span class="line"><span class="comment"># lambda表达式来返回一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>)</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------示例二----------</span></span><br><span class="line"><span class="comment"># 传递一个函数作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">'four'</span>), (<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">2</span>, <span class="string">'two'</span>)]</span><br></pre></td></tr></table></figure><hr><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>函数的形参接受另外一个函数的函数名，则称这个函数为高阶函数。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(add(<span class="number">-5</span>, <span class="number">6</span>, abs))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、filter()</span><br><span class="line">功能：用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。</span><br><span class="line">调用：filter（function，sequence）</span><br><span class="line">示例：</span><br><span class="line"><span class="comment"># 找出偶数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x:x%<span class="number">2</span> == <span class="number">0</span>,x)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、map()</span><br><span class="line">功能：返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。</span><br><span class="line">调用：map(function, iterable, ...)</span><br><span class="line">示例：</span><br><span class="line"><span class="comment"># 计算列表各个元素的平方</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> square(x):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(square,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># return</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、reduce()</span><br><span class="line">功能：将两个参数的 function 从左至右积累地应用到 iterable 的条目，以便将该可迭代对象缩减为单一的值。</span><br><span class="line">调用：functools.reduce(function, iterable[, initializer])</span><br><span class="line">示例：</span><br><span class="line"><span class="comment"># 计算列表和</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span> </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><hr><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>返回一个新的部分对象，当被调用时其行为类似于func附带位置参数args和关键字参数keywords被调用。 如果为调用提供了更多的参数，它们会被附加到args。如果提供了额外的关键字参数，它们会扩展并重载keywords。</li><li>偏函数是将所要承载的函数作为partial()函数的第一个参数，原函数的各个参数依次作为partial()函数后续的参数，除非使用关键字参数。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----------无关键字参数----------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mod</span><span class="params">( n, m )</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> n % m</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod_by_100 = partial( mod, <span class="number">100</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mod(<span class="number">100</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mod_by_100(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------有关键字参数----------</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin2dec = partial( int, base=<span class="number">2</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> bin2dec( <span class="string">'0b10001'</span> )</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> bin2dec( <span class="string">'10001'</span> )</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex2dec = partial( int, base=<span class="number">16</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex2dec( <span class="string">'0x67'</span> )</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex2dec( <span class="string">'67'</span> )</span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;各种函数&quot;&gt;&lt;a href=&quot;#各种函数&quot; class=&quot;headerlink&quot; title=&quot;各种函数&quot;&gt;&lt;/a&gt;各种函数&lt;/h2&gt;&lt;h3 id=&quot;内置函数&quot;&gt;&lt;a href=&quot;#内置函数&quot; class=&quot;headerlink&quot; title=&quot;内置函数&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python初识函数</title>
    <link href="https://elijahyg.github.io/2020/02/26/Python%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/"/>
    <id>https://elijahyg.github.io/2020/02/26/Python初识函数/</id>
    <published>2020-02-26T14:07:46.000Z</published>
    <updated>2020-02-26T14:14:07.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识函数"><a href="#初识函数" class="headerlink" title="初识函数"></a>初识函数</h2><h3 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h3><p>wiki百科中解释：函数是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。<br>简而言之，函数就是具有输入参数、输出参数的，并且可以独立完成特定功能的程序代码。</p><h3 id="函数与方法的区别"><a href="#函数与方法的区别" class="headerlink" title="函数与方法的区别"></a>函数与方法的区别</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>通过<code>函数名()</code>的方式调用</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>通过<code>类的实例.方法名()</code>的方式调用</li></ul><h4 id="判断函数or方法"><a href="#判断函数or方法" class="headerlink" title="判断函数or方法"></a>判断函数or方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType, MethodType</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self,<span class="string">"in func"</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()  <span class="comment"># foo是类Foo的实例</span></span><br><span class="line">foo.func()  <span class="comment"># 类Foo的实例调用func</span></span><br><span class="line">Foo.func(foo)  <span class="comment"># 类Foo调用func，并传入foo实例</span></span><br><span class="line"></span><br><span class="line">print(isinstance(foo.func, FunctionType))  <span class="comment"># False</span></span><br><span class="line">print(isinstance(foo.func, MethodType))   <span class="comment"># True   #说明这是一个方法</span></span><br><span class="line"></span><br><span class="line">print(isinstance(Foo.func, FunctionType))  <span class="comment"># True   #说明这是一个函数。</span></span><br><span class="line">print(isinstance(Foo.func, MethodType))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>wiki百科中的解释：它表示着一个标识符的可见范围。<br>简而言之，命名空间就是对象或变量的作用范围。<br>python中的命名空间：内置命名空间、全局命名空间、局部命名空间</p><ul><li>内置命名空间: python编译器启动时就可以使用的名字存在内置命名空间中</li><li>全局命名空间: 除函数外的代码部分</li><li>局部命名空间: 函数内部的代码部分</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>wiki百科中解释：作用域是名字（name）与实体（entity）的绑定保持有效的那部分计算机程序。<br>简而言之，作用域就是变量有效的代码区域。<br>python中的作用域分为：全局变量作用域、局部变量作用域</p><ul><li>全局变量作用域：是整个代码范围。</li><li>局部变量作用域：是定义该变量的子程序的代码范围。</li><li>同名变量在全局和局部变量作用域如何划分：在局部变量作用域代码范围内，局部变量起作用;在其他地方全局变量起作用。</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数的概念"><a href="#参数的概念" class="headerlink" title="参数的概念"></a>参数的概念</h4><p>参数可以理解为函数的输入值。</p><h4 id="参数的种类"><a href="#参数的种类" class="headerlink" title="参数的种类"></a>参数的种类</h4><ul><li>形参的角度（函数定义阶段）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置参数：必须传，且有多少就必须传多少</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名是:'</span> + name + <span class="string">'\n性别是:'</span> + sex)</span><br><span class="line">name_sex(<span class="string">'张三'</span>,<span class="string">'男'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>姓名是:张三</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>性别是:男</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认参数：可传可不传，不传则使用默认值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(name, sex=<span class="string">'男'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名是:'</span> + name + <span class="string">'\n性别是:'</span> + sex)</span><br><span class="line">name_sex(<span class="string">'张三'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>姓名是:张三</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>性别是:男</span><br><span class="line"></span><br><span class="line"><span class="comment"># *args：接收的是按照位置传参的值，组织成一个元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">name_sex(<span class="string">'张三'</span>,<span class="string">'男'</span>)</span><br><span class="line">&gt;&gt;&gt;(<span class="string">'张三'</span>, <span class="string">'男'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># **kwargs：接受的是按照关键字传参的值，组织成一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">name_sex(姓名=<span class="string">'张三'</span>,性别=<span class="string">'男'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'性别'</span>: <span class="string">'男'</span>, <span class="string">'姓名'</span>: <span class="string">'张三'</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>实参的角度（函数调用阶段）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按位置传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名是:'</span> + name + <span class="string">'\n性别是:'</span> + sex)</span><br><span class="line">name_sex(<span class="string">'张三'</span>, <span class="string">'男'</span>)</span><br><span class="line">&gt;&gt;&gt;姓名是:张三</span><br><span class="line">&gt;&gt;&gt;性别是:男</span><br><span class="line"></span><br><span class="line"><span class="comment"># *按关键字传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名是:'</span> + name + <span class="string">'\n性别是:'</span> + sex)</span><br><span class="line">name_sex(sex=<span class="string">'男'</span>,name=<span class="string">'张三'</span>)</span><br><span class="line">&gt;&gt;&gt;姓名是:张三</span><br><span class="line">&gt;&gt;&gt;性别是:男</span><br><span class="line"></span><br><span class="line"><span class="comment"># *按位置、按关键字混合传参：必须按照位置参数，再按照关键字传参，不能将参数赋予多个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name_sex</span><span class="params">(name, sex)</span>:</span></span><br><span class="line">    print(<span class="string">'姓名是:'</span> + name + <span class="string">'\n性别是:'</span> + sex)</span><br><span class="line">name_sex(<span class="string">'张三'</span>,sex=<span class="string">'男'</span>)</span><br><span class="line">&gt;&gt;&gt;姓名是:张三</span><br><span class="line">&gt;&gt;&gt;性别是:男</span><br></pre></td></tr></table></figure><h4 id="多种参数混合的顺序"><a href="#多种参数混合的顺序" class="headerlink" title="多种参数混合的顺序"></a>多种参数混合的顺序</h4><ul><li>位置参数 -&gt; *args -&gt; 默认参数 -&gt; **kwargs</li></ul><h4 id="动态参数的另一个传参方式"><a href="#动态参数的另一个传参方式" class="headerlink" title="动态参数的另一个传参方式"></a>动态参数的另一个传参方式</h4><ul><li>站在形参的角度上，给变量加上*，就是组合所有传来的值。</li><li>站在实参的角度上，给一个序列加上*，就是将这个序列按照顺序打散</li></ul><h4 id="默认参数的陷阱"><a href="#默认参数的陷阱" class="headerlink" title="默认参数的陷阱"></a>默认参数的陷阱</h4><ul><li>默认参数是可变数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg,lst = [])</span>:</span></span><br><span class="line">    lst.append(arg)</span><br><span class="line">    print(lst)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'python'</span>)</span><br><span class="line">foo(<span class="string">'java'</span>)</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="返回值的概念"><a href="#返回值的概念" class="headerlink" title="返回值的概念"></a>返回值的概念</h4><p>返回值可以理解为函数的输出值。</p><h4 id="返回值的种类"><a href="#返回值的种类" class="headerlink" title="返回值的种类"></a>返回值的种类</h4><ul><li>没有返回值，默认返回None<ul><li>只有return：结束一个函数的继续</li><li>没有return</li><li>return None：不常用</li></ul></li><li>一个返回值<ul><li>可以返回任何数据类型</li><li>只要返回就可以接收到</li><li>如果在一个函数中有多个return，只返回第一个</li></ul></li><li>多个返回值<ul><li>用多个变量接收：有多少返回值就要有多少变量接收</li><li>用一个变量接收：接收到的是一个元组</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初识函数&quot;&gt;&lt;a href=&quot;#初识函数&quot; class=&quot;headerlink&quot; title=&quot;初识函数&quot;&gt;&lt;/a&gt;初识函数&lt;/h2&gt;&lt;h3 id=&quot;函数的概念&quot;&gt;&lt;a href=&quot;#函数的概念&quot; class=&quot;headerlink&quot; title=&quot;函数的概念&quot;&gt;
      
    
    </summary>
    
    
      <category term="Python系列" scheme="https://elijahyg.github.io/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
</feed>
