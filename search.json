[{"title":"PythonIO多路复用","url":"/2021/01/10/PythonIO多路复用/","content":"\n## I/O多路复用\n### I/O模型\n此处所讲的I/O模型是参考Richard Stevens所著《UNIX网络编程 卷1：套接字联网API》（第3版）中的I/O模型为基础。列举了其中所讲的5中I/O网络模型并加以描述对比。\n\n#### 网络I/O发生时系统涉及的操作\n - 数据准备（等待数据通过网络送达）\n - 将数据从内核复制到程序进程\n\n#### 阻塞I/O（blocking I/O）\n - 【Step 1】应用进程执行系统调用，阻塞直至数据准备完成\n - 【Step 2】将数据从内核复制到用户空间\n - 【Step 3】数据复制完成，返回成功指示，应用程序进程处理数据\n\n![](/images/post_imgs/blocking.jpg)\n\n#### 非阻塞I/O（non-blocking I/O）\n - 【Step 1】应用进程执行系统调用，内核如果没有准备好数据不会阻塞，而是会以非阻塞方式返回错误码告知应用进程\n - 【Step 2】应用进程收到错误码后依然会不断系统调用询问内核是否准备好数据，直至内核准备好数据，返回成功\n - 【Step 3】将数据从内核复制到用户空间\n - 【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据\n\n\n![](/images/post_imgs/non-blocking.jpg)\n\n#### 多路复用I/O（I/O multiplexing）\n类似于非阻塞I/O的轮询系统调用方式，区别在于轮询的执行不是由用户线程调用，而是内核调用\n - 【Step 1】应用进程执行系统调用，内核如果没有准备好数据不会阻塞，而是会以非阻塞方式返回错误码告知应用进程\n - 【Step 2】内核以轮询方式不断检查是否准备好数据，直至数据准备完成，返回成功\n - 【Step 3】将数据从内核复制到用户空间\n - 【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据\n\n\n![](/images/post_imgs/multiplexing.jpg)\n#### 信号驱动I/O（signal driven I/O） \n使用信号，内核在数据准备就绪时通过信号来进行通知\n - 【Step 1】建立SIGIO的信号处理程序进行系统调用\n - 【Step 2】内核准备好数据后通过递交SIGIO告知应用进程\n - 【Step 3】将数据从内核复制到用户空间\n - 【Step 4】数据复制完成，返回成功指示，应用程序进程处理数据\n\n\n![](/images/post_imgs/signal_driven.jpg)\n#### 异步I/O（Asynchronous I/O）\n异步I/O通过信号处理程序告知应用进程，其告知应用进程的是I/O操作完成，而不是数据准备完成\n - 【Step 1】应用进程进行系统调用，内核通过非阻塞方式返回给应用程序\n - 【Step 2】当数据准备好时内核将数据复制到用户空间\n - 【Step 3】数据复制完成，递交再aio_read中指定的信号，应用程序进程处理数据\n\n![](/images/post_imgs/Asynchronous.jpg)\n\n#### I/O模型比较分析\n - 阻塞I/O、非阻塞I/O、多路复用I/O、信号驱动I/O的相同点在于数据准备期间与数据从内核复制到用户空间这段过程中，都是阻塞状态。即上述这四种I/O模型都是同步I/O模型。\n - 异步I/O操作不会讲进程阻塞。\n\n![](/images/post_imgs/compare.jpg)\n\n---\n\n### I/O多路复用的机制【TODO】\n#### Select\n线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）\n\n#### Poll\n同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作\n\n#### Epoll\n用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销\n\n\n","categories":["Python系列"]},{"title":"Python中协程","url":"/2021/01/10/Python中协程/","content":"\n## Python中协程\n### asyncio模块\n#### 概念\nasyncio 是用来编写 并发 代码的库，使用 async/await 语法。\nasyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。\nasyncio 往往是构建 IO 密集型和高层级 结构化 网络代码的最佳选择。\n\n#### 作用\n - 提供`高层级API`\n  - 并发地运行 Python 协程并对其执行过程实现完全控制\n  - 执行 网络 IO 和 IPC\n  - 控制 子进程\n  - 通过 队列 实现分布式任务\n  - 同步 并发代码\n\n - 提供`低层级API`\n  - 创建和管理 事件循环，以提供异步 API 用于 网络化, 运行 子进程，处理 OS 信号 等等\n  - 使用 transports 实现高效率协议\n  - 通过 async/await 语法 桥接 基于回调的库和代码\n\n---\n\n### asyncio模块之协程\n#### 协程\n - 概念\n使用async / await语法声明的协程是编写异步应用程序的首选方式。\n\n - 三种运行协程的机制\n\n```python\n# --------------------------------------------------------------------------------\n# 一、asyncio.run() 函数用来运行最高层级的入口点 \"main()\" 函数\n# --------------------------------------------------------------------------------\nimport asyncio\n\nasync def main():\n    print('hello')\n    await asyncio.sleep(1)\n    print('world')\n\nasyncio.run(main())\n\n# 输出\nhello\nworld\n\n# --------------------------------------------------------------------------------\n# 二、等待一个协程\n# --------------------------------------------------------------------------------\nimport asyncio\nimport time\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n    print(f\"started at {time.strftime('%X')}\")\n\n    await say_after(1, 'hello')\n    await say_after(2, 'world')\n\n    print(f\"finished at {time.strftime('%X')}\")\n\nasyncio.run(main())\n\n# 输出\nstarted at 17:13:52\nhello\nworld\nfinished at 17:13:55\n\n# --------------------------------------------------------------------------------\n# 三、asyncio.create_task() 函数用来并发运行作为 asyncio 任务 的多个协程。\n# --------------------------------------------------------------------------------\nasync def main():\n    task1 = asyncio.create_task(\n        say_after(1, 'hello'))\n\n    task2 = asyncio.create_task(\n        say_after(2, 'world'))\n\n    print(f\"started at {time.strftime('%X')}\")\n\n    # Wait until both tasks are completed (should take\n    # around 2 seconds.)\n    await task1\n    await task2\n\n    print(f\"finished at {time.strftime('%X')}\")\n\n# 输出\nstarted at 17:14:32\nhello\nworld\nfinished at 17:14:34\n```\n\n#### 可等待对象\n - 概念\n如果一个对象可以在 await 语句中使用，那么它就是 可等待 对象。\n\n - 类型\n可等待 对象有三种主要类型: `协程（包括协程函数、协程对象）`, `任务` 和 `Future`\n\n\n#### 并发协程\n - 语法\nasyncio.gather(*aws, loop=None, return_exceptions=False)\n  - 并发 运行 aws 序列中的 可等待对象。\n  - 如果 aws 中的某个可等待对象为协程，它将自动作为一个任务加入日程。\n  - 如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。\n\n - 示例\n\n```python\nimport asyncio\n\nasync def factorial(name, number):\n    f = 1\n    for i in range(2, number + 1):\n        print(f\"Task {name}: Compute factorial({i})...\")\n        await asyncio.sleep(1)\n        f *= i\n    print(f\"Task {name}: factorial({number}) = {f}\")\n\nasync def main():\n    # Schedule three calls *concurrently*:\n    await asyncio.gather(\n        factorial(\"A\", 2),\n        factorial(\"B\", 3),\n        factorial(\"C\", 4),\n    )\n\nasyncio.run(main())\n\n# 输出\nTask A: Compute factorial(2)...\nTask B: Compute factorial(2)...\nTask C: Compute factorial(2)...\nTask A: factorial(2) = 2\nTask B: Compute factorial(3)...\nTask C: Compute factorial(3)...\nTask B: factorial(3) = 6\nTask C: Compute factorial(4)...\nTask C: factorial(4) = 24\n```\n\n#### 超时\n - 语法\nasyncio.wait_for(aw, timeout, *, loop=None)\n  - 等待 aw 可等待对象 完成，指定 timeout 秒数后超时。\n  - 如果 aw 是一个协程，它将自动作为任务加入日程。\n  - timeout 可以为 None，也可以为 float 或 int 型数值表示的等待秒数。如果 timeout 为 None，则等待直到完成。\n\n - 示例\n\n```python\nasync def eternity():\n    # Sleep for one hour\n    await asyncio.sleep(3600)\n    print('yay!')\n\nasync def main():\n    # Wait for at most 1 second\n    try:\n        await asyncio.wait_for(eternity(), timeout=1.0)\n    except asyncio.TimeoutError:\n        print('timeout!')\n\nasyncio.run(main())\n\n# 输出\ntimeout!\n```\n\n#### 内省\n - 语法\nasyncio.current_task(loop=None)：返回当前运行的 Task 实例，如果没有正在运行的任务则返回 None。\nasyncio.all_tasks(loop=None)：返回事件循环所运行的未完成的 Task 对象的集合。\n\n\n#### Task 对象\n - 概念\n一个与 Future 类似 的对象，可运行 Python 协程。非线程安全。\nTask 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 完成，被打包的协程将恢复执行。\n\n---\n\n### 支持协程的模块Greenlet/Gevent\n#### Greenlet\n - 概念\ngreenlet提供了一种简单的切换模式，当任务遇到I/O时可以出发阻塞。但是greenlet没有解决切换任务的目的。\n\n - 示例\n\n```python\n# greenlet实现切换\npip install greenlet\n\nfrom greenlet import greenlet\n\ndef foo(x):\n    print('{} at foo_1'.format(x))\n    g2.switch('Elijah')\n    print('{} at foo_2'.format(x))\n    g2.switch()\n\ndef bar(y):\n    print('{} at bar_1'.format(y))\n    g1.switch()\n    print('{} at bar_2'.format(y))\n\ng1 = greenlet(foo)\ng2 = greenlet(bar)\n\ng1.switch('yang')\n```\n\n#### Gevent\n - 概念\nGevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。\nGreenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。\n\n - 示例一\n\n```python\n# ---------- 主动切换 ----------\npip install gevent\nimport gevent\n\ndef foo(x):\n    print('{} at foo_1'.format(x))\n    gevent.sleep(2)\n    print('{} at foo_2'.format(x))\n\ndef bar(y):\n    print('{} at bar_1'.format(y))\n    gevent.sleep(1)\n    print('{} at bar_2'.format(y))\n\ng1 = gevent.spawn(foo, 'yang')\ng2 = gevent.spawn(bar, 'Elijah')\ngevent.joinall([g1,g2])\n```\n\n - 示例二\n\n```python\n# ----------服务端 ----------\nfrom gevent import monkey;monkey.patch_all()\nfrom socket import *\nimport gevent\n\n#如果不想用money.patch_all()打补丁,可以用gevent自带的socket\n# from gevent import socket\n# s=socket.socket()\n\ndef server(server_ip,port):\n    s=socket(AF_INET,SOCK_STREAM)\n    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)\n    s.bind((server_ip,port))\n    s.listen(5)\n    while True:\n        conn,addr=s.accept()\n        gevent.spawn(talk,conn,addr)\n\ndef talk(conn,addr):\n    try:\n        while True:\n            res=conn.recv(1024)\n            print('client %s:%s msg: %s' %(addr[0],addr[1],res))\n            conn.send(res.upper())\n    except Exception as e:\n        print(e)\n    finally:\n        conn.close()\n\nif __name__ == '__main__':\n    server('127.0.0.1',8080)\n\n# ----------客户端 ----------\nfrom socket import *\n\nclient=socket(AF_INET,SOCK_STREAM)\nclient.connect(('127.0.0.1',8080))\n\n\nwhile True:\n    msg=input('>>: ').strip()\n    if not msg:continue\n\n    client.send(msg.encode('utf-8'))\n    msg=client.recv(1024)\n    print(msg.decode('utf-8'))\n\n# ----------多个客户端并发 ----------\nfrom threading import Thread\nfrom socket import *\nimport threading\n\ndef client(server_ip,port):\n    c=socket(AF_INET,SOCK_STREAM) #套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了\n    c.connect((server_ip,port))\n\n    count=0\n    while True:\n        c.send(('%s say hello %s' %(threading.current_thread().getName(),count)).encode('utf-8'))\n        msg=c.recv(1024)\n        print(msg.decode('utf-8'))\n        count+=1\nif __name__ == '__main__':\n    for i in range(500):\n        t=Thread(target=client,args=('127.0.0.1',8080))\n        t.start()\n\n```\n\n---\n\n### 猴子补丁\n#### 名字的由来\n - 说法一\n这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。\n - 说法二\n由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。\n\n#### 作用\n在程序运行是，将原本的模块功能替换成另外模块的功能","categories":["Python系列"]},{"title":"Python中（多）线程","url":"/2021/01/10/Python中（多）线程/","content":"\n\n## Python中(多)线程\n\n### threading模块\n_thread模块提供了操作多个线程的底层原语，多个控制线程共享全局数据空间。threading 模块基于该模块提供了更易用的高级多线程 API。\n\n---\n\n### threading.Thread类\n - 创建线程\n\n```python\n# ---------- 方式一 ----------\nfrom threading import Thread\nimport time\n\ndef foo():\n    time.sleep(2)\n    print('foo run')\n\nif __name__ == '__main__':\n    t=Thread(target=foo,args=())\n    t.start()\n    print('主线程')\n\n# 输出\n主线程\nfoo run\n\n# ---------- 方式二 ----------\nfrom threading import Thread\nimport time\n\nclass foo(Thread):\n    def __init__(self):\n        super().__init__()\n  \n    def run(self):\n        time.sleep(2)\n        print('foo run')\n\n\nif __name__ == '__main__':\n    t = foo()\n    t.start()\n    print('主线程')\n\n# 输出\n主线程\nfoo run\n```\n\n---\n\n### 线程本地数据\n#### threading.local\n - 概念\n线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 local （或者一个子类型）的实例并在实例中储存属性\n在不同的线程中，实例的值会不同。\n\n - 示例\n\n```python\nmydata = threading.local()\nmydata.x = 1\n```\n\n---\n\n### 锁对象\n#### 死锁\n - 概念\n是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁。\n\n#### 互斥锁（Lock）\n - 概念\n实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。\n\n - 示例\n\n```python\nfrom threading import Thread,Lock\nimport time\n\nn=100\n\ndef f():\n    global n\n    mutex.acquire()\n    temp = n\n    time.sleep(0.1)\n    n = temp-1\n    mutex.release()\n\nif __name__ == '__main__':\n    mutex = Lock()\n    l=[]\n    for i in range(10):\n        t=Thread(target = f)\n        l.append(t)\n        t.start()\n\n    for t in l:\n        t.join()\n\n    print(n)\n\n# 输出\n90\n```\n\n#### 递归锁（RLock）\n - 概念\n递归锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在互斥锁的锁定/非锁定状态上附加了 \"所属线程\" 和 \"递归等级\" 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。\n\n - 示例\n\n```python\nfrom threading import Thread,RLock\nimport time\n\nmutexB = RLock()\nmutexA = RLock()\n\nclass MyThread(Thread):\n    def run(self):\n        self.f1()\n        self.f2()\n  \n    def f1(self):\n        mutexA.acquire()\n        print('%s 拿到A锁 '%self.name)\n        mutexB.acquire()\n        print('%s 拿到B锁 '%self.name)\n        mutexB.release()\n        mutexA.release()\n  \n    def f2(self):\n        mutexB.acquire()\n        print('%s 拿到B锁 ' % self.name)\n        time.sleep(1)\n        mutexA.acquire()\n        print('%s 拿到B锁 ' % self.name)\n        mutexA.release()\n        mutexB.release()\n  \nif __name__ == '__main__':\n    for i in range(10):\n        t = MyThread()\n        t.start()\n\n# 输出\nThread-1 拿到A锁 \nThread-1 拿到B锁 \nThread-1 拿到B锁 \nThread-2 拿到A锁 \n```\n\n---\n\n### Join & Daemon\n#### Join(timeout)\n - 概念\n等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 join() 的线程终结。\n\n#### 守护线程（Daemon）\n - 概念\n一个表示这个线程守护线程的布尔值。一定要在调用 start() 前设置好，不然会抛出 RuntimeError 。\n初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 daemon = False。\n当没有存活的非守护线程时，整个Python程序才会退出。\n\n---\n\n### 条件对象\n#### 条件（Condition）\n - 概念\n使线程等待，只有满足某条件时，才释放n个线程。\n条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。\n\n - 示例\n\n```python\nimport threading\n\ndef run(n):\n    con.acquire()\n    con.wait()\n    print(\"run the thread: %s\" % n)\n    con.release()\n\nif __name__ == '__main__':\n\n    con = threading.Condition()\n    for i in range(10):\n        t = threading.Thread(target=run, args=(i,))\n        t.start()\n\n    while True:\n        inp = input('>>>')\n        if inp == 'q':\n            break\n        con.acquire()\n        con.notify(int(inp))\n        con.release()\n        print('****')\n```\n\n---\n\n### 信号量对象\n#### 信号量（Semaphore）\n - 概念\n同进程的一样，Semaphore管理一个内置的计数器，每当调用acquire()时内置计数器-1；调用release()时内置计数器+1；计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()\n\n - 示例\n\n```python\nfrom threading import Semaphore\nimport threading\nimport time\n\ndef func():\n    sm.acquire()\n    print('%s get sm' %threading.current_thread().getName())\n    time.sleep(2)\n    sm.release()\nif __name__ == '__main__':\n    sm=Semaphore(5)\n    for i in range(10):\n        t=threading.Thread(target=func)\n        t.start()\n\n# 输出\nThread-1 get sm\nThread-2 get sm\nThread-3 get sm\nThread-4 get sm\nThread-5 get sm\nThread-6 get sm\nThread-9 get sm\nThread-8 get sm\nThread-7 get sm\nThread-10 get sm\n```\n\n---\n\n### 事件对象\n#### 事件（Event）\n - 概念\n同进程的一样，线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行。\n\n - 示例\n\n```python\nimport threading\nimport time\nimport random\nfrom threading import Thread\nfrom threading import Event\n\ndef conn_mysql():\n    count=1\n    while not event.is_set():\n        if count > 3:\n            raise TimeoutError('链接超时')\n        print('<%s>第%s次尝试链接' % (threading.current_thread().getName(), count))\n        event.wait(0.5)\n        count+=1\n    print('<%s>链接成功' %threading.current_thread().getName())\n\ndef check_mysql():\n    print('\\033[45m[%s]正在检查mysql\\033[0m' % threading.current_thread().getName())\n    time.sleep(random.randint(2,4))\n    event.set()\nif __name__ == '__main__':\n    event=Event()\n    conn1=Thread(target=conn_mysql)\n    conn2=Thread(target=conn_mysql)\n    check=Thread(target=check_mysql)\n\n    conn1.start()\n    conn2.start()\n    check.start()\n\n# 输出\n<Thread-1>第1次尝试链接\n<Thread-2>第1次尝试链接\n<Thread-1>第2次尝试链接\n<Thread-2>第2次尝试链接\n<Thread-1>第3次尝试链接\n<Thread-2>第3次尝试链接\nException in thread Thread-1:\nTraceback (most recent call last):\n  File \"main.py\", line 12, in conn_mysql\n    raise TimeoutError('链接超时')\nTimeoutError: 链接超时\n```\n\n---\n\n### 定时器对象\n#### 定时器（Timer）\n - 概念\n此类表示一个操作应该在等待一定的时间之后运行，相当于一个定时器。 Timer 类是 Thread 类的子类，因此可以像一个自定义线程一样工作。\n\n - 示例\n\n```python\ndef hello():\n    print(\"hello, world\")\n\nt = Timer(30.0, hello)\nt.start()  # 30秒后输出'hello, world'\n```\n\n---\n\n### 栅栏对象\n#### 栅栏（Barrier）\n - 概念\n栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 wait() 方法后将阻塞，直到所有线程都调用了 wait() 方法。此时所有线程将被同时释放。\n栅栏对象可以被多次使用，但进程的数量不能改变。\n\n - 示例\n\n```python\nimport threading, logging\nlogging.basicConfig(level=logging.INFO, format=\"%(threadName)s %(message)s\")\n \ndef work(barrier:threading.Barrier):\n    logging.info(\"n_waiting = {}\".format(barrier.n_waiting))\n    bid = barrier.wait()\n    logging.info(\"after barrier {}\".format(bid)) # 栅栏之后\n \nbarrier = threading.Barrier(3)\n \nfor x in range(1,4): \n    threading.Event().wait(1)\n    threading.Thread(target=work,args=(barrier,),name=\"Barrier-{}\".format(x)).start()\n\n# 输出\nBarrier-1 n_waiting = 0\nBarrier-2 n_waiting = 1\nBarrier-3 n_waiting = 2\nBarrier-3 after barrier 2\nBarrier-2 after barrier 1\nBarrier-1 after barrier 0\n```\n\n\n\n","categories":["Python系列"]},{"title":"Python中（多）进程","url":"/2021/01/10/Python中（多）进程/","content":"\n## Python中(多)进程\n### multiprocessing模块\nmultiprocessing 是一个用于产生进程的包，具有与 threading 模块相似API。 multiprocessing 包同时提供本地和远程并发，使用子进程代替线程，有效避免 GIL锁（Global Interpreter Lock）带来的影响。因此，multiprocessing 模块允许程序员充分利用机器上的多核。可运行于 Unix 和 Windows 。\n\n---\n\n### multiprocessing.Process类\n - 创建进程\n在 multiprocessing 中，通过创建一个 Process 对象然后调用它的 start() 方法来生成进程。\n\n```python\n# ---------- 创建进程 ----------\nfrom multiprocessing import Process\n\ndef f(name):\n    print('hello', name)\n\nif __name__ == '__main__':\n    p = Process(target=f, args=('bob',))\n    p.start()\n    p.join()\n\n# ---------- 显示所涉及的各个进程ID ----------\nfrom multiprocessing import Process\nimport os\n\ndef info(title):\n    print(title)\n    print('module name:', __name__)\n    print('parent process:', os.getppid())\n    print('process id:', os.getpid())\n\ndef f(name):\n    info('function f')\n    print('hello', name)\n\nif __name__ == '__main__':\n    info('main line')\n    p = Process(target=f, args=('bob',))\n    p.start()\n    p.join()\n```\n\n---\n\n### multiprocessing启动方式\n\n#### spawn\n父进程启动一个新的Python解释器进程。子进程只会继承那些运行进程对象的 run() 方法所需的资源。特别是父进程中非必须的文件描述符和句柄不会被继承。相对于使用 fork 或者 forkserver，使用这个方法启动进程相当慢。\n可在Unix和Windows上使用。 Windows上的默认设置。3.8版本后，macOS上的默认方式。\n\n#### fork\n父进程使用 os.fork() 来产生 Python 解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。\n只存在于Unix。Unix中的默认值。\n\n#### forkserver\n程序启动并选择* forkserver * 启动方法时，将启动服务器进程。从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。分叉服务器进程是单线程的，因此使用 os.fork() 是安全的。没有不必要的资源被继承。\n可在Unix平台上使用，支持通过Unix管道传递文件描述符。\n\n#### 示例\n\n```python\n# ---------- 启动示例 ----------\nimport multiprocessing as mp\n\ndef foo(q):\n    q.put('hello')\n\nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    q = mp.Queue()\n    p = mp.Process(target=foo, args=(q,))\n    p.start()\n    print(q.get())\n    p.join()\n\n# ---------- 获取上下文----------\n# 在程序中 set_start_method() 不应该被多次调用。\n# 可以使用 get_context() 来获取上下文对象。\n# 上下文对象与 multiprocessing 模块具有相同的API，并允许在同一程序中使用多种启动方法。\n# ------------------------------\n\nimport multiprocessing as mp\n\ndef foo(q):\n    q.put('hello')\n\nif __name__ == '__main__':\n    ctx = mp.get_context('spawn')\n    q = ctx.Queue()\n    p = ctx.Process(target=foo, args=(q,))\n    p.start()\n    print(q.get())\n    p.join()\n```\n\n---\n\n### multiprocessing 进程间通信\n####  队列（Queue）\n - 概念\nQueue 类是一个近似 queue.Queue 的克隆。`队列是线程和进程安全的。`\n\n - 示例\n\n```python\nfrom multiprocessing import Process, Queue\n\ndef f(q):\n    q.put([42, None, 'hello'])\n\nif __name__ == '__main__':\n    q = Queue()\n    p = Process(target=f, args=(q,))\n    p.start()\n    print(q.get()) # prints \"[42, None, 'hello']\"\n    p.join()\n```\n\n####  管道（Pipe）\n - 概念\nPipe() 函数返回一个由管道连接的连接对象，默认情况下是双工（双向）。如果两个进程/线程同时尝试读取或写入管道的同一端，则管道中的数据可能会损坏。\n\n - 示例\n\n```python\nfrom multiprocessing import Process, Pipe\n\ndef f(conn):\n    conn.send([42, None, 'hello'])\n    conn.close()\n\nif __name__ == '__main__':\n    parent_conn, child_conn = Pipe()\n    p = Process(target=f, args=(child_conn,))\n    p.start()\n    print(parent_conn.recv()) # prints \"[42, None, 'hello']\"\n    p.join()\n```\n\n---\n\n### multiprocessing 进程间同步\n#### 死锁\n - 概念\n是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程\n\n#### 互斥锁（Lock）\n - 概念\n实现互斥锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。互斥锁有可能造成死锁问题。\n\n - 示例\n\n```python\nfrom multiprocessing import Process, Lock\n\ndef f(l, i):\n    l.acquire()\n    try:\n        print('hello world', i)\n    finally:\n        l.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    for num in range(10):\n        Process(target=f, args=(lock, num)).start()\n\n# 输出\nhello world 2\nhello world 3\nhello world 1\nhello world 4\nhello world 0\nhello world 6\nhello world 5\nhello world 7\nhello world 8\nhello world 9\n```\n\n#### 递归锁（RLock）\n - 概念\n递归锁必须由持有线程、进程亲自释放。如果某个进程或者线程拿到了递归锁，这个进程或者线程可以再次拿到这个锁而不需要等待。但是这个进程或者线程的拿锁操作和释放锁操作的次数必须相同。递归锁避免了互斥锁有可能会造成死锁的情况。\n\n---\n\n### 进程间状态共享\n#### 共享内存（Value/Array）\n - 概念\n可以使用 Value 或 Array 将数据存储在共享内存映射中。\n为了更灵活地使用共享内存，可以使用 multiprocessing.sharedctypes 模块，该模块支持创建从共享内存分配的任意ctypes对象。\n\n - 示例\n\n```python\nfrom multiprocessing import Process, Value, Array\n\ndef f(n, a):\n    n.value = 3.1415927\n    for i in range(len(a)):\n        a[i] = -a[i]\n\nif __name__ == '__main__':\n    num = Value('d', 0.0)\n    arr = Array('i', range(10))\n\n    p = Process(target=f, args=(num, arr))\n    p.start()\n    p.join()\n\n    print(num.value)\n    print(arr[:])\n\n# 输出\n3.1415927\n[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n```\n\n#### 服务进程（Manager）\n - 概念\n由 Manager() 返回的管理器对象控制一个服务进程，该进程保存Python对象并允许其他进程使用代理操作它们。\nManager() 返回的管理器支持类型： list 、 dict 、 Namespace 、 Lock 、 RLock 、 Semaphore 、 BoundedSemaphore 、 Condition 、 Event 、 Barrier 、 Queue 、 Value 和 Array 。\n使用服务进程的管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。\n\n - 示例\n\n```python\nfrom multiprocessing import Process, Manager\n\ndef f(d, l):\n    d[1] = '1'\n    d['2'] = 2\n    d[0.25] = None\n    l.reverse()\n\nif __name__ == '__main__':\n    with Manager() as manager:\n        d = manager.dict()\n        l = manager.list(range(10))\n\n        p = Process(target=f, args=(d, l))\n        p.start()\n        p.join()\n\n        print(d)\n        print(l)\n\n# 输出\n{0.25: None, 1: '1', '2': 2}\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```\n\n---\n\n### 使用工作进程\n#### 进程池（Pool）\n - 概念\nPool 类表示一个工作进程池。它具有允许以几种不同方式将任务分配到工作进程的方法。\n`进程池的方法只能由创建它的进程使用`\n\n - 示例\n\n```python\nfrom multiprocessing import Pool, TimeoutError\nimport time\nimport os\n\ndef f(x):\n    return x*x\n\nif __name__ == '__main__':\n    # start 4 worker processes\n    with Pool(processes=4) as pool:\n\n        # print \"[0, 1, 4,..., 81]\"\n        print(pool.map(f, range(10)))\n\n        # print same numbers in arbitrary order\n        for i in pool.imap_unordered(f, range(10)):\n            print(i)\n\n        # evaluate \"f(20)\" asynchronously\n        res = pool.apply_async(f, (20,)) # runs in *only* one process\n        print(res.get(timeout=1)) # prints \"400\"\n\n        # evaluate \"os.getpid()\" asynchronously\n        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n        print(res.get(timeout=1)) # prints the PID of that process\n\n        # launching multiple evaluations asynchronously *may* use more processes\n        multiple_results = [pool.apply_async(os.getpid, ()) for i in range(4)]\n        print([res.get(timeout=1) for res in multiple_results])\n\n        # make a single worker sleep for 10 secs\n        res = pool.apply_async(time.sleep, (10,))\n        try:\n            print(res.get(timeout=1))\n        except TimeoutError:\n            print(\"We lacked patience and got a multiprocessing.TimeoutError\")\n\n        print(\"For the moment, the pool remains available for more work\")\n\n    # exiting the 'with'-block has stopped the pool\n    print(\"Now the pool is closed and no longer available\")\n```\n\n---\n\n### Join & Daemon\n#### Join(timeout)\n - 概念\n使用join会将该方法阻塞，直到timeout时间或调用join的进程终止。一个进程可以被join多次，且进程无法join自身，join自身会导致死锁问题。\n\n - 示例\n\n```python\nfrom multiprocessing import Process\nimport os\nimport time\n\ndef now():\n    return str(time.time())\n\n\ndef f():\n    print('Run child process ' + str(os.getpid()) + ' at ' + str(now()))\n    time.sleep(3)\n    print('Stop child process ' + str(os.getpid()) + ' at ' + str(now()))\n\nif __name__ == '__main__':\n    print ('Parent process ' + str(os.getpid()))\n    p1 = Process(target=f, args=())\n    print('Process start at '+ str(now()))\n    p1.start()\n    p1.join()\n    print('Process end at '+ str(now()))\n\n# 输出\n# 如果没p1.join()，则主进程会在子进程结束之前执行Process end 打印\nParent process 2\nProcess start at 1581322409.9711816\nRun child process 3 at 1581322409.975377\nStop child process 3 at 1581322412.9764113\nProcess end at 1581322412.9770644\n```\n\n#### Daemon\n - 概念\n进程的守护标志，一个布尔值。这必须在 start() 被调用之前设置。当进程退出时，它会尝试终止其所有守护进程子进程。\n不允许守护进程创建子进程。否则，守护进程会在子进程退出时终止其子进程。\n\n - 示例\n\n```python\nimport multiprocessing\nimport time\n\ndef f():\n    print(\"work start at {}\".format(time.time()));\n    time.sleep(3)\n    print(\"work end at {}\".format(time.time()));\n\nif __name__ == \"__main__\":\n    p = multiprocessing.Process(target = f, args = ())\n    p.daemon = True  # 设置是否为守护进程\n    p.start()\n    print(\"Process end\")\n\n# 输出\n# 因为守护进程随主进程的结束而结束，所以如果加了p.daemon = True，则只会输出 Process end\nProcess end\nwork start at 1581323384.468953  # 如果不加p.daemon = True，则输出该行\nwork end at 1581323387.4720087  # 如果不加p.daemon = True，则输出该行\n```\n\n---\n\n### 信号量\n#### 信号量（Semaphore）\n - 概念\n该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 release() 方法的调用次数减去 acquire() 的调用次数再加上一个初始值。如果需要， acquire() 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 value 的值时，默认为1。\n\n - 示例\n\n```python\nimport multiprocessing\nimport time\n\ndef f(sem, num):\n    sem.acquire()\n    print('{} get semaphores'.format(num))\n    time.sleep(3)\n    sem.release()\n\nif __name__ == '__main__':\n    sem = multiprocessing.Semaphore(5)\n    for i in range(10):\n        t = multiprocessing.Process(target=f, args=(sem, i,))\n        t.start()\n\n# 输出\n1 get semaphores\n2 get semaphores\n3 get semaphores\n4 get semaphores\n5 get semaphores\n```\n\n---\n\n### 事件\n#### 事件（Event）\n - 概念\n实现事件对象的类。事件对象管理一个内部标志，调用 set() 方法可将其设置为true。调用 clear() 方法可将其设置为false。调用 wait() 方法将进入阻塞直到标志为true。这个标志初始时为false。\n\n - 示例\n\n```python\n#!/usr/bin/python\nfrom multiprocessing import Process\nfrom multiprocessing import Event\nimport time, random\n\ndef traffic_light(e):\n    while True:\n        if e.is_set():\n            time.sleep(1)\n            print('红灯亮')\n            e.clear()\n        else:\n            time.sleep(1)\n            print('绿灯亮')\n            e.set()\n\ndef car(i, e):\n    e.wait()\n    print('{}:车通过...'.format(i))\n\nif __name__ == '__main__':\n    e = Event()\n    traffic = Process(target=traffic_light, args=(e,))\n    traffic.daemon = True\n    traffic.start()\n    for i in range(30):\n        if i % 6:\n            time.sleep(random.random())\n        car_obj = Process(target=car, args=(i, e))\n        car_obj.start()\n\n# 输出\n0:车通过...\n1:车通过...\n2:车通过...\n4:车通过...\n3:车通过...\n5:车通过...\n6:车通过...\n7:车通过...\n8:车通过...\n```\n\n---\n\n### CPython中GIL问题\n#### 概念\nGIL全称为全局解释器锁，每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。它并不是python语言的特性，仅仅是由于历史的原因在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。\n\n#### 问题\n多核环境下，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核优势，同时由于线程在多核上交替执行，反而又导致了核心切换时造成的资源消耗，会似的程序的运行更耗时。造成这样现象的原因就是因为CPython解释器中的GIL问题，即同一时刻一个进程只会有一把GIL，当多个线程需要执行任务时就会造成资源不足，进而线程等待GIL锁的释放，导致多核优势不能被利用。\n\n#### 影响\n - 计算密集型\nCPython的GIL对于计算密集型的程序会有较大影响，因为同一时刻一个线程只会执行一个任务，所以对于计算密集型程序而言只能串行等待资源调用。\n - I/O密集型\n对于I/O密集型程序而言，其瓶颈在于I/O，所以CPython的GIL对其影响并没有想象中的大。\n\n#### 解决方案\n - 多进程\nPython中的Multiprocessing库可以帮助实现多进程，从而在多核系统中利用多核资源。\n - Ctypes\nCPython解释器的优势就是其可以调用C语言库来帮助实现程序对于多核系统的充分利用。\n - 协程\n协程又称微线程，是一种用户态的轻量级线程。python3.4之后内置了asyncio标准库，实现了内置协程，同时也可以通过第三方库类似Greenlet、Gevent实现协程。、\n\n\n","categories":["Python系列"]},{"title":"Python进程线程初识","url":"/2021/01/10/Python进程线程初识/","content":"\n## 进程&线程初识\n\n### 进程（Process）\n#### 概念\n进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。\n在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。\n\n#### 组成\n进程的组成，通常包括：\n - 程序\n - 数据\n - 进程控制块\n\n进程有其自己的地址空间，通常包括：\n - 文本区域：存储处理器执行的代码\n - 数据区域：存储变量和进程执行期间使用的动态分配的内存\n - 堆栈：存储着活动过程调用的指令和本地变量。\n\n#### 意义\n进程是对正在运行程序过程的一种抽象，进程的意义在于方便有效的管理、调度计算机的程序。\n\n#### 特征\n - 动态性：进程是程序的执行过程，其产生和销毁都是动态产生的。\n - 并发性：进程间完全独立，多个进程可以并发执行各自任务。\n - 独立性：进程可以独立运行，其是独立运行的基本单位，也是系统分配资源和调度的独立单位。\n - 异步性：进程间相互制约，使其执行具有间断性，即进程按各自独立的、不可预知的速度向前推进。\n\n#### 进程调度\n - 概念\n进程调度是计算机的基本功能之一，其主要作用是将就绪队列中的程序进行调度，管理程序状态，使得多个程序都可以正常运行。\n进程调度流程大致如下图：\n![](/images/post_imgs/process_schedule.jpg)\n\n - 常见调度算法\n  - 先来先服务调度算法（FCFS）\n是最简单的调度算法，按先后顺序进行调度。\nFCFS算法比较有利于长作业，而不利于短作业，适合于CPU密集型作业，而不适合I/O密集型作业。\n  - 短作业(进程)优先调度算法 (SPN)\n是指对短作业(进程)优先调度的算法。\n其调度算法是从就绪队列中依次选出预估运行时间最短的进程进行处理。\n  - 优先权调度算法的类型\n是指对高权限的进程优先调度的算法。\n其调度算法是从就绪队列中依次选出预设权限最高的进程进行处理。\n  - 高响应比优先调度算法 (HRRN)\n高响应比优先调度算法相比短作业优先调度算法对长作业相对友好，其为每个作业分配了动态优先权，使得作业的优先权随等待时间的增加而增加，进而可以使长作业有机会得到优先处理。\n其中，响应比 =（进程执行时间 + 进程等待时间）/ 进程执行时间。\n  - 时间片轮转法 (RR)\n系统将所有就绪任务按照先来先服务的原则循序排列，每次调度则分配给任务一个固定的时间片，以此类推直至所有任务调度完成。\n  - 反馈调度算法 (Feedback)\n设置多个就绪队列，多个就绪队列的优先级逐级降低，且优先级越高的队列执行时间片越小。就绪任务以先来先服务原则进入队列，首先将其放置优先级最高队列队尾，如果在该队列时间片时间内没有任务没有执行完成，便将其转入下一级队列队尾，以此类推。仅当上级队列空闲时才会执行下级队列。\n\n![](/images/post_imgs/Feedback.jpg)\n\n#### 创建/终止进程\n - 创建进程\n新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。\n通常创建进程的方式包括：系统初始化进程、创建子进程、用户交互创建进程、任务创建进程\n\n - 终止进程\n终止进程包括主动终止和被动终止，大概包括以下几种方式：正常退出、异常退出、主动杀死进程\n\n\n---\n\n### 线程\n#### 概念\n线程是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。\n但同一进程中的多个线程有各自的调用栈（call stack）、寄存器环境（register context）、线程本地存储（thread-local storage）。\n\n#### 基本状态\n - 产生（spawn）\n - 中断（block）\n - 非中断（unblock）\n - 结束（finish）\n\n#### 要素\n - 线程内核对象\n - 线程环境块(TEB)\n - 用户模式栈\n - 内核模式栈\n - DLL线程连接和线程分离通知\n\n#### 特点\n - 轻型实体：线程中拥有的资源可以最小化保证程序的独立运行\n - 独立调度和分派的基本单位\n - 共享进程资源\n - 可并发运行\n\n#### 线程分类 \n\n - 内核线程\n  - 内核线程可以独立运行任务，可以利用其处理异步事件。内核线程使用的资源是内核栈和上下文切换时保存寄存器的空间。\n  - 支持多线程的内核叫做多线程内核(Multi-Threads kernel )。\n  - 内核线程只运行在内核态，不受用户态上下文的拖累。\n  - 处理器竞争：可以在全系统范围内竞争处理器资源；\n  - 使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间\n  - 调度：调度的开销可能和进程自身差不多昂贵\n  - 同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。\n\n - 轻量级线程\n  - 轻量级线程(LWP)是一种由内核支持的用户线程。它是基于内核线程的高级抽象，因此只有先支持内核线程，才能有LWP。\n  - 特点：轻量级线程只有一个最小的执行上下文和调度程序所需的统计信息。\n  - 处理器竞争：轻量级线程是由内核支持，所以可以在全系统范围竞争处理器资源。\n  - 使用资源：与父进程共享进程地址空间\n  - 局限：轻量级线程的创建、同步、销毁等操作都需要系统调用，即用户态与内核态切换，所以系统调用代价较高；每个轻量级线程都需要一个内核线程支持，所以消耗内核资源较多，不宜大量创建。\n\n - 用户线程\n  - 用户线程是基于用户空间建立的线程，其创建、同步、销毁等操作都基于用户空间，不需要消耗内核资源，所以用户线程消耗资源低，线程高效。\n  - 处理器竞争：用户线程基于用户空间创建，其对于内核是透明的，所以用户线程所属的进程参与竞争处理器资源，所属进程下的所有线程竞争进程的资源。\n  - 使用资源：与所属进程共享进程地址空间和系统资源。\n  - 调度：用户线程在其所属进程内参数调度\n\n\n---\n\n### 并发&并行\n\n - Erlang 之父 Joe Armstrong 用于解释并发与并行的图示\n![](/images/post_imgs/concurrent.jpg)\n\n\n#### 并发计算\n - 概念\n并发（Concurrent），是一种程序计算的形式，在系统中，至少有两个以上的计算在同时运作，计算结果可能同时发生。\n\n\n#### 并行计算\n - 概念\n并行计算（Parallel）一般是指许多指令得以同时进行的计算模式。在同时进行的前提下，可以将计算的过程分解成小部分，之后以并发方式来加以解决。所谓并发方式可以简单理解为多个任务交替运行，但是同一时刻只会有一个任务被执行。\n\n---\n\n### 同步&异步\n#### 同步\n - 概念\n同步（Synchronous）是指计算机在处理多个任务时，处理过程顺序执行，是线性执行方式。前一个任务执行完成并返回结果后才会执行下一个任务，以此类推。\n\n#### 异步\n - 概念\n异步（Asynchronous）是指计算机处理多个任务时，无需遵循顺序执行的方式，不需要等待任务返回结果即可开始其他任务，当任务执行完成时，使用回调的方式返回结果。\n\n---\n\n### 阻塞&非阻塞\n#### 阻塞\n - 概念\n进程/线程被操作系统挂起，需要等待当前任务执行完成后才可以执行其他任务。\n\n#### 非阻塞\n - 概念\n进程/线程被操作系统不被挂起，可以执行其他任务。\n\n\n\n","categories":["Python系列"]},{"title":"PythonSocketServer实现多并发","url":"/2021/01/10/PythonSocketServer实现多并发/","content":"\n## Socketserver\n### 概念\nsocketserver模块简化了编写网络服务器的任务。\n\n---\n\n### Socketserver实现服务端与多个客户端交互\n\n```python\n# ---------- 服务端 ----------\nimport socketserver\n\nclass MyServer(socketserver.BaseRequestHandler):\n    def handle(self):\n        while True:\n            recv_msg = self.request.recv(1024).decode('utf-8')\n            if recv_msg == 'q':\n                self.request.send(b'q') # 输入'q'退出\n                break\n            else:\n                print(recv_msg)\n            info = input('服务端 >>>').strip()\n            if info:\n                self.request.send(info.encode('utf-8'))\n\nif __name__ == '__main__':\n    server = socketserver.ThreadingTCPServer(('localhost', 8889), MyServer)\n    server.allow_reuse_address = True\n    server.serve_forever()\n\n\n# ---------- 客户端 ----------\nimport socket\n\nsk = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\nsk.connect(('localhost', 8889))\nwhile True:\n    info = input('客户端 >>>').strip()\n    if info == '':\n        continue\n    elif info == 'q':\n        sk.send(info.encode('utf-8')) # 输入'q'退出\n        break\n    else:\n        sk.send(info.encode('utf-8'))\n        recv_msg = sk.recv(1024).decode('utf-8')\n        print(recv_msg)\nsk.close()\n```\n\n","categories":["Python系列"]},{"title":"Python黏包问题","url":"/2021/01/10/Python黏包问题/","content":"\n## 黏包问题\n### 概念\n黏包问题只存在于基于TCP协议的Socket通信过程中，其是指发送者将多个数据包一起发送给接收者，造成接收者不能区分每个数据包的分界。\n\n---\n\n### 原因\n#### 发送者因素\n基于TCP协议进行通信时，TCP协议默认会使用Nagle算法。Nagle算法是以减少数据包发送量来增进TCP/IP网络的性能。其工作方式是合并一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。\n所以，基于TCP协议的Nagle算法，就引发了发送者所导致的黏包现象。\n\n#### 接收者因素\n接收者受到通信数据后，类似上面所说的Nagle算法，接收者也会首先将数据保存至缓存中，由应用层程序主动从缓存中获取数据进行读取。这样就会造成如果接收数据的速度大于读取数据的速度，数据会被暂存至缓存，也就是多个数据包的分界不能区分，造成黏包问题。\n\n---\n\n### 处理办法\n#### 发送者处理\n由于发送者造成的黏包问题主要是因为Nagle算法所导致，所以我们解决的方式也就是将Nagle算法禁用，进而解决由于发送者所造成的的黏包问题。使用TCP_NODELAY选项来关闭Nagle算法。\n\n#### 应用程序处理\n由于接收端没有可以处理黏包问题的方法，我们只能从应用程序进行逻辑上的处理。\n\n```python\n# ---------- 服务端 ----------\n# 1、发送报头长度\n# 2、发送编码后的报头内容\n# 3、发送消息体\n# ------------------------------\nimport socket, struct, json\nimport subprocess\n\nsk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # 重复利用端口\nsk.bind(('127.0.0.1', 8080))\nsk.listen(5)\n\nwhile True:\n    conn, addr = sk.accept()\n    while True:\n        cmd = conn.recv(1024)\n        if not cmd: \n            break\n        print('cmd: %s' % cmd)\n        res = subprocess.Popen(cmd.decode('utf-8'),\n                               shell=True,\n                               stdin=subprocess.PIPE,\n                               stdout=subprocess.PIPE,\n                               stderr=subprocess.PIPE)\n        err = res.stderr.read()\n        print(err)\n        if err:\n            back_msg = err\n        else:\n            back_msg = res.stdout.read()\n\n        headers={'data_size':len(back_msg)}  # 使用dict整理报头\n        head_json=json.dumps(headers)  # 将报头序列化\n        head_json_bytes=bytes(head_json,encoding='utf-8')  # 编码序列化报头\n\n        conn.send(struct.pack('i', len(head_json_bytes)))  # 发送报头长度\n        conn.send(head_json_bytes)  # 发送编码后的报头内容\n        conn.sendall(back_msg)  # 发送消息体\n    conn.close()\n\n# ---------- 客户端 ----------\n# 1、接收报头长度\n# 2、根据报头长度接收报头内容→解码→反序列化\n# 3、根据报头内容获取消息体\n# ------------------------------\n\nfrom socket import *\nimport struct, json\n\nip_port=('127.0.0.1',8080)\nclient=socket(AF_INET,SOCK_STREAM)\nclient.connect(ip_port)\n\nwhile True:\n    cmd=input('>>: ')\n    if not cmd:continue\n    client.send(bytes(cmd,encoding='utf-8'))\n\n    head=client.recv(4)\n    head_json_len=struct.unpack('i',head)[0]\n    head_json=json.loads(client.recv(head_json_len).decode('utf-8'))\n    data_len=head_json['data_size']\n\n    recv_size=0\n    recv_data=b''\n    while recv_size < data_len:\n        recv_data+=client.recv(1024)\n        recv_size+=len(recv_data)\n\n    print(recv_data.decode('utf-8'))\n```\n\n","categories":["Python系列"]},{"title":"PythonSocket(套接字)","url":"/2021/01/10/PythonSocket-套接字/","content":"\n## Socket（套接字）\n### 客户端/服务器架构（C/S架构）\n#### 概念\n主从式架构 (也称客户端/服务器架构、C/S架构），是一种网络架构，它把客户端（Client）与服务器（Server）区分开。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、游戏服务器等。\n\n\n### Socket简介\n#### 概念\nSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。为了简化计算机程序与TCP/IP协议族的复杂交互协议，封装了更方便的接口以便更快速的让用户组织数据，进行网络传输。\n更形象的来说，套接字实际上是一个通信端点，每个套接字都有一个套接字序号，包括主机的IP地址与一个16位的主机端口号，即：主机IP地址：端口号。\n\n#### Socket种类\n为满足不同情况下的通信需求，通常网络会提供三种Socket以供选择。\n\n - 流式套接字（SOCK-STREAM）\n是一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。\n通常使用TCP协议来实现字节流的传输，以满足需要发送大量的数据或者对数据传输有较高的要求时，可以使用流式套接字。\n\n - 数据报套接字（SOCK-DGRAM）\n是一种无连接、不可靠的双向数据传输服务。\n数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。\n通常使用UDP协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。\n\n - 原始套接字（SOCK-RAW）\n该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。 \n\n#### 伯克利套接字\n - 概念\n\n伯克利套接字，又称为BSD 套接字(BSD sockets)是一种应用程序接口（API），用于网络套接字与Unix域套接字，包括了一个用C语言写成的应用程序开发库，主要用于实现进程间通讯，在计算机网络通讯方面被广泛使用。\n\n伯克利套接字应用程序接口形成了事实上的网络套接字的标准精髓。 大多数其他的编程语言使用与这套用C语言写成的应用程序接口类似的接口。 这套应用程序接口也被用于Unix域套接字（Unix domain sockets），后者可以在单机上为进程间通讯（IPC）的接口。\n\n - 使用伯克利套接字的系统\n  - Windows Sockets (Winsock) ，和Berkeley Sockets很相似，最初是为了便于移植Unix程序。\n  - Java Sockets\n  - Python sockets\n  - Perl sockets\n\n\n### Python语言下套接字（Socket）简单使用示例\n#### 基于TCP协议的Socket\n可靠的、面向连接的双向数据传输。\n\n - 单服务端、单客户端示例\n\n```python\n# ---------- 服务端 ----------\nimport socket\n\nsk = socket.socket()\nsk.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)  # 此处作用解决Address already in use的情况，可以加入socket配置重用ip和端口\nsk.bind(('127.0.0.1', 8088))\nsk.listen()\nconn, addr = sk.accept()\nwhile True:\n    res = conn.recv(1024).decode('utf-8')\n    if res == 'bye':\n        break\n    else:\n        print(res)\n    info = input('请输入：\\n>>>').encode('utf-8')\n    conn.send(info)\nconn.close()\nsk.close()\n\n# ---------- 客户端 ----------\nimport socket\n\nsk= socket.socket()\nsk.connect(('127.0.0.1', 8088))\nwhile True:\n    info = input('请输入：\\n>>>').encode('utf-8')\n    sk.send(info)\n    res = sk.recv(1024).decode('utf-8')\n    if res == 'bye':\n        break\n    else:\n        print(res)\nsk.close()\n```\n\n  - 单服务端、多客户端示例\n\n```python\n# ---------- 服务端 ----------\nimport socket\n\nsk = socket.socket()\nsk.bind(('127.0.0.1', 8088))\n# listen([backlog])中的[backlog]参数代表服务端允许多少客户端连接到服务端，即阻塞队列长度，所以一共能与服务器连接的客户端共有backlog+1个\nsk.listen(3)\nwhile True:\n    conn, addr = sk.accept() # sk.accept()放在循环内部是为了每次与同一个客户端交互结束后会重新建立conn连接，以便下一个客户端连入\n    res = conn.recv(1024).decode('utf-8')\n    if res == 'bye':\n        break\n    else:\n        print('收到',res)\n    info = input('请输入>>>').encode('utf-8')\n    conn.send(info)\n    conn.close() # 同上面sk.accept()的作用\nsk.close()\n\n# ---------- 客户端 ----------\nimport socket\n\nsk = socket.socket()\nsk.connect(('127.0.0.1', 8088))\nwhile True:\n    info = input('请输入>>>').encode('utf-8')\n    if info == 'bye':\n        break\n    else:\n        sk.send(info)\n    res = sk.recv(1024).decode('utf-8')\n    print(res)\nsk.close()\n```\n\n#### 基于UDP协议的Socket\n无连接、不可靠的双向数据传输\n\n - 单服务端、单客户端示例\n\n```python\n# ---------- 服务端 ----------\nimport socket\nip_port=('127.0.0.1',9000)\nBUFSIZE=1024\nudp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nudp_server_client.bind(ip_port)\nwhile True:\n    msg,addr=udp_server_client.recvfrom(BUFSIZE)\n    print(msg,addr)\n    udp_server_client.sendto(msg.upper(),addr)\n\n# ---------- 客户端 ----------\nimport socket\nip_port=('127.0.0.1',9000)\nBUFSIZE=1024\nudp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\nwhile True:\n    msg=input('>>: ').strip()\n    if not msg:continue\n    udp_server_client.sendto(msg.encode('utf-8'),ip_port)\n    back_msg,addr=udp_server_client.recvfrom(BUFSIZE)\n    print(back_msg.decode('utf-8'),addr)\n```\n\n - 单服务端、多客户端示例\n\n```python\n# ---------- 服务端 ----------\nimport socket\n\nsk = socket.socket(type=socket.SOCK_DGRAM)\nsk.bind(('127.0.0.1', 8888))\nwhile True:\n    msg, addr = sk.recvfrom(1024)\n    print('消息地址：' + addr)\n    if msg.decode('utf-8') == 'bye':\n        break\n    else:\n        print(msg.decode('utf-8'))\n    info = input('>>>').encode('utf-8')\n    sk.sendto(info, addr)\nsk.close()\n\n# ---------- 客户端 ----------\nimport socket\n\nsk = socket.socket(type=socket.SOCK_DGRAM)\nip_port = ('127.0.0.1', 8888)\nwhile True:\n    info = input('client：')\n    info = ('\\033[33m来自client的消息 ：%s\\033[0m' % info).encode('utf-8')\n    sk.sendto(info, ip_port)\n    msg, addr = sk.recvfrom(1024)\n    if msg.decode('utf-8') == 'bye':\n        break\n    else:\n        print(msg.decode('utf-8'))\nsk.close()\n```\n\n","categories":["Python系列"]},{"title":"Python网络编程初识.md","url":"/2021/01/10/Python网络编程初识/","content":"\n## 网络编程初识\n\n### 网络协议\n#### 概念\n网络协议，也称通信协议或传输协议。在电信中是指在任何物理介质中允许两个或多个在传输系统中的终端之间传播信息的系统标准，也是指计算机通信或网络设备的共同语言。通俗来讲，网络协议就是指信息在网络设备以何种语法规范进行传播，协议就是规定了通信时信息的格式以及如何进行处理。\n\n#### OSI模型\n - 概念\n开放式系统互联模型（Open System Interconnection Model，简称为OSI模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。\n\n - 七层模型\n![](/images/post_imgs/7_osi.png)\n\n - 五层模型\n\n![](/images/post_imgs/5_osi.jpg)\n\n---\n\n### TCP/IP协议\n#### 概念\n互联网协议套件（缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（TCP/IP Protocol Stack）。\nTCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。\n\n#### IP协议\n - 概念\n网际协议（IP,也称互联网协议）是用于分组交换数据网络的一种协议。\nIP是在TCP/IP协议族中网络层的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为IPv4，目前仍然是广泛使用的互联网协议，已有 30 多年历史。IPv4 地址的长度为 32 位，采用十进制，如 192.1.1.1，最多有 4,294,967,296 个 IPv4 地址可用。尽管世界各地正在积极部署IPv6，IPv6 相比 IPv4 最显著的变化在于地址长度增长到了 128 位，可用的地址数量大为增加，理论上有 340,282,366,920,938,463,463,374,607,431,768,211,456 个，即 340 万亿兆，通常采用十六进制表示，分为8组，每4个数为一组，以冒号分隔。\n\n - IPv4地址耗尽\n2019-11-25 UTC+1 15:35 时，一封来自欧洲 RIPE NCC 的邮件中得到确认：全球的IPv4地址已经彻底耗尽。\n\n![](/images/post_imgs/ipv4_email.jpg)\n\n#### TCP协议\n - 概念\n传输控制协议（TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能。用户数据报协议（UDP）是同一层内另一个重要的传输协议。\n在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。\n\n - 基本原理\n应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来透过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认信息（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失并进行重传。TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和。\n\n - TCP状态图\n\n![](/images/post_imgs/TCP_status.png)\n\n---\n\n### 网络编程\n#### 概念\n网络编程最主要的工作就是在发送端把信息通过规定好的协议进行组装包，在接收端按照规定好的协议把包进行解析，从而提取出对应的信息，达到通信的目的。换句话说，网络把不同的网络设备互联，让数据信息可以通过网络进行交换，对于我们而言就是计算机与计算机之间的通信交互，所以网络编程就是利用程序实现网络设备（如计算机）之间的通信。\n\n\n\n","categories":["Python系列"]},{"title":"Python异常处理","url":"/2020/11/22/Python异常处理/","content":"\n## 异常处理\n### 介绍\n#### 语法错误\n语法错误又称解析错误，语法错误是在语法层面出现的代码错误，python解释器可以在代码运行之前对语法错误进行检查，并输出出现语法错误的具体位置和错误原因。\n\n#### 异常\n - 概念\n即使在语法上是正确的，但在尝试执行时，它仍可能会引发错误。在执行时检测到的错误被称为异常，异常不一定会导致严重后果，我们可以利用异常处理来解决异常。\n\n - 基本语法\n\n```python\ntry:\n    pass\nexcept Exception as e:\n    pass\nfinally:\n    pass\n```\n\n - 示例\n```python\n# 定义除法的函数\ndef divide(x, y):\n    try: \n        result = x / y\n    except ZeroDivisionError:  # 如果发生ZeroDivisionError异常，则进行下面的处理\n        print(\"division by zero!\")\n    else:  # 如果程序正常执行，则输出除法结果\n        print(\"result is\", result)\n    finally:  # 定义清理操作，程序不论是否触发异常，一定会执行finally，通常进行清理操作\n        print(\"executing finally clause\")\n\ndivide(1,0)  # 函数调用\n\n# 输出\ndivision by zero!\nexecuting finally clause\n```\n\n---\n\n### 异常种类\n#### 常见异常\n|异常名称|描述|\n|---|---|\n|BaseException|所有异常的基类|\n|SystemExit|解释器请求退出|\n|KeyboardInterrupt|用户中断执行(通常是输入^C)|\n|Exception|常规错误的基类|\n|StopIteration|迭代器没有更多的值|\n|GeneratorExit|生成器(generator)发生异常来通知退出|\n|StandardError|所有的内建标准异常的基类|\n|ArithmeticError|所有数值计算错误的基类|\n|FloatingPointError|浮点计算错误|\n|OverflowError|数值运算超出最大限制|\n|ZeroDivisionError|除(或取模)零(所有数据类型)|\n|AssertionError|断言语句失败|\n|AttributeError|对象没有这个属性|\n|EOFError|没有内建输入,到达EOF标记|\n|EnvironmentError|操作系统错误的基类|\n|IOError|输入/输出操作失败|\n|OSError|操作系统错误|\n|WindowsError|系统调用失败|\n|ImportError|导入模块/对象失败|\n|LookupError|无效数据查询的基类|\n|IndexError|序列中没有此索引(index)|\n|KeyError|映射中没有这个键|\n|MemoryError|内存溢出错误(对于Python解释器不是致命的)|\n|NameError|未声明/初始化对象(没有属性)|\n|UnboundLocalError|访问未初始化的本地变量|\n|ReferenceError|弱引用(Weakreference)试图访问已经垃圾回收了的对象|\n|RuntimeError|一般的运行时错误|\n|NotImplementedError|尚未实现的方法|\n|SyntaxError Python|语法错误|\n|IndentationError|缩进错误|\n|TabError|Tab和空格混用|\n|SystemError|一般的解释器系统错误|\n|TypeError|对类型无效的操作|\n|ValueError|传入无效的参数|\n|UnicodeErrorUnicode|相关的错误|\n|UnicodeDecodeErrorUnicode|解码时的错误|\n|UnicodeEncodeErrorUnicode|编码时错误|\n|UnicodeTranslateErrorUnicode|转换时错误|\n|Warning|警告的基类|\n|DeprecationWarning|关于被弃用的特征的警告|\n|FutureWarning|关于构造将来语义会有改变的警告|\n|OverflowWarning|旧的关于自动提升为长整型(long)的警告|\n|PendingDeprecationWarning|关于特性将会被废弃的警告|\n|RuntimeWarning|可疑的运行时行为(runtimebehavior)的警告|\n|SyntaxWarning|可疑的语法的警告|\n|UserWarning|用户代码生成的警告|\n\n#### 异常层次结构\n由下图的异常层级结构我们可以看出，BaseException 所有内置异常的基类。但是官方不建议在实际使用时直接继承使用，而是建议继承Exception类，几乎所有的异常都是Exception的子类。\n\n```python\nBaseException\n +-- SystemExit\n +-- KeyboardInterrupt\n +-- GeneratorExit\n +-- Exception\n      +-- StopIteration\n      +-- StopAsyncIteration\n      +-- ArithmeticError\n      | +-- FloatingPointError\n      | +-- OverflowError\n      | +-- ZeroDivisionError\n      +-- AssertionError\n      +-- AttributeError\n      +-- BufferError\n      +-- EOFError\n      +-- ImportError\n      | +-- ModuleNotFoundError\n      +-- LookupError\n      | +-- IndexError\n      | +-- KeyError\n      +-- MemoryError\n      +-- NameError\n      | +-- UnboundLocalError\n      +-- OSError\n      | +-- BlockingIOError\n      | +-- ChildProcessError\n      | +-- ConnectionError\n      | | +-- BrokenPipeError\n      | | +-- ConnectionAbortedError\n      | | +-- ConnectionRefusedError\n      | | +-- ConnectionResetError\n      | +-- FileExistsError\n      | +-- FileNotFoundError\n      | +-- InterruptedError\n      | +-- IsADirectoryError\n      | +-- NotADirectoryError\n      | +-- PermissionError\n      | +-- ProcessLookupError\n      | +-- TimeoutError\n      +-- ReferenceError\n      +-- RuntimeError\n      | +-- NotImplementedError\n      | +-- RecursionError\n      +-- SyntaxError\n      | +-- IndentationError\n      | +-- TabError\n      +-- SystemError\n      +-- TypeError\n      +-- ValueError\n      | +-- UnicodeError\n      | +-- UnicodeDecodeError\n      | +-- UnicodeEncodeError\n      | +-- UnicodeTranslateError\n      +-- Warning\n           +-- DeprecationWarning\n           +-- PendingDeprecationWarning\n           +-- RuntimeWarning\n           +-- SyntaxWarning\n           +-- UserWarning\n           +-- FutureWarning\n           +-- ImportWarning\n           +-- UnicodeWarning\n           +-- BytesWarning\n           +-- ResourceWarning\n```\n\n---\n\n### 抛出异常\n#### 概念\nraise 语句允许程序员强制发生指定的异常。\n\n#### 示例\n\n```python\ntry:\n    raise NameError('HiThere')  # 主动抛出异常\nexcept NameError:\n    print('An exception flew by!')\n    raise\n```\n\n---\n\n### 自定义异常\n#### 概念\n程序可以通过创建新的异常类来命名它们自己的异常。异常通常应该直接或间接地从 Exception 类派生。自定义异常类通常要保持功能简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。\n\n#### 示例\n\n```python\nclass Error(Exception):  # 继承Exception\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    pass\n\n\nclass TransitionError(Error):  # 继承Exception的子类Error\n    \"\"\"Raised when an operation attempts a state transition that's not\n    allowed.\n\n    Attributes:\n        previous -- state at beginning of transition\n        next -- attempted new state\n        message -- explanation of why the specific transition is not allowed\n    \"\"\"\n\n    def __init__(self, previous, next, message):\n        self.previous = previous\n        self.next = next\n        self.message = message\n```\n\n---\n\n### 断言\n#### 概念\nassert 语句是在程序中插入调试性断言的简便方式\n\n#### 断言的两种形式\n - 简单形式：`assert expression`\n\n```python\n# 简单形式断言，等价于\nif __debug__:\n    if not expression: raise AssertionError\n```\n\n - 扩展形式：`assert expression1, expression2` \n\n```python\n#扩展形式断言，等价于\nif __debug__:\n    if not expression1: raise AssertionError(expression2)\n```\n\n#### 示例\n\n```python\ndef foo():\n    try:\n        assert 1 == 1 # 断言1 == 1\n        print('【NO·1】断言成功时执行')\n        assert 2 == 1\n        print('【NO·2】断言失败时执行') # 断言此处会失败，进而抛出AssertionError异常\n    except Exception: # 捕获AssertionError异常\n        print(\"Catch AssertionError \")\n\nfoo()\n\n# 输出\n\n【NO·1】断言成功时执行\nCatch AssertionError \n```","categories":["Python系列"]},{"title":"Python方法","url":"/2020/07/14/Python方法/","content":"\n\n## 方法\n\n### 属性方法\n#### 概念\n属性方法即使用`@property`装饰器，将函数中的方法转化为\"属性\"，即可以直接使用访问属性的方式，即`属性名.方法`进行方法的调用。\n\n#### 内置函数`property`及`@property`\n\n - `property`函数\nproperty函数的作用是托管类的属性。\n\n```python\nclass C:\n    def __init__(self):\n        self._x = 'This is x'\n\n    def getx(self):\n        return self._x\n\n    def setx(self, value):\n        self._x = value\n\n    def delx(self):\n        del self._x\n\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nc = C()\n\nprint(c.x)  # 调用getter\nc.x = 'value'  # 调用setter\ndel c.x  # 调用deleter\n```\n\n - `@property`装饰器\n\n```python\n# 下面类与上述例子具有相同的效果\nclass C:\n    def __init__(self):\n        self._x = None\n\n    @property\n    def x(self):\n        \"\"\"I'm the 'x' property.\"\"\"\n        return self._x\n\n    @x.setter\n    def x(self, value):\n        self._x = value\n\n    @x.deleter\n    def x(self):\n        del self._x\nc = C()\n\nprint(c.x)  # 调用getter\nc.x = 'value'  # 调用setter\ndel c.x  # 调用deleter\n```\n\n---\n\n### 类方法(@classmethod)\n#### 概念\n类方法的调用可以在类上进行也可以在实例上进行。\n@classmethod装饰器将一个方法封装成类方法。\n\n#### 意义\n - python中的类方法解决了python中不可以通过不同的参数来重载不同的构造函数的问题。即python可以通过类方法实现在实例化前进行某些操作，进而实现类似于多个构造函数的效果。\n - 对于某些需要在类实例化之前做些交互操作提供实现方法。\n - 在继承的时，保证了子类使用可选构造函数构造出来的类是子类的实例而不是父类的实例。\n\n#### 示例\n\n```python\nclass Foo(object):\n\n    def bar_1(self):\n        print ('this is bar_1')\n\n    @classmethod\n    def bar_2(cls):\n        print ('this is bar_2')\n        cls().bar_1()\n\nFoo.bar_2()\n\n# 输出\nthis is bar_2\nthis is bar_1\n```\n\n---\n\n### 静态方法\n#### 概念\n静态方法的调用可以在类上进行也可以在实例上进行。\n\n#### 意义\n静态方法其本质是函数，虽然静态方法定义在类中，但是静态方法并不是类或者类实例的方法，而可以理解为与类没有直接关系的函数，那么静态方法定义在类中的意义是因为可以将一些功能性的工具函数放在类中，方便调用。\n\n#### 示例\n\n```python\nclass Foo(object):\n\n    def bar_1(self):\n        print ('this is bar_1')\n\n    @staticmethod\n    def bar_2():\n        print ('this is bar_2')\n\nFoo.bar_2()\n```\n\n---\n\n### 特殊成员方法(魔术方法)\n#### 常用魔术方法\n`__new__(cls[, …])`：\npython3中在类实例化过程中首先要调用`__new__(cls[, …])`方法，其第一个参数是当前类，其余参数在随后的过程中传递至`__init__`方法。\n\n`__init__(self[, …])`：\n可以理解为python中的构造方法，当一个实例被创建时进行初始化的方法。\n\n`__del__(self)`：\npython中的析构方法，当实例被销毁时调用该方法，可以执行清理相关功能。\n\n`__call__(self[, args…])`：\n允许一个类的实例像函数一样被调用：foo(x, y) 调用 `foo.__ call__(x, y)`\n\n`__len__(self)`：\n调用len() 时的操作\n\n`__repr__(self)`：\n调用repr() 时的操作\n\n`__str__(self)`：\n调用str() 时的操作\n\n`__bytes__(self)`：\n调用bytes() 时的操作\n\n`__hash__(self)`：\n调用hash() 时的操作\n\n`__bool__(self)`：\n调用bool() 时的操作，返回True或False\n\n`__format__(self, format_spec)`：\n调用format() 时的操作\n\n\n#### 属性相关\n`__getattr__(self, name)`：\n当尝试获取不存在的属性时的操作\n\n`__getattribute__(self, name)`：\n当前类的属性被访问时的操作\n\n`__setattr__(self, name, value)`：\n定义当一个属性被设置时的行为\n\n`__delattr__(self, name)`：\n当属性被删除时的操作\n\n`__dir__(self)`：\n调用dir()时的操作\n\n`__get__(self, instance, owner)`：\n当获得描述符的值时的操作\n\n`__set__(self, instance, value)`：\n当修改描述符的值时的操作\n\n`__delete__(self, instance)`：\n当删除描述符的值时的操作\n\n#### 比较操作符\n`__lt__(self, other)`：\n调用小于号时的操作：即x < y 调用 x.lt(y)\n`__le__(self, other)`：\n调用小于等于号时的操作：即x <= y 调用 x.le(y)\n`__eq__(self, other)`：\n调用等于号时的操作：即x == y 调用 x.eq(y)\n`__ne__(self, other)`：\n调用不等于号时的操作：即x != y 调用 x.ne(y)\n`__gt__(self, other)`：\n调用大于号时的操作：即x > y 调用 x.gt(y)\n`__ge__(self, other)`：\n调用大于等于号时的操作：即x >= y 调用 x.ge(y)\n\n#### 算数运算符 & 反运算\n> 反运算：即当左操作数不存在对应方法时，则检查右操作数是否有相对应的反运算符，若有则进行对应运算，若没有则抛出异常\n\n`__radd/add__(self, other)`：\n调用加法时的操作：`+`\n\n`__rsub/sub__(self, other)`：\n调用减法时的操作：`-`\n\n`__rmul/mul__(self, other)`：\n调用乘法时的操作：`*`\n\n`__rtruediv/truediv__(self, other)`：\n调用除法时的操作：`/`\n\n`__rfloordiv/floordiv__(self, other)`：\n调用整除时的操作：`//`\n\n`__rmod/mod__(self, other)`：\n调用取模运算时的操作：`%`\n\n`__rdivmod/divmod__(self, other)`：\n调用 divmod() 时的操作\n\n`__rpow/pow__(self, other[, modulo])`：\n调用 power() 或 `**` 时的操作\n\n`__rlshift/lshift__(self, other)`：\n调用按位左移时的操作：`<<`\n\n`__rrshift/rshift__(self, other)`：\n调用按位右移时的操作：`>>`\n\n`__rand/and__(self, other)`：\n调用按位与时的操作：`&`\n\n`__rxor/xor__(self, other)`：\n调用按位异或时的操作：`^`\n\n`__ror/or__(self, other)`：\n调用按位或时的操作：`|`\n\n#### 增量赋值运算\n上述算数运算符前增加`i`，则转换为对应的增量赋值运算符，对应操作转换为赋值运算\n例如：`__iadd__(self, other)`，则调用赋值加法时的操作，即`+=`\n\n#### 一元操作符\n`__pos__(self)`：\n调用正号时的操作\n\n`__neg__(self)`：\n调用负号时的操作\n\n`__abs__(self)`：\n调用 abs() 时的操作\n\n`__invert__(self)`：\n调用按位求反时的操作\n\n#### 类型转化\n`__complex__(self)`：\n调用 complex() 时的操作\n\n`__int__(self)`：\n调用 int() 时的操作\n\n`__float__(self)`：\n调用 float() 时的操作\n\n`__round__(self[, n])`：\n调用 round() 时的操作\n\n`__index__(self)`：\n调用此方法以实现 operator.index() 以及 Python 需要无损地将数字对象转换为整数对象的场合（例如切片或是内置的 bin(), hex() 和 oct() 函数)。存在此方法表明数字对象属于整数类型。必须返回一个整数。\n\n#### 上下文管理\n`__enter__(self)`：\n当使用 with 语句时，返回值被 with 语句的目标或者 as 后的名字绑定。\n\n`__exit__(self, exc_type, exc_value, traceback)`：\n退出关联到此对象的运行时上下文。通常用于处理异常、清除处理或做一些代码块执行完毕之后的日常工作。\n\n#### 容器类型\n`__len__(self)`：\n调用 len() 时的操作\n\n`__getitem__(self, key)`：\n获取容器中元素时的操作: self[key]\n\n`__setitem__(self, key, value)`：\n设置容器中元素时的操作: self[key] = value\n\n`__delitem__(self, key)`：\n删除容器中元素时的操作: del self[key]\n\n`__iter__(self)`：\n对容器中元素进行迭代时的操作\n\n`__reversed__(self)`：\n被 reversed() 调用时的操作\n\n`__contains__(self, item)`：\n调用 in 时的操作\n\n#### `__slots__`\n - 概念\n`__slots__` 允许我们显式地声明数据成员并禁止创建 `__dict__` 和 `__weakref__` (除非是在 __slots__ 中显式地声明或是在父类中可用。)\n\n - 意义及作用\n - 相比使用 __dict__ 此方式可以显著地节省空间。 \n - 属性查找速度也可得到显著的提升。\n - `__slots__`不可被继承，也不可动态添加属性\n\n - 示例\n\n```python\nclass Foo:\n    __slots__ = ['x', 'y']\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nf = Foo('a', 'b')\nprint(f.x) # 输出 'a'\nprint(f.y) # 输出 'b'\nf.z = 'new' # 抛出 AttributeError 异常\n```\n\n---\n\n### 反射（自省）\n#### 概念\n反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。\n\n#### python中的反射\n通过字符串的形式操作对象相关的属性，python中的一切事物都是对象（都可以使用反射）。\n\n#### 反射的实现\n - hasattr(obj, name)\n返回obj对象是否具有name所描述的属性\n\n - getattr(obj, name)\n从obj对象中获取到name所描述的属性\n\n - setattr(obj, name, value)\n给obj对象设置一个名为name的属性，属性值为value\n\n - delattr(obj, name)\n从obj对象中删除名为name的属性\n\n#### 示例\n\n```python\n#  反射示例中的属性和方法\nclass Foo:\n    static_var = '类的静态变量'\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def bar(self):\n        print('this is bar')\n\nfoo = Foo('a', 'b')\n\n# 用hasattr函数检测是否含有某属性\nprint(hasattr(foo, 'x'))\nprint(hasattr(foo, 'y'))\n\n\n# 用getattr获取属性\nprint(getattr(foo, 'x'))\n\nfunc=getattr(foo, 'y')\n\nfunc() # 输出'a'\n\nprint(getattr(foo, 'm', '不存在'))  # 报错\n\n\n# 用setattr设置属性\nsetattr(foo, 'z', 'c')\nsetattr(foo, 'new_attr', lambda self:self.x + '_new_attr')\nprint(foo.__dict__)\nprint(foo.bar(foo))\n\n# 用delattr删除属性\ndelattr(foo, 'x')\ndelattr(foo, 'y')\ndelattr(foo, 'not_exist_func') # 不存在,报错\n\nprint(foo.__dict__)\n\n# 反射类的方法和属性\nclass Foo(object):\n    static_var = \"类的静态属性\"\n\n    def __init__(self):\n        self.name = '人身苦短'\n\n    def func(self):\n        return '我用python'\n\n    @staticmethod\n    def bar():\n        return 'bar func...'\n\nprint(getattr(Foo, 'static_var'))\nprint(getattr(Foo, 'func'))\nprint(getattr(Foo, 'bar'))\n\n# 反射模块的属性和方法(内置模块也是可以的)\n'''\n程序目录：\n    module_test.py\n    index.py\n\n当前文件：\n    index.py\n'''\nimport module_test as obj\n\nprint(hasattr(obj, 'test'))\n\nprint(getattr(obj, 'test'))\n\n# 反射自身模块中的函数\nimport sys\n\ndef func_1():\n    print('funx_1')\n\ndef funx_2():\n    print('funx_2')\n\nthis_module = sys.modules[__name__]  # 返回自己的模块\n\nprint(hasattr(this_module, 'func_1'))\nprint(getattr(this_module, 'funx_2'))\n```","categories":["Python系列"]},{"title":"Python面向对象的三大特征","url":"/2020/06/27/Python面向对象的三大特征/","content":"\n\n## 面向对象三大特征\n封装、继承、多态作为面向对象编程的三大特征，其概念也是循序渐进的，首先需要有类的概念，随后将类进行封装，对外只暴露需要暴露的部分，简化对外交互；而后类与类之间会有继承关系；进而有了多态的概念。\n\n### 封装\n#### 概念\n封装是指一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。同时，它也是一种防止外界调用端访问对象内部实现细节的手段。\n\n#### 原则\n封装的目的是隐藏对象的属性和实现细节，仅对外公开访问方法，并且控制访问级别。所以对于封装的原则，大致可以归纳为高内聚，低耦合。\n1、高内聚：高内聚是指一个模块中各个部分之间关联应该是紧密的。\n2、低耦合：低耦合是指多个模块之间的关联应该是松散的。\n\n#### 评价标准\n不同程序员对于同样的类也可能会有不同的封装方法，评价类是否较好的完成封装这一特征的标准大致包含以下几方面：\n - 功能单一性\n - 可扩展性\n - 明确的输入输出\n\n---\n\n### 继承\n#### 概念\n继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类。\n\n#### 抽象\n所谓抽象，与我们平时理解的抽象大致相同。就是将有共同特征的一类事物进行归纳，将其共有的、本质性的特征归纳抽象出来。\n\n#### 继承\n所谓继承，就是基于抽象出来的共同特征定义父类之后，需要定义和父类具有相同的属性和方法的子类，即称子类继承于父类，子类中仍可以重新定义、追加属性和方法等。\n\n - 继承与重用的区别\n  所谓代码重用是将已经编写完成的代码复制，在新的编码中重用之前程序已经完成的代码功能，代码重用可以虽然可以节省开发周期，简化编码难度。\n  而继承与重用的核心区别就是继承是基于对类进行抽象之后，对于类进行的抽象归纳之后认为其所具有的相同的方法/属性。对于编码而言，不需要将原有代码复制到新的编码之中，而只需要声明其继承于某个已经完成的类作为父类即可。相比重用，减少了代码量，增加了代码的可读性。\n\n\n#### 继承相关名词概念解释\n - 父类 & 子类\n所谓父类即作为抽象的类可以产生相关子类的类。\n所谓子类就是通过继承其他类所创建出来的类。\n\n - 基类 & 派生类\n基类概念同父类，派生类概念同子类。\n\n - 新式类 & 经典类\n  - 新式类：\n  1、在Python 3.x中取消了经典类，默认都是新式类，创建新式类时不必显式的继承object。\n  2、新式类多继承的原则是：广度优先。总结而言，即在新式类中对于子类继承多个父类的情况，如果继承的多个父类中有属性相同的，则越`靠后`继承的父类中的属性会覆盖靠前继承的父类的相同属性。\n  3、新式类中增加了`__slots__`内置属性, `__slots__`的作用是可以限定实例属性的种类。\n  4、新式类中增加了`__getattribute__`方法，对于访问类/实例中任何存在与否的方法/属性时都会调用`__getattribute__`方法。\n  5、新式类内置增加了`__new__`方法。\n\n  - 经典类：\n  1、在Python2.x中，默认都是经典类，只有显式继承了object创建的才是新式类。\n  2、经典类多继承的原则是：深度优先。总结而言，即在新式类中对于子类继承多个父类的情况，如果继承的多个父类中有属性相同的，则越`靠前`继承的父类中的属性会覆盖靠后继承的父类的相同属性。\n\n - 单继承 & 多继承\n单继承是指子类只可以继承自一个父类。\n多继承是指一个子类同时继承自多个父类。\n\n\n#### 抽象类&接口类\n - 抽象类\n抽象类只能被继承，而不能被实例化。其作用在于规定继承它的子类需要实现什么方法，而不是其本身实现了什么功能。\n\n```python\nimport abc  # 利用abc模块实现抽象类\n\n# 定义父类Person\nclass Person(metaclass=abc.ABCMeta):\n    all_type = 'person'\n    @abc.abstractmethod  # 定义抽象方法，无需具体实现\n    def sleep(self):\n        '子类需定义睡觉方法'\n        pass\n\n    @abc.abstractmethod  # 定义抽象方法，无需具体实现\n    def eat(self):\n        '子类需定义吃饭方法'\n        pass\n\n# 定义子类Student\nclass Student(Person):\n    pass\nstudent = Student()  # 此处抛出异常，因为子类没有定义抽象方法\n\n# 定义子类Worker\nclass Worker(Person):\n    def sleep(self):\n        print('Worker睡觉方法')\n\n    def eat(self):\n        print('Worker吃方法')\n\n# 定义子类Teacher\nclass Teacher(Person):\n    def sleep(self):\n        print('Teacher睡觉方法')\n\n    def eat(self):\n        print('Teacher吃方法')\n\n# 定义子类Farmer\nclass Farmer(Person):\n    def sleep(self):\n        print('Farmer睡觉方法')\n\n    def eat(self):\n        print('Farmer吃方法')\n\nworker=Worker()\n\nteacher=Teacher()\n\nfarmer=Farmer()\n\n#  此处体现了归一化思想，即相同方法在不同子类中的具体实现不同，但是调用者的调用方式相同\nworker.sleep()\nworker.eat()\n\nteacher.sleep()\nteacher.eat()\n\nfarmer.sleep()\nfarmer.eat()\n```\n\n - 接口类\n继承的作用可以大致分类两方面：代码复用和实现接口继承。\n那么，什么是接口继承呢？接口继承的意义在于需要一种抽象类，该抽象类实现了一种兼容功能，使得调用者无需关心类的内部实现细节，便可以统一处理特定接口。这被称为\"归一化\"。归一化的意义在于外部功能的调用者不用关注细节，便可以统一的处理所有接口兼容的对象。\n同时，便要引出编程的\"依赖倒置\"原则。即：\n1、高层模块不应该依赖低层模块，二者都应该依赖其抽象；\n2、抽象不应该应该依赖细节，细节应该依赖抽象。\n总而言之，即程序要针对接口编程，而不是针对实现编程\n\n\n---\n\n\n### 多态\n\n#### 概念\n多态指的是一类事物具有多种形态，同时，多态是继承的具体展现形式。\n\n#### 多态性\n多态性是指在不考虑实例类型的情况下使用实例。\n\n#### 鸭子类型（Duck Type）\n - 鸭子类型概念\nIf it walks like a duck and quacks like a duck, it must be a duck。(如果它走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。)\n鸭子类型是计算机领域中的一种设计风格，其意义即对象的特征不取决于其父类，而取决于对象本身的实现。\n\n#### 示例\n\n```python\nimport abc\n\n# 定义父类Person\nclass Person(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def eat(self):\n        '子类需定义吃饭方法'\n        pass\n\n\n# 定义子类Worker\nclass Worker(Person):\n    def eat(self):\n        print('Worker吃方法')\n\n# 定义子类Teacher\nclass Teacher(Person):\n    def eat(self):\n        print('Teacher吃方法')\n\n# 定义子类Farmer\nclass Farmer(Person):\n    def eat(self):\n        print('Farmer吃方法')\n\nworker=Worker()\nteacher=Teacher()\nfarmer=Farmer()\n\n# 此处worker、teacher、farmer都有吃的方法，但是具体的实现不同，所以eat方法本身不取决于Person父类中的eat方法，而是由每个子类所产生的实例自己决定\nworker.eat()\nteacher.eat()\nfarmer.eat()\n\n# 我们也可以进一步的统一调用方式\ndef someone_eat(obj):\n    obj.eat()\n\nsomeone_eat(worker)\nsomeone_eat(teacher)\nsomeone_eat(farmer)\n```\n","categories":["Python系列"]},{"title":"Python面向对象初识","url":"/2020/06/07/Python面向对象初识/","content":"\n\n## 面相对象初识\n - 面向过程编程\n面向过程编程即流程式编程，根据问题进行分析，抽象出解决问题所需要的步骤，并按步骤逐步进行函数调用解决问题。\n\n - 函数式编程\n函数式编程是一种编程范式，即给定输入值，经过函数处理后给出返回值，即为函数式编程。比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。\n\n - 面向对象编程\n面向对象编程是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。\n\n\n### 类与对象\n#### 类\n - 概念\n定义了一件事物的抽象特点，类的定义包含了数据的形式以及对数据的操作。\n\n - 意义\n类的出现，为面向对象编程的三个最重要的特性，即封装性、继承性、多态性，提供了实现的手段。\n\n - 作用\n属性引用、实例化\n\n- 声明类\n\n```python\nclass Foo:\n    \"description of class\"\n    pass\n```\n\n\n#### 对象\n - 概念\n对象即类的实例\n\n - 意义\n类相当于是蓝图，定义了一件特定事物的抽象特点，而对象则是类的真实实例，实现了类定义。\n\n - 作用\n属性引用\n\n - 创建对象\n\n```python\nclass Foo:\n    \"description of class\"\n    def __init__(self, x):\n        self.x = x\n\nfoo = Foo()  # 类的实例化，python中类的实例化会自动调用类的__init__方法\n```\n\n---\n\n### 属性与方法\n - 概念\n在Python中 , 我们将静态属性 就称为`属性`, 将动态属性就称为`方法`, 以变量表示`属性`, 以函数表示`方法`。\n\n - 调用\n类/实例调用属性/方法的方式为：`类名/实例名 . 属性名/方法名`\n\n - 特殊的类属性\n\n\n|属性名|说明|\n|---|---|\n|\\__dict\\__ |查看类/实例成员, 返回字典|\n|\\__name\\__ |查看类名|\n|\\__doc\\__ |查看类的描述信息, 即类的注释|\n|\\__base\\__ |查看当前类的第一个父类|\n|\\__bases\\__|查看当前类的所有父类, 返回元组|\n|\\__module\\__|查看当前类所在模块|\n|\\__class\\__|查看当前实例的父类|\n\n\n---\n\n### 构造方法 & 析构方法\n - 构造方法\n`\\__init\\__`被称作构造方法，其作用是用于对类进行初始化，如果需要对类设置属性，则可以在构造方法中进行初始化设置。\n\n - 析构方法\n`\\__del\\__`被称作析构方法，当对象的生命周期结束时，它会自动地被调用运行。它最主要的目的在于，清空并释放对象先前创建或是占用的存储器资源。\n\n---\n\n### 命名空间\n命名空间它表示着一个标识符的可见范围，在定义类的时候会产生类的命名空间，同样在类实例化对象之后，对象也会对应产生命名空间。当调用类/实例的属性/方法时，Python解释器首先会到该实例的命名空间中去找对应属性/方法,如果没有找到则继续向上去类的命名空间去找,如果都没有找到对应调用的属性/方法，则抛出异常。\n\n---\n\n### 类/实例中的属性/方法绑定关系\n - Python作为一种动态语言，其所有的赋值机制都是通过动态绑定实现。\n - 类中的属性/方法可供其创建的所有实例使用\n - 实例中的属性/方法只适用于实例本身\n\n---\n\n### 对象交互&类的组合\n - 对象交互\n\n```python\nclass Foo:\n    def __init__(self, x):\n        self.x = x\n    def interactive(self, other):\n        print(\"【{}】 interactive 【{}】\".format(self.x, other.x))\n\nobj_a = Foo('obj_a')\nobj_b = Foo('obj_b')\nobj_a.interactive(obj_b)\n\n# 输出\n【obj_a】 interactive 【obj_b】\n\n```\n\n - 类的组合\n\n```python\n# 传参\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\nclass Worker:\n    def __init__(self, person):\n        self.person = person\n\nperson = Worker(Person('Yang'))\n\n# 定义\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\nclass Worker:\n    def __init__(self, person):\n        self.person = Person('Yang')\n\nworker = Worker()\n\n```\n\n---\n\n### metaclass（元类）\n> https://docs.python.org/zh-cn/3.8/reference/datamodel.html#metaclasses\n\n#### 概念及作用\n - 概念\n一种用于创建类的类。\n类定义包含类名、类字典和基类列表。\n元类负责接受上述三个参数并创建相应的类。\n大部分面向对象的编程语言都会提供一个默认实现。\nPython 的特别之处在于可以创建自定义元类。\n大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。\n - 作用\n它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。\n\n#### 元类的原理及定义类的执行过程\n - 元类的原理\n默认情况下，类是使用 type() 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定到 type(name, bases, namespace) 的结果。\n类创建过程可通过在定义行传入 metaclass 关键字参数，或是通过继承一个包含此参数的现有类来进行定制。\n\n - 类定义的执行过程\n\n```python\n1、解析 MRO 条目:\n如果在类定义中出现的基类不是 type 的实例，则使用 __mro_entries__ 方法对其进行搜索，当找到结果时，它会以原始基类元组做参数进行调用。\n\n2、确定适当的元类:\n在类定义时确定元类的流程：\n    ①如果没有基类且没有显式指定元类，则使用 type()；\n    ②如果给出一个显式元类且不是 type() 的实例，则其会被直接用作元类；\n    ③如果给出一个 type() 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。\n\n3、准备类命名空间:\n在类定义之时确定元类的命名空间原则：\n    ①如果元类具有 __prepare__ 属性，它会以 namespace = metaclass.__prepare__(name, bases, **kwds) 的形式被调用（其中如果有任何额外的关键字参数，则应来自类定义）。 __prepare__ 方法的实现应当为 classmethod()。\n    ②如果元类没有 __prepare__ 属性，则类命名空间将初始化为一个空的有序映射。\n\n4、执行类主体:\n    类主体会以（类似于） exec(body, globals(), namespace) 的形式被执行。普通调用与 exec() 的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当前和外部作用域的名称。\n    但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过隐式词法作用域的 __class__ 引用。\n\n5、创建类对象:\n一旦执行类主体完成填充类命名空间，将通过调用 metaclass(name, bases, namespace, **kwds) 创建类对象（此处的附加关键字参数与传入 __prepare__ 的相同）。\n\n如果类主体中有任何方法引用了 __class__ 或 super，这个类对象会通过零参数形式的 super(). __class__ 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 super() 能够正确标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第一个参数来标识的。\n\n当使用默认的元类 type 或者任何最终会调用 type.__new__ 的元类时，以下额外的自定义步骤将在创建类对象之后被发起调用:\n    ①首先，type.__new__ 将收集类命名空间中所有定义了 __set_name__() 方法的描述器；\n    ②接下来，所有这些 __set_name__ 方法将使用所定义的类和特定描述器所赋的名称进行调用；\n    ③最后，将在新类根据方法解析顺序所确定的直接父类上调用 __init_subclass__() 钩子。\n\n在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已定义的类绑定到局部命名空间。\n\n当通过 type.__new__ 创建一个新类时，提供以作为命名空间形参的对象会被复制到一个新的有序映射并丢弃原对象。这个新副本包装于一个只读代理中，后者则成为类对象的 __dict__ 属性。\n\n```\n\n---\n\n### 单例模式的四种方式\n - `__new__`\n\n```python\nclass Singleton(object):\n    \"\"\"单例模式\"\"\"\n    _instance = None\n    def __new__(cls, *args, **kw):\n        if not cls._instance:\n            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)\n        return cls._instance\n```\n\n - 模块导入\n\n```python\n# Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得单例对象\n\nclass My_Singleton(object):\n    def foo(self):\n        pass\nmy_singleton = My_Singleton()\n\n# 将上面的代码保存在文件 mysingleton.py 中，然后这样使用：\nfrom mysingleton import my_singleton\nmy_singleton.foo()\n\n```\n\n - 装饰器（decorator）\n\n```python\nfrom functools import wraps\n\ndef singleton(cls):\n    instances = {}\n    @wraps(cls)\n    def getinstance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return getinstance\n@singleton\nclass MyClass(object):\n    pass\n```\n\n - 元类（metaclass）\n\n```python\nclass SingletonType(object):\n    \"\"\"docstring for Singleton\"\"\"\n    def __init__(self, *args,**kwargs):\n        super(SingletonType, self).__init__(*args,**kwargs)\n    def __call__(cls,*args,**kwargs):\n        obj = cls.__new__(cls,*args,**kwargs)\n        cls.__init__(obj,*args,**kwargs)\n        return obj\nclass Foo(metaclass=SingletonType):\n    \"\"\"docstring for Foo\"\"\"\n    def __init__(self, name):\n        self.name = name\n    def __new__(cls,*args,**kwargs):\n        return object.__new__(cls)\nobj = Foo('xxx')\n```\n","categories":["Python系列"]},{"title":"Python常用的模块&包","url":"/2020/05/10/Python常用的模块&包/","content":"\n\n## 常用模块&包\n\n### re模块\n#### 正则表达式简介\n - 概念\n又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。\n\n - 字符组\n在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用`[]`表示。\n\n|正则表达式|待匹配字符串|解释|\n|---|---|---|\n|[0123456789]|6|字符组里包含待匹配字符|\n|[abcdefghij]|a|字符组里包含待匹配字符|\n|[0-9]|a|字符组里使用-作为范围，包含待匹配字符|\n|[a-z]|a|字符组里使用-作为范围，包含待匹配字符|\n|[A-Za-z0-9]|a|字符组里使用-作为范围，可以包含多个范围，包含待匹配字符|\n\n\n - 字符\n\n|元字符|解释|\n|---|---|\n|. | 可以匹配除换行符(\\n)外的任意字符 |\n|\\w    | 可以匹配数字、字母、下划线(_)|\n|\\s    | 可以匹配任何空白字符，包括空格、制表符、换页符等等。等价于字符组用法的：[\\f\\n\\r\\t\\v]|\n|\\d    | 可以匹配数字 |\n|\\n    | 可以匹配一个换行符 |\n|\\t    | 可以匹配一个制表符 |\n|\\b    | 定位符,可以匹配一个单词的边界,这个位置的一侧是构成单词的字符,另一侧为非单词字符、字符串的开始或结束位置,\"\\b\"是零宽度的 |\n|^    | 可以匹配字符串的开始 |\n|$    | 可以匹配字符串的结尾 |\n|\\W    | 可以匹配非字母或数字或下划线 |\n|\\D    | 可以匹配非数字 |\n|\\S    | 可以匹配非空白符 |\n|\\B    | 定位符,可以匹配一个非单词的边界 |\n|a\\|b | 可以匹配字符a或字符b |\n|()    | 可以匹配括号内的表达式，也表示一个组 |\n|[...] | 可以匹配字符组中的字符 |\n|[^...]    | 可以匹配除了字符组中字符的所有字符 |\n \n\n - 量词\n\n|量词|解释|\n|---|---|\n| *    | 重复零次或更多次| \n| +    | 重复一次或更多次| \n| ?    | 重复零次或一次| \n| {n} | 重复n次| \n| {n,} | 重复n次或更多次| \n| {n,m} | 重复n到m次| \n\n\n\n - 转义符`\\`与r\n\n|字符|解释|\n|---|---|\n| `\\` | 元字符中很多都包括`\\`，如果需要匹配反斜杠`\\`的话，则需要对其转义，在`\\`前增加一个`\\`变为`\\\\` | \n| r    | 如果需要转义的`\\`过多，或者觉得麻烦，可以在正则表达式中使用r，则正则表达式字符串中的`\\`视为`\\`，不当做元字符的一部分 | \n\n\n - 贪婪匹配原则\n在满足匹配条件时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配\n\n\n#### re模块介绍\nre模块使Python拥有全部的正则表达式功能,re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数\n\n\n#### re模块常用方法\n - findall(): 返回所有满足匹配条件的结果至列表中\n - search(): 返回第一个包含匹配条件的信息对象，可以调用该对象的group()方法将匹配的字符输出，如果没有匹配到则调用group()方法会报错\n - match(): 与search()方法类似，但是仅在字符串开始出匹配，返回第一个包含匹配条件的信息对象，调用该对象的group()方法将匹配的字符输出，如果没有匹配到则调用group()方法会报错\n - split(): 逐个按符合条件的字符串对待匹配字符串进行切分，返回结果列表\n - sub(): 将待匹配字符串中满足匹配条件的内容进行替换，最后一个参数指定替换的次数，返回替换后的字符串\n - subn(): 与sub()方法类型，但是无法指定替换的次数，并且输出的是一个元组，包括替换后的字符串和替换的总次数\n - compile(): 将正则表达式编译成为一个正则表达式对象，之后可以用re模块中的方法对对象进行操作\n - finditer(): finditer返回一个存放匹配结果的迭代器，用next等方法取出存放结果的对象，再用group()方法取出结果\n - findall的优先级查询: 将findall()方法中匹配条件中加括号后，只会输出匹配到的字符串；可以在括号中加入?:取消权限\n - split的优先级查询: 将split()方法中的匹配条件加括号后，会将满足条件的切分字符也输出值最终列表中，同样可以在括号中加入?:取消权限\n\n```python\n# 示例\n\nimport re\n\ns = 'life1is2short,I3use4python5' # 待匹配字符串\n\nres = re.findall(\"\\d\", s)\nprint(res)\n>>> ['1', '2', '3', '4', '5']\n\n\nres = re.search(\"1\", s)\nprint(res.group())\n>>> \"1\"\n\n\nres = re.match(\"1\", s)\nprint(res)\n>>> None\n\n\nres = re.split(\"\\d\", s)\nprint(res)\n>>> ['life', 'is', 'short,I', 'use', 'python', '']\n\n\nres = re.sub(\"\\d\", \"___\", s, 2)\nprint(res)\n>>> \"life___is___short,I3use4python5\"\n\n\nres = re.subn(\"\\d\", \"___\", s)\nprint(res)\n>>> \"life___is___short,I___use___python___\"\n\n\nprog = re.compile(\"\\d\")\nres = prog.match(s)\n# 等价于 res = re.match(\"\\d\", s)\nprint(res)\n>>> ['1', '2', '3', '4', '5']\n\n\nres = re.finditer(\"\\d\", s)\nprint([i.group() for i in res]) # 返回为一个迭代器 iterator 保存了 匹配对象 \n>>> ['1', '2', '3', '4', '5']\n\n```\n\n---\n\n\n### collections模块\n#### collections模块介绍\n这个模块实现了特定目标的容器，以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。\n\n#### collections模块常用方法\n\n|名称 |作用|\n|---|---|\n|namedtuple() |创建命名元组子类的工厂函数|\n|deque |类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)|\n|ChainMap |类似字典(dict)的容器类，将多个映射集合到一个视图里面|\n|Counter |字典的子类，提供了可哈希对象的计数功能|\n|OrderedDict |字典的子类，保存了他们被添加的顺序|\n|defaultdict |字典的子类，提供了一个工厂函数，为字典查询提供一个默认值|\n|UserDict |封装了字典对象，简化了字典子类化|\n|UserList |封装了列表对象，简化了列表子类化|\n|UserString |封装了列表对象，简化了字符串子类化|\n\n```python\n\n# -------------------\n# namedtuple\n# -------------------\n\n这个新的子类用于创建类元组的对象，可以通过域名来获取属性值，同样也可以通过索引和迭代获取值。\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(11, y=22)\nres = p[0] + p[1]\nprint(res)\n\n# 输出\n>>> 33\n\n# -------------------\n# deque\n# -------------------\n返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从迭代对象数据创建。\n\n>>> from collections import deque\n>>> d = deque('ghi') # 创建一个新的deque\n>>> for elem in d: # 循环输出deque中的元素\n... print(elem.upper())\nG\nH\nI\n\n>>> d.append('j') # 从右边插入新元素\n>>> d.appendleft('f') # 从左边插入新元素\n>>> d # 输出deque所有元素\ndeque(['f', 'g', 'h', 'i', 'j'])\n\n>>> d.pop() # 从右边推出最后一个元素\n'j'\n>>> d.popleft() # 从左边推出最后一个元素\n'f'\n>>> list(d) # 输出deque所有元素\n['g', 'h', 'i']\n>>> d[0] # 输出最左边元素\n'g'\n>>> d[-1] # 输出最右边元素\n'i'\n\n>>> list(reversed(d)) # 逆向输出deque所有元素\n['i', 'h', 'g']\n>>> 'h' in d # 在deque中查找元素\nTrue\n>>> d.extend('jkl') # 一次性添加多个元素\n>>> d\ndeque(['g', 'h', 'i', 'j', 'k', 'l'])\n>>> d.rotate(1) # 所有元素向右移动\n>>> d\ndeque(['l', 'g', 'h', 'i', 'j', 'k'])\n>>> d.rotate(-1) # 所有元素向左移动\n>>> d\ndeque(['g', 'h', 'i', 'j', 'k', 'l'])\n\n>>> deque(reversed(d)) # 创建一个新的deque\ndeque(['l', 'k', 'j', 'i', 'h', 'g'])\n>>> d.clear() # 清空deque\n>>> d.pop() # 空deque不能推出元素\nTraceback (most recent call last):\n    File \"<pyshell#6>\", line 1, in -toplevel-\n        d.pop()\nIndexError: pop from an empty deque\n\n>>> d.extendleft('abc') # 一次性添加多个元素，从左边开始插入\n>>> d\ndeque(['c', 'b', 'a'])\n\n# -------------------\n# ChainMap\n# -------------------\n将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。\n\nfrom collections import ChainMap\nbaseline = {'music': 'bach', 'art': 'rembrandt'}\nadjustments = {'art': 'van gogh', 'opera': 'carmen'}\nprint(list(ChainMap(adjustments, baseline)))\n\n# 输出\n>>> ['music', 'opera', 'art']\n\nfrom collections import ChainMap\nbaseline = {'music': 'bach', 'art': 'rembrandt'}\nadjustments = {'art': 'van gogh', 'opera': 'carmen'}\ncombined = baseline.copy()\ncombined.update(adjustments)\nprint(list(combined))\n\n# 输出\n>>> ['music', 'art', 'opera']\n\n\n# -------------------\n# Counter:\n# -------------------\n是dict的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。\n\nc = Counter() # 创建新的空Counter对象\nc = Counter('gallahad') # 创建字符串的Counter对象\nc = Counter({'red': 4, 'blue': 2}) # 创建映射关系的Counter对象\nc = Counter(cats=4, dogs=8) # 创建关键字的Counter对象\n\n# -------------------\n# OrderedDict\n# -------------------\n\n它具有专门用于重新排列字典顺序的方法。\n\n>>> d = OrderedDict.fromkeys('abcde')\n>>> d.move_to_end('b')\n>>> ''.join(d.keys())\n'acdeb'\n>>> d.move_to_end('b', last=False)\n>>> ''.join(d.keys())\n'bacde'\n\n\n# -------------------\n# defaultdict\n# ------------------- \n一个新的类似字典的对象。它重载了一个方法并添加了一个可写的实例变量。\n\n>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]\n>>> d = defaultdict(list)\n>>> for k, v in s:\n... d[k].append(v)\n...\n>>> sorted(d.items())\n[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]\n\n\n# -------------------\n# UserDict\n# ------------------- \n模拟一个字典类。这个实例的内容保存为一个正常字典， 可以通过 UserDict 实例的 data 属性存取。\n\n\n# -------------------\n# UserList\n# ------------------- \n这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。\n\n\n# -------------------\n# UserString\n# ------------------- \n用作字符串对象的外包装。对这个类的需求已部分由直接创建 str 的子类的功能所替代\n\n```\n\n---\n\n\n### 时间模块\n#### 表示时间的三种方式\n - 时间戳：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。\n\n```python\nimport time\nprint(time.time())\n\n>>> 1515570662.77503\n\n```\n\n - 结构化时间：结构化时间元组共有9个元素(年，月，日，时，分，秒，一年中第几周，一年中第几天等）\n\n```python\nimport time\nprint(time.localtime())\n\n>>> time.struct_time(tm_year=2018, tm_mon=1, tm_mday=10, tm_hour=16, tm_min=0, tm_sec=33, tm_wday=2, tm_yday=10, tm_isdst=0)\n```\n\n - 时间字符串：以字符串表示年、月、日、时间\n\n```python\nimport time\nprint(time.strftime(\"%Y-%m-%d %H-%M-%S\"))\n\n>>> 2018-01-10 15-59-16\n```\n\n#### 几种格式之间的转换\n - 时间戳–>结构化时间\n\n```python\n# time.gmtime(时间戳) #UTC时间，与英国伦敦当地时间一致\n# time.localtime(时间戳) #当地时间。例如当地时间为北京时间，与UTC时间相差8小时，UTC时间+8小时 = 北京时间\n\nimport time\n\ntimestamp = 1515570662.77503\n\n# 时间戳 → 当地时间\nprint(time.localtime(timestamp))\n>>> time.struct_time(tm_year=2018, tm_mon=1, tm_mday=10, tm_hour=15, tm_min=51, tm_sec=2, tm_wday=2, tm_yday=10, tm_isdst=0)\n\n# 时间戳 → UTC时间\nprint(time.gmtime(timestamp))\n>>> time.struct_time(tm_year=2018, tm_mon=1, tm_mday=10, tm_hour=7, tm_min=51, tm_sec=2, tm_wday=2, tm_yday=10, tm_isdst=0)\n```\n\n - 结构化时间–>时间戳\n\n```python\n# time.mktime(结构化时间)\n\nimport time\ntime_tuple  = time.localtime(1500000000)\nprint(time.mktime(time_tuple))\n\n>>> 1500000000.0\n```\n\n - 字符串时间–>结构化时间\n\n```python\n# time.strptime(时间字符串,字符串对应格式)\n\nimport time\nprint(time.strftime(\"%Y-%m-%d %X\"))\n>>> 2018-01-10 16:19:46\nprint(time.strftime(\"%Y-%m-%d\",time.localtime(1515570662.77503)))\n\n>>> 2018-01-10\n```\n\n - 结构化时间–>字符串时间\n\n```python\n# time.strftime(“格式定义”,”结构化时间”) 结构化时间参数若不传，则现实当前时间\n\nimport time\nprint(time.strptime(\"2017-03-16\",\"%Y-%m-%d\"))\n\n>>> time.struct_time(tm_year=2017, tm_mon=3, tm_mday=16, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=75, tm_isdst=-1)\n\nprint(time.strptime(\"07/24/2017\",\"%m/%d/%Y\"))\n\n>>> time.struct_time(tm_year=2017, tm_mon=7, tm_mday=24, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=205, tm_isdst=-1)\n```\n\n---\n\n\n### random模块\n#### random模块介绍\n该模块实现了各种分布的伪随机数生成器。\n\n#### random模块常用方法\n - 随机小数\n\n```python\nimport random\nprint(random.random()) # 随机输出在0-1之间的小数\n>>> 0.11828833626857149\n\nimport random\nprint(random.uniform(1,5)) # 随机输出在范围之间的小数\n>>> 2.164732131520036\n```\n\n - 随机整数\n\n```python\nimport random\nprint(random.randint(5,10)) # randint中的范围包括首尾\n>>> 8\n\nimport random\nprint(random.randrange(5,10,2)) # randrange中的范围顾首不顾尾，可以指定步长\n>>> 7\n```\n\n - 随机返回列表元素\n\n```python\nimport random\nprint(random.choice([1,'23',[4,5],(6,7)]))\n>>> (6, 7)\n```\n\n - 随机返回多个列表元素，可以指定返回的个数\n\n```python\nimport random\nprint(random.sample([1,'23',[4,5],(6,7)],2)) \n>>> [(6, 7), 1]\n```\n\n - 打乱顺序\n\n```python\nimport random\nitem=[1,2,3,4,5,6,7,8,9]\nrandom.shuffle(item)\nprint(item)\n>>> [2, 6, 8, 3, 5, 4, 7, 1, 9]\n```\n\n---\n\n\n### os模块\n#### os模块介绍\n本模块提供了一种使用与操作系统相关的功能的便捷式途径。\n\n#### os模块常用方法\n - 进程参数: 这些函数和数据项提供了操作当前进程和用户的信息。\n\n```python\n os.ctermid(): 返回与进程控制终端对应的文件名。\n os.environ: 一个表示字符串环境的 mapping 对象。\n os.environb:字节版本的 environ: 一个以字节串表示环境的 mapping 对象。\n os.fsencode(filename)：编码 路径类 文件名 为文件系统接受的形式，使用 'surrogateescape' 代理转义编码错误处理器，在Windows系统上会使用 'strict' ；返回 bytes 字节类型不变。\n os.fsdecode(filename)：从文件系统编码方式解码为 路径类 文件名，使用 'surrogateescape' 代理转义编码错误处理器，在Windows系统上会使用 'strict' ；返回 str 字符串不变。\n os.fspath(path):返回路径的文件系统表示。\n os.getenv(key, default=None):如果存在，返回环境变量 key 的值，否则返回 default。 key ， default 和返回值均为 str 字符串类型。\n os.getenvb(key, default=None):如果存在环境变量 key 那么返回其值，否则返回 default。 key ， default 和返回值均为bytes字节串类型。\n os.get_exec_path(env=None):返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。\n os.getegid():返回当前进程的有效组ID。\n os.geteuid():返回当前进程的有效用户ID。\n os.getgid():返回当前进程的实际组ID。\n os.getgrouplist(user, group):返回该用户所在的组 ID 列表。\n os.getgroups(): 返回当前进程对应的组ID列表\n os.getlogin():返回通过控制终端进程进行登录的用户名。\n os.getpgid(pid):根据进程id pid 返回进程的组 ID 列表。\n os.getpgrp():返回当时进程组的ID\n os.getpid():返回当前进程ID\n os.getppid():返回父进程ID。\n os.getpriority(which, who):获取程序调度优先级。\n os.getresuid():返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和甲暂存用户ID。\n os.getresgid():返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。\n os.getuid():返回当前进程的真实用户ID。\n os.initgroups(username, gid):调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID\n os.putenv(key, value):将名为 key 的环境变量值设置为 value。\n os.setegid(egid):设置当前进程的有效组ID。\n os.seteuid(euid):设置当前进程的有效用户ID。\n os.setgid(gid):设置当前进程的组ID。\n os.setgroups(groups):将 group 参数值设置为与当进程相关联的附加组ID列表\n os.setpgrp():根据已实现的版本（如果有）来调用系统 setpgrp() 或 setpgrp(0, 0) 。\n os.setpgid(pid, pgrp):使用系统调用 setpgid()，将 pid 对应进程的组ID设置为 pgrp。\n os.setpriority(which, who, priority):设置程序调度优先级。\n os.setregid(rgid, egid):设置当前进程的真实和有效组ID。\n os.setresgid(rgid, egid, sgid):设置当前进程的真实，有效和暂存组ID。\n os.setresuid(ruid, euid, suid):设置当前进程的真实，有效和暂存用户ID。\n os.setreuid(ruid, euid):设置当前进程的真实和有效用户ID。\n os.getsid(pid):调用系统调用 getsid()。\n os.setsid():使用系统调用 getsid()。\n os.setuid(uid):设置当前进程的用户ID。\n os.strerror(code):根据 code 中的错误码返回错误消息。\n os.supports_bytes_environ:如果操作系统上原生环境类型是字节型则为 True (例如在 Windows 上为 False)。\n os.umask(mask):设定当前数值掩码并返回之前的掩码。\n os.uname():返回当前操作系统的识别信息。\n os.unsetenv(key):取消设置（删除）名为 key 的环境变量。\n```\n\n - 创建文件对象: 这些函数创建新的 file objects。\n\n```python\n os.fdopen(fd, *args, **kwargs)：返回打开文件描述符 fd 对应文件的对象。\n```\n\n - 文件描述符操作: 这些函数对文件描述符所引用的 I/O 流进行操作。\n\n```python\n os.close(fd):关闭文件描述符 fd\n os.closerange(fd_low, fd_high):关闭从 fd_low （包括）到 fd_high （排除）间的文件描述符，并忽略错误。\n os.copy_file_range(src, dst, count, offset_src=None, offset_dst=None):从文件描述符 src 复制 count 字节，从偏移量 offset_src 开始读取，到文件描述符 dst，从偏移量 offset_dst 开始写入。\n os.device_encoding(fd):如果连接到终端，则返回一个与 fd 关联的设备描述字符，否则返回 None。\n os.dup(fd):返回一个文件描述符 fd 的副本。\n os.dup2(fd, fd2, inheritable=True):把文件描述符 fd 复制为 fd2，必要时先关闭后者。\n os.fchmod(fd, mode):将 fd 指定文件的权限状态修改为 mode。\n os.fchown(fd, uid, gid):分别将 fd 指定文件的所有者和组 ID 修改为 uid 和 gid 的值。\n os.fdatasync(fd):强制将文件描述符 fd 指定文件写入磁盘。\n os.fpathconf(fd, name):返回与打开的文件有关的系统配置信息。\n os.fstat(fd):获取文件描述符 fd 的状态. 返回一个 stat_result 对象。\n os.fstatvfs(fd):返回文件系统的信息，该文件系统是文件描述符 fd 指向的文件所在的文件系统，与 statvfs() 一样。从 Python 3.3 开始，它等效于 os.statvfs(fd)。\n os.fsync(fd):强制将文件描述符 fd 指向的文件写入磁盘。\n os.ftruncate(fd, length):将文件描述符 fd 指向的文件切分开，以使其最大为 length 字节。从 Python 3.3 开始，它等效于 os.truncate(fd, length)。\n os.get_blocking(fd):获取文件描述符的阻塞模式：如果设置了 O_NONBLOCK 标志位，返回 False，如果该标志位被清除，返回 True。\n os.isatty(fd):如果文件描述符 fd 打开且已连接至 tty 设备（或类 tty 设备），返回 True，否则返回 False。\n os.lockf(fd, cmd, len):在打开的文件描述符上，使用、测试或删除 POSIX 锁。\n os.lseek(fd, pos, how):将文件描述符 fd 的当前位置设置为 pos，\n os.open(path, flags, mode=0o777, *, dir_fd=None):打开文件 path，根据 flags 设置各种标志位，并根据 mode 设置其权限模式。\n os.openpty():打开一对新的伪终端，返回一对文件描述符``（主，从）``，分别为 pty 和 tty。\n os.pipe():创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)。\n os.pipe2(flags):创建带有 flags 标志位的管道。\n os.posix_fallocate(fd, offset, len):确保为 fd 指向的文件分配了足够的磁盘空间，该空间从偏移量 offset 开始，到 len 字节为止。\n os.posix_fadvise(fd, offset, len, advice):声明即将以特定模式访问数据，使内核可以提前进行优化。\n os.pread(fd, n, offset):从文件描述符 fd 所指向文件的偏移位置 offset 开始，读取至多 n 个字节，而保持文件偏移量不变。\n os.preadv(fd, buffers, offset, flags=0):从文件描述符 fd 所指向文件的偏移位置 offset 开始，将数据读取至可变 字节类对象 缓冲区 buffers 中，保持文件偏移量不变。\n os.RWF_NOWAIT:不要等待无法立即获得的数据。\n os.RWF_HIPRI:高优先级读/写。\n os.pwrite(fd, str, offset):将 str 中的字节串 (bytestring) 写入文件描述符 fd 的偏移位置 offset 处，保持文件偏移量不变。\n os.pwritev(fd, buffers, offset, flags=0):将缓冲区 buffers 的内容写入文件描述符 fd 的偏移位置 offset 处，保持文件偏移量不变。\n os.RWF_DSYNC:提供立即写入功能，等效于 O_DSYNC open(2) 标志\n os.RWF_SYNC:提供立即写入功能，等效于 O_SYNC open(2) 标志。\n os.read(fd, n):从文件描述符 fd 中读取至多 n 个字节。\n os.sendfile(out, in, offset, count, [headers, ][trailers, ]flags=0):将文件描述符 in 中的 count 字节复制到文件描述符 out 的偏移位置 offset 处。返回复制的字节数，如果到达 EOF，返回 0。\n os.set_blocking(fd, blocking):设置指定文件描述符的阻塞模式：如果 blocking 为 False，则为该描述符设置 O_NONBLOCK 标志位，反之则清除该标志位。\n os.readv(fd, buffers):从文件描述符 fd 将数据读取至多个可变的 字节类对象 缓冲区 buffers 中。\n os.tcgetpgrp(fd):返回与 fd 指定的终端相关联的进程组（fd 是由 os.open() 返回的已打开的文件描述符）\n os.tcsetpgrp(fd, pg):设置与 fd 指定的终端相关联的进程组为 pg*（*fd 是由 os.open() 返回的已打开的文件描述符）。\n os.ttyname(fd):返回一个字符串，该字符串表示与文件描述符 fd 关联的终端。\n os.write(fd, str):将 str 中的字节串 (bytestring) 写入文件描述符 fd。\n os.writev(fd, buffers):将缓冲区 buffers 的内容写入文件描述符 fd。\n\n# 查询终端的尺寸\n os.get_terminal_size(fd=STDOUT_FILENO):返回终端窗口的尺寸，格式为 (columns, lines)，它是类型为 terminal_size 的元组。\n os.terminal_size:元组的子类，存储终端窗口尺寸 (columns, lines)。\n\n# 文件描述符的继承\n os.get_inheritable(fd):获取指定文件描述符的“可继承”标志位（为布尔值）。\n os.set_inheritable(fd, inheritable):设置指定文件描述符的“可继承”标志位。\n os.get_handle_inheritable(handle):获取指定句柄的“可继承”标志位（为布尔值）。\n os.set_handle_inheritable(handle, inheritable):设置指定句柄的“可继承”标志位。\n\n```\n\n - 文件和目录\n\n```python\n os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True):使用 实际用户ID/用户组ID 测试对 path 的访问。\n os.chdir(path):将当前工作目录更改为 path。\n os.chflags(path, flags, *, follow_symlinks=True):将 path 的 flags 设置为其他由数字表示的 flags。\n os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True):将 path 的 mode 更改为其他由数字表示的 mode。 \n os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True):将 path 的用户和组 ID 分别修改为数字形式的 uid 和 gid。 \n os.chroot(path):将当前进程的根目录更改为 path。 \n os.fchdir(fd):将当前工作目录更改为文件描述符 fd 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 os.chdir(fd)。\n os.getcwd():返回表示当前工作目录的字符串。\n os.getcwdb():返回表示当前工作目录的字节串 (bytestring)。\n os.lchflags(path, flags):将 path 的 flags 设置为其他由数字表示的 flags，与 chflags() 类似，但不跟踪符号链接。\n os.lchmod(path, mode):将 path 的权限状态修改为 mode。\n os.lchown(path, uid, gid):将 path 的用户和组 ID 分别修改为数字形式的 uid 和 gid，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 os.chown(path, uid, gid, follow_symlinks=False)。\n os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True):创建一个指向 src 的硬链接，名为 dst。\n os.listdir(path='.'):返回一个列表，该列表包含了 path 中所有文件与目录的名称。\n os.lstat(path, *, dir_fd=None)：在给定路径上执行本函数，其操作相当于 lstat() 系统调用，类似于 stat() 但不跟踪符号链接。返回值是 stat_result 对象。\n os.mkdir(path, mode=0o777, *, dir_fd=None):创建目录path，并使用数字定义模式。\n os.makedirs(name, mode=0o777, exist_ok=False):Recursive directory creation function. Like mkdir(), but makes all intermediate-level directories needed to contain the leaf directory.\n os.rmdir(path, *, dir_fd=None):Remove (delete) the directory path.\n os.stat(path, *, dir_fd=None, follow_symlinks=True): Get the status of a file or a file descriptor.\n os.walk(top, topdown=True, onerror=None, followlinks=False):Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames).\n\n```\n\n - 进程管理\n\n```python\n os.abort():Generate a SIGABRT signal to the current process.\n os.add_dll_directory(path):Add a path to the DLL search path.\n\n These functions all execute a new program, replacing the current process; they do not return.\n    os.execl(path, arg0, arg1, ...)\n    os.execle(path, arg0, arg1, ..., env)\n    os.execlp(file, arg0, arg1, ...)\n    os.execlpe(file, arg0, arg1, ..., env)\n    os.execv(path, args)\n    os.execve(path, args, env)\n    os.execvp(file, args)\n    os.execvpe(file, args, env)\n\n Execute the program path in a new process.\n    os.spawnl(mode, path, ...)\n    os.spawnle(mode, path, ..., env)\n    os.spawnlp(mode, file, ...)\n    os.spawnlpe(mode, file, ..., env)\n    os.spawnv(mode, path, args)\n    os.spawnve(mode, path, args, env)\n    os.spawnvp(mode, file, args)\n    os.spawnvpe(mode, file, args, env)\n\n```\n\n - 调度器接口\n\n```python\nos.sched_get_priority_min(policy):获取 policy 的最小优先级数值。 policy 是以上调度策略常量之一。\nos.sched_get_priority_max(policy):获取 policy 的最高优先级数值。 policy 是以上调度策略常量之一。\n```\n\n - 杂项系统信息\n\n```python\n os.confstr(name):Return string-valued system configuration values.\n os.cpu_count():Return the number of CPUs in the system.该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 len(os.sched_getaffinity(0)) 方法获得。\n os.curdir:The constant string used by the operating system to refer to the current directory.\n os.pardir:The constant string used by the operating system to refer to the parent directory.\n os.sep:The character used by the operating system to separate pathname components.\n```\n\n - 随机数\n\n```python\n os.getrandom(size, flags=0):Get up to size random bytes.\n os.urandom(size):Return a string of size random bytes suitable for cryptographic use.\n```\n\n---\n\n\n### sys模块\n#### sys模块介绍\n该模块提供了一些变量和函数。这些变量可能被解释器使用，也可能由解释器提供。\n\n#### sys模块常用方法\n\n```python\nsys.argv: 命令行参数List，第一个元素是程序本身路径\nsys.exit(n): 退出程序，正常退出时exit(0),错误退出sys.exit(1)\nsys.version: 获取Python解释程序的版本信息\nsys.path: 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值\nsys.platform: 返回操作系统平台名称\n```\n\n---\n\n\n### 序列化相关模块\n#### 序列化概念\nwiki中对于序列化的解释：在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。\n简而言之，将原本的字典、列表等内容转换成一个字符串的过程叫做序列化，其反过程叫反序列化。\n\n#### 序列化目的\n - 以某种存储形式使自定义对象持久化\n - 将对象从一个地方传递到另一个地方\n - 使程序更具维护性\n\n#### 序列化相关模块介绍\n - json: 由 RFC 7159 (which obsoletes RFC 4627) 和 ECMA-404 指定，是一个受 JavaScript 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。\n - pickle: 模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。\n - shelve: \"Shelf\" 是一种持久化的类似字典的对象。 与 \"dbm\" 数据库的区别在于 Shelf 中的值（不是键！）实际上可以为任意 Python 对象, 即 pickle 模块能够处理的任何东西。\n - marshal: 此模块包含一此能以二进制格式来读写 Python 值的函数。这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 pickle 和 shelve 等模块。\n\n#### 序列化相关模块常用方法\n - json: 用于字符串(包括其他支持json的语言)和python数据类型间进行转换\n\n```python\n# ---------------\n# 序列化dumps\n# ---------------\nimport json\n\n# 序列化列表list\nprint(json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}]))\n>>> '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n\n# 序列化字符串string\nprint(json.dumps(\"\\\"foo\\bar\"))\n>>> \"\\\"foo\\bar\"\n\nprint(json.dumps('\\u1234'))\n>>> \"\\u1234\"\n\nprint(json.dumps('\\\\'))\n>>> \"\\\\\"\n\n# 序列化字典dict\nprint(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n>>> '{\"a\": 0, \"b\": 0, \"c\": 0}'\n\n# ---------------\n# 反序列化loads\n# ---------------\nimport json\nprint(json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]'))\n>>> ['foo', {'bar': ['baz', None, 1.0, 2]}]\n\njson.loads('\"\\\\\"foo\\\\bar\"')\n>>> '\"foo\\x08ar'\n\n# ---------------\n# 序列化dump(文件)\n# ---------------\nimport json\ndic = {'k1':'v1','k2':'v2','k3':'v3'}\nwith open('json_file',mode='wb') as f:\n    dic_fd=json.dump(dic,f)\n# 文件中的内容：\n>>> {\"k3\": \"v3\", \"k2\": \"v2\", \"k1\": \"v1\"}\n\n# ---------------\n# 反序列化load(文件)\n# ---------------\nimport json\nwith open('json_file',mode='r') as f:\n    dic_fs=json.load(f)\nprint(dic_fs)\n>>> {'k1': 'v1', 'k3': 'v3', 'k2': 'v2'}\n```\n\n - shelve: 只提供一个open方法，用key来访问，使用起来与字典类似\n\n```python\n# ---------------\n# 序列化(文件)\n# ---------------\nimport shelve\nwith shelve.open('shelve_file') as f:\n    f['key'] = {1,2,3,4,5,6,7,8,9}\n\n# ---------------\n# 反序列化(文件)\n# ---------------\nimport shelve\nwith shelve.open('shelve_file') as f:\n    data = f['key']\nprint(data)\n>>> {1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n# ---------------\n# 额外支持的两个方法\n# ---------------\nShelf.sync(): 如果 Shelf 打开时将 writeback 设为 True 则写回缓存中的所有条目。 如果可行还会清空缓存并将持久化字典同步到磁盘。 此方法会在使用 close() 关闭 Shelf 时自动被调用。\nShelf.close():同步并关闭持久化 dict 对象。 对已关闭 Shelf 的操作将失败并引发 ValueError。\n\n```\n\n - pickle: 用于python特有的类型和python的数据类型间进行转换\n\n```python\n# ---------------\n# 序列化dumps\n# ---------------\nimport pickle\n\n# 序列化列表list\nprint(pickle.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}]))\n>>> b'\\x80\\x03]q\\x00(X\\x03\\x00\\x00\\x00fooq\\x01}q\\x02X\\x03\\x00\\x00\\x00barq\\x03(X\\x03\\x00\\x00\\x00bazq\\x04NG?\\xf0\\x00\\x00\\x00\\x00\\x00\\x00K\\x02tq\\x05se.'\n\n# 序列化字符串string\nprint(pickle.dumps(\"\\\"foo\\bar\"))\n>>> b'\\x80\\x03X\\x07\\x00\\x00\\x00\"foo\\x08arq\\x00.'\n\nprint(pickle.dumps('\\u1234'))\n>>> b'\\x80\\x03X\\x03\\x00\\x00\\x00\\xe1\\x88\\xb4q\\x00.'\n\nprint(pickle.dumps('\\\\'))\n>>> b'\\x80\\x03X\\x01\\x00\\x00\\x00\\\\q\\x00.'\n\n# 序列化字典dict\nprint(pickle.dumps({\"c\": 0, \"b\": 0, \"a\": 0})\n>>> b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x00cq\\x01K\\x00X\\x01\\x00\\x00\\x00bq\\x02K\\x00X\\x01\\x00\\x00\\x00aq\\x03K\\x00u.'\n\n# ---------------\n# 反序列化loads\n# ---------------\nimport pickle\nprint(pickle.loads(b'\\x80\\x03]q\\x00(X\\x03\\x00\\x00\\x00fooq\\x01}q\\x02X\\x03\\x00\\x00\\x00barq\\x03(X\\x03\\x00\\x00\\x00bazq\\x04NG?\\xf0\\x00\\x00\\x00\\x00\\x00\\x00K\\x02tq\\x05se.'))\n>>> ['foo', {'bar': ['baz', None, 1.0, 2]}]\n\nprint(pickle.loads(b'\\x80\\x03X\\x07\\x00\\x00\\x00\"foo\\x08arq\\x00.'))\n>>> '\"foo\\x08ar'\n\n# ---------------\n# 序列化dump(文件)\n# ---------------\nimport pickle\ndic = {'k1':'v1','k2':'v2','k3':'v3'}\nwith open('pickle_file',mode='wb') as f:\n    dic_fd=pickle.dump(dic,f)\n# 文件中的内容：\n>>> 8003 7d71 0028 5802 0000 006b 3171 0158\n0200 0000 7631 7102 5802 0000 006b 3271\n0358 0200 0000 7632 7104 5802 0000 006b\n3371 0558 0200 0000 7633 7106 752e \n\n# ---------------\n# 反序列化load(文件)\n# ---------------\nimport pickle\nwith open('pickle_file',mode='rb') as f:\n    dic_fs=pickle.load(f)\nprint(dic_fs)\n>>> {'k1': 'v1', 'k3': 'v3', 'k2': 'v2'}\n\n```\n\n - marshal：Python 有一个更原始的序列化模块称为 marshal，但一般地 pickle 应该是序列化 Python 对象时的首选。marshal 存在主要是为了支持 Python 的 `.pyc` 文件.\n\n\n#### `Pickle` vs `Json` vs `Marshal`\n - `pickle` vs `json`\n  - pickle 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。marshal 不会这么做。\n  - 这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。pickle 只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。\n  - marshal 不能被用于序列化用户定义类及其实例。pickle 能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。\n  - 同样用于序列化的 marshal 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 .pyc 文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。pickle 序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python 3 之间跨越传递，封存和解封的代码在 2 和 3 之间也是不同的。\n\n - `pickle` vs `marshal`\n  - JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 utf-8 编码），而 pickle 是一个二进制序列化格式；\n  - JSON 是我们可以直观阅读的，而 pickle 不是；\n  - JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；\n  - 默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。\n  - 不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。\n\n\n---\n\n\n### hashlib模块\n#### hashlib模块介绍\n该模块为许多不同的安全哈希和消息摘要算法实现了一个通用接口。包括FIPS安全哈希算法SHA1，SHA224，SHA256，SHA384和SHA512以及RSA的MD5算法。术语“安全哈希”和“消息摘要”是等价的，旧称消息摘要，现在称安全哈希。\n\n#### hashlib的作用\n它通过一个函数，把任意长度的数据转换为一个长度固定的数据串，用以验证原始数据是否被篡改，保证数据的一致性。\n\n#### hashlib模块应用场景\n - 摘要算法\n - 密码的密文存储\n - 文件的一致性验证\n\n#### hashlib模块示例\n - MD5\n\n```python\nimport hashlib\n\n# 使用md5进行哈希\nmd5 = hashlib.md5()\nmd5.update(b'life is short')\nprint(md5.hexdigest())\n\n>>> 617d2b938b9b59b347b92f19f84436bd\n\n# 使用sha256进行哈希\nm = hashlib.sha256()\nm.update(b\"Nobody inspects\")\nm.update(b\" the spammish repetition\")\nm.digest()\n>>> b'\\x03\\x1e\\xdd}Ae\\x15\\x93\\xc5\\xfe\\\\\\x00o\\xa5u+7\\xfd\\xdf\\xf7\\xbcN\\x84:\\xa6\\xaf\\x0c\\x95\\x0fK\\x94\\x06'\n\n# 使用sha224进行哈希\nhashlib.sha224(b\"Nobody inspects the spammish repetition\").hexdigest()\n>>> 'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'\n```\n\n---\n\n\n### configparser模块\n#### configparser模块介绍\n该模块提供了ConfigParser类，该类实现了一种基本配置语言，该语言提供的结构类似于Microsoft Windows INI文件中的结构。您可以使用它来编写可由最终用户轻松定制的Python程序。\n\n#### configparser模块示例\n - 常见配置文档格式\n\n```python\n[DEFAULT]\nServerAliveInterval = 45\nCompression = yes\nCompressionLevel = 9\nForwardX11 = yes\n\n[bitbucket.org]\nUser = hg\n\n[topsecret.server.com]\nPort = 50022\nForwardX11 = no\n```\n\n - configparser创建Python配置文档\n\n```python\n# 使用configparser实现上述配置文件\n\nimport configparser\nconfig = configparser.ConfigParser()\nconfig['DEFAULT'] = {\n                        'ServerAliveInterval': '45',\n                        'Compression': 'yes',\n                        'CompressionLevel': '9'\n                    }\nconfig['bitbucket.org'] = {}\nconfig['bitbucket.org']['User'] = 'hg'\nconfig['topsecret.server.com'] = {}\ntopsecret = config['topsecret.server.com']\ntopsecret['Port'] = '50022'\ntopsecret['ForwardX11'] = 'no'\nconfig['DEFAULT']['ForwardX11'] = 'yes'\nwith open('example.ini', 'w') as configfile:\n    config.write(configfile)\n```\n\n - 增删改查CURD操作\n\n```python\n# --------\n# 增\n# --------\nimport configparser\n\n# 使用set方法增加配置\nconfig = configparser.ConfigParser()\nconfig.add_section('new_added')\nconfig.set('new_added','config_key_1','Value')\nconfig.write(open('sample_add.ini', \"w\"))\n\n# --------\n# 删\n# --------\nimport configparser\n\n# 使用remove_section/remove_option方法删除\nconfig = configparser.ConfigParser()\nconfig.read('sample.ini')\nconfig.remove_section('new_added')\nconfig.remove_option('new_added_2',\"config_key_2\")\nconfig.write(open('sample_del.ini', \"w\"))\n\n# --------\n# 改\n# --------\nimport configparser\n\n# 使用read读取，set方法进行覆盖修改操作\nconfig = configparser.ConfigParser()\nconfig.read('sample.ini')\nconfig.set('config_section_2','user','python')\nconfig.write(open('sample_modi.ini', \"w\"))\n\n# --------\n# 查\n# --------\nimport configparser\n\n# 类似于字典的方式进行查询操作\nconfig = configparser.ConfigParser()\nprint(config.sections())\n\nconfig.read('example.ini')\n\nprint(config.sections())\nprint('bitbucket.org' in config) # True\nprint(config['bitbucket.org'][\"user\"])\n\n```\n\n---\n\n\n### logging模块\n#### logging模块介绍\nlogging模块为应用与库定义了实现灵活的事件日志系统的函数与类。\n\n#### logging模块详解\n - 日志级别\n\n|级别|数值|\n|---|---|\n|CRITICAL|50|\n|ERROR|40|\n|WARNING|30|\n|INFO|20|\n|DEBUG|10|\n|NOTSET|0|\n\n - Log相关对象\n\n|对象类型|说明|\n|---|---|\n|Logger|日志，暴露函数给应用程序，基于日志记录器和过滤器级别决定哪些日志有效。|\n|LogRecord|日志记录器，将日志传到相应的处理器处理。|\n|Handler|处理器, 将(日志记录器产生的)日志记录发送至合适的目的地。|\n|Filter|过滤器, 提供了更好的粒度控制,它可以决定输出哪些日志记录。|\n|Formatter|格式化器, 指明了最终输出中日志记录的布局。|\n\n - basicConfig()方式\n\n```python\nimport logging\n\nlogging.basicConfig(filename=\"logging.log\", filemode=\"w\", format=\"%(asctime)s %(name)s:%(levelname)s:%(message)s\", datefmt=\"%d-%M-%Y %H:%M:%S\", level=logging.DEBUG)\nlogging.debug('This is a debug message')\nlogging.info('This is an info message')\nlogging.warning('This is a warning message')\nlogging.error('This is an error message')\nlogging.critical('This is a critical message')\n\n# 输出至logging.log文件中\n19-10-18 14:28:57 root:DEBUG:This is a debug message\n19-10-18 14:28:57 root:INFO:This is an info message\n19-10-18 14:28:57 root:WARNING:This is a warning message\n19-10-18 14:28:57 root:ERROR:This is an error message\n19-10-18 14:28:57 root:CRITICAL:This is a critical message\n\n```\n\n - logging对象方式：解决了basicconfig方式的中文支持问题和终端、文本同时输出的问题，推荐使用\n\n> 注意永远不要直接实例化Loggers，应当通过模块级别的函数 logging.getLogger(name)\n\n```python\n# 分别定义终端、文件中的日志输出级别，可以设置 Logger 对象为最低级别，之后设置两个不同级别的Handler 对象来实现。\n\nimport logging\nimport logging.handlers\n\nlogger = logging.getLogger(\"logger\")\n\nhandler_console = logging.StreamHandler()\nhandler_file = logging.FileHandler(filename=\"logging.log\")\n\nlogger.setLevel(logging.DEBUG)  # 级别为30\nhandler_console.setLevel(logging.WARNING)  # 级别为10\nhandler_file.setLevel(logging.DEBUG)  # 级别为30\n\nformatter = logging.Formatter(\"%(asctime)s %(name)s %(levelname)s %(message)s\")\nhandler_console.setFormatter(formatter)\nhandler_file.setFormatter(formatter)\n\nlogger.addHandler(handler_console)\nlogger.addHandler(handler_file)\n\n# print(handler1.level)  # 10\n# print(handler2.level)  # 30\n# print(logger.level)  # 30\n\nlogger.debug('This is a customer debug message')\nlogger.info('This is an customer info message')\nlogger.warning('This is a customer warning message')\nlogger.error('This is an customer error message')\nlogger.critical('This is a customer critical message')\n\n# 控制台输出结果\n2019-10-18 15:29:54,392 logger WARNING This is a customize warning message\n2019-10-18 15:29:54,392 logger ERROR This is an customize error message\n2019-10-18 15:29:54,392 logger CRITICAL This is a customize critical message\n\n# 文件输出结果\n2019-10-13 15:30:13,417 logger DEBUG This is a customize debug message\n2019-10-13 15:30:13,417 logger INFO This is an customize info message\n2019-10-13 15:30:13,417 logger WARNING This is a customize warning message\n2019-10-13 15:30:13,417 logger ERROR This is an customize error message\n2019-10-13 15:30:13,417 logger CRITICAL This is a customize critical message\n```\n\n---\n\n\n### pymysql模块\n#### pymysql模块介绍\n该软件包包含一个基于PEP 249的纯Python MySQL客户端库。\n\n#### pymysql模块使用示例\n - 版本要求 & 安装\n\n```python\n# 版本要求\nPython – one of the following:\n    CPython >= 2.7 or >= 3.5\n    Latest PyPy\nMySQL Server – one of the following:\n    MySQL >= 5.5\n    MariaDB >= 5.5\n\n# 安装\npython3 -m pip install PyMySQL\n```\n\n - 基本使用\n\n```python\n# 数据库插入数据\nCREATE TABLE `users` (\n    `id` int(11) NOT NULL AUTO_INCREMENT,\n    `email` varchar(255) COLLATE utf8_bin NOT NULL,\n    `password` varchar(255) COLLATE utf8_bin NOT NULL,\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin\nAUTO_INCREMENT=1 ;\n\n# 使用PyMySQL连接数据库\nimport pymysql.cursors\n\n# Connect to the database\nconnection = pymysql.connect(host='localhost',\n                             user='user',\n                             password='passwd',\n                             db='db',\n                             charset='utf8mb4',\n                             cursorclass=pymysql.cursors.DictCursor)\n\ntry:\n    with connection.cursor() as cursor:\n        # Create a new record\n        sql = \"INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)\"\n        cursor.execute(sql, ('webmaster@python.org', 'very-secret'))\n\n    # connection is not autocommit by default. So you must commit to save\n    # your changes.\n    connection.commit()\n\n    with connection.cursor() as cursor:\n        # Read a single record\n        sql = \"SELECT `id`, `password` FROM `users` WHERE `email`=%s\"\n        cursor.execute(sql, ('webmaster@python.org',))\n        result = cursor.fetchone()\n        print(result)\nfinally:\n    connection.close()\n\n# 输出\n{'password': 'very-secret', 'id': 1}\n\n```\n\n---\n\n### redis模块\n#### redis模块介绍\nRedis键值存储的Python接口。\n\n#### redis模块使用示例\n - 版本要求 & 安装\n\n```python\n# 版本要求\nredis-py 3.0 supports Python 2.7 and Python 3.5+.\n\n# 安装\npip install redis\n```\n\n - 基本使用\n\n```python\nimport redis\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nr.set('foo', 'bar')\n>>> True\n\nr.get('foo')\n>>> 'bar'\n```\n\n---\n\n### PyMongo模块\n#### PyMongo模块介绍\nPyMongo是一个Python发行版，其中包含用于MongoDB的工具，并且是从Python使用MongoDB的推荐方式。\n\n#### PyMongo模块使用示例\n - 版本要求 & 安装\n\n```python\n# 版本要求\nPyMongo supports MongoDB 2.6, 3.0, 3.2, 3.4, 3.6, 4.0 and 4.2.\nPyMongo supports CPython 2.7, 3.4+, PyPy, and PyPy3.5+.\n\n# 安装\npython -m pip install pymongo[snappy,gssapi,srv,tls,zstd]\n```\n\n - 基本使用\n\n```python\nimport pymongo\n\nclient = pymongo.MongoClient(\"localhost\", 27017)\ndb = client.test\ndb.name\n>>> u'test'\n\n\ndb.my_collection\n>>> Collection(Database(MongoClient('localhost', 27017), u'test'), u'my_collection')\n\n\ndb.my_collection.insert_one({\"x\": 10}).inserted_id\n>>> ObjectId('4aba15ebe23f6b53b0000000')\n\n\ndb.my_collection.insert_one({\"x\": 8}).inserted_id\n>>> ObjectId('4aba160ee23f6b543e000000')\n\n\ndb.my_collection.insert_one({\"x\": 11}).inserted_id\n>>> ObjectId('4aba160ee23f6b543e000002')\n\n\ndb.my_collection.find_one()\n>>> {u'x': 10, u'_id': ObjectId('4aba15ebe23f6b53b0000000')}\n\n\nfor item in db.my_collection.find():\n    print(item[\"x\"])\n>>> 10\n>>> 8\n>>> 11\n\n\ndb.my_collection.create_index(\"x\")\n>>> u'x_1'\n\n\nfor item in db.my_collection.find().sort(\"x\", pymongo.ASCENDING):\n    print(item[\"x\"])\n>>> 8\n>>> 10\n>>> 11\n\n\n[item[\"x\"] for item in db.my_collection.find().limit(2).skip(1)]\n>>> [8, 11]\n```\n\n\n","categories":["Python系列"]},{"title":"Python包","url":"/2020/04/14/Python包/","content":"\n## 包\n### 概念\n包是一种通过使用`.模块名`来组织python模块名称空间的方式。\n\n### 导入包的本质\nimport 包，产生的名称空间的名字同样来源于文件，即包下的`__init__.py`文件，导入包本质就是在导入该文件\n\n### 注意事项\n - 在导入语句中包含有`.`，说明是包导入。\n - 包是目录级的，包是一种包含`__init__.py`文件的目录。\n - import导入文件时，产生名称空间中的名字来源于文件；import导入包，产生的名称空间的名字同样来源于文件，即包下的`__init__.py`文件，导入包本质就是在导入该文件。\n - 在python3中，即使包下没有`__init__.py`文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import导入包报错。\n - 创建包的目的不是为了运行，而是被导入使用，包只是模块的一种形式而已，包即模块。\n - 凡是在导入时带`.`的，`.`的左边都必须是一个包，否则非法。可以带有一连串的`.`,但都必须遵循这个原则。\n - 对于导入包之后，`.`的左边可以是包,模块，函数，类等,它们都可以用`.`的方式调用自己的属性。\n - 对比`import item` 和`from item import name`，如果想直接使用`name`则必须使用后者的导入方式。\n\n\n### 包的使用\n#### import用法\n\n```python\n# 测试python文件与包同目录\n\nimport package.nextpackage.models\npackage.nextpackage.models.models_function('func_1') \n```\n\n#### from ... import ...用法\n\n```python\n# 注意：from ... import ... 中import后面必须是类、方法等，且不能包含点(.)\n\n# 测试python文件与包同目录\n# 1、导入某个模块\nfrom package.nextpackage import models\nmodels.models_function('func_1')\n\n# 2、导入模块中的某个方法\nfrom package.nextpackage.models import models_function\nmodels_function('func_1')\n```\n\n#### `__init__.py`文件\n不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的`__init__.py`文件，这个文件可以为空，也可以进行一些初始化的工作。\n\n\n#### `from ... import *`用法\n - `from ... import *`意在导入包中所有类、方法等，实际上该语句只会导入包下`__init__.py`文件中定义的名字，我们可以在这个文件中定义`__all__`变量\n\n\n#### 绝对导入和相对导入\n - 绝对导入：以项目根路径作为起始\n - 相对导入：用`.`或者`..`的方式最为起始（只能在一个包中使用，不能用于不同目录内）\n\n```python\n# 文件路径\npackage/nextpackage/models.py\n\n\n# 绝对导入\nfrom package.nextpackage import models\nmodels.models_function()\n\n# 相对导入\nfrom ..nextpackage import models\nmodels.models_function()\n```\n\n#### 单独导入包\n - 单独导入包名称时不会导入包中所有包含的所有子模块\n\n```python\n# 测试python文件与包同目录，在py程序中直接引入方法\nimport package\npackage.nextpackage.models.models_function()\n# 输出报错\n>>> AttributeError: module 'package' has no attribute 'nextpackage'\n\n# 解决方法\n#package/__init__.py\nfrom . import nextpackage\n\n#package/nextpackage/__init__.py\nfrom . import models\n\n# 执行结果\n# 测试python文件与包同目录\nimport package\npackage.nextpackage.models.models_function()\n```\n\n\n\n\n","categories":["Python系列"]},{"title":"Python模块","url":"/2020/04/07/Python模块/","content":"\n## 模块\n\n### 什么是模块\n - 已经被编译为共享库或DLL的C/C++扩展\n - 使用C编写并链接到python解释器的内置模块\n\n### 意义\n - 模块的意义在于方便功能的复用，在系统以及\n\n### 模块导入规范\n - 导入的内置模块应该写在前面：内置模块 -> 扩展模块 -> 自定义模块\n - 模块不会被重复导入\n - 模块导入的根路径: sys.path\n - import用法\n\n```python\n# 1、import 模块名\n\n# 2、import 模块名.变量名：与代码文件中的变量名完全不冲突\n\n# 3、import 模块名 as 重命名的模块名：提高代码的兼容性\n\n# 4、import 模块1，模块2\n\n```\n\n - `from ... import ...`\n\n```python\n# 1、from 模块名 import 变量名\n  - 直接使用 变量名 就可以完成操作\n  - 如果代码文件中有相同的变量名会发生冲突\n\n# 2、from 模块名 import 变量名字 as 重命名变量名\n\n# 3、from 模块名 import 变量名1，变量名2\n\n# 4、from 模块名 import *\n - 将模块中的所有变量名都放到内存中\n - 如果代码文件中有相同的变量名会发生冲突\n\n# 5、from 模块名 import * 和 __all__变量搭配使用\n - 如果没有__all__变量，就会导入该模块的所有变量名\n - 如果有__all__变量则只导入__all__变量列表中的名字\n```\n\n - `__name__`\n\n```python\n# 1、在模块中 有一个变量__name__，\n# 2、当我们直接执行这个模块的时候，__name__ == '__main__'\n# 3、当我们执行其他模块，在其他模块中引用这个模块的时候，这个模块中的__name__ == '模块的名字'\n```","categories":["Python系列"]},{"title":"Python迭代器&生成器","url":"/2020/03/28/Python迭代器&生成器/","content":"\n\n### 可迭代对象\n#### 概念\n内部实现了`__iter__()`方法\n\n#### 验证方法\n - 使用dir()方法查看数据类型中的方法是否包含`__iter__()`\n\n#### 作用\n - 可迭代对象执行`__iter__()`方法后会生成一个迭代器对象\n\n#### 标识\n - 拥有`__iter__()`方法的对象 \n\n#### 示例\n\n```python\ns = 'abc' # 可迭代对象\nit = iter(s) # 调用迭代方法，等同于 s.__iter__()\n\nprint(it)\n\n# 输出\n<str_iterator object at 0x7f0234b10eb8>\n```\n\n---\n\n### 迭代器\n#### 概念\n迭代器是一个有状态的对象，它能在调用next()方法的时候返回容器中的下一个值，任何实现了`__iter__()`和`__next__()`方法的对象都是迭代器，`__iter__`返回迭代器自身，`__next__`返回容器中的下一个值，如果容器中没有下一个值则抛出`StopIteration`异常。\n\n#### 迭代器 vs 可迭代对象区别\n - 迭代器拥有`__length_hint__`: 获取迭代器中元素的长度 \n\n - 迭代器拥有`__setstate__`: 根据索引值指定从哪里开始迭代\n\n - 迭代器拥有`__next__`: 获取迭代器对象的下一个值\n\n#### 标识\n - 拥有`__iter__()`和`__next__()`方法的对象 \n\n#### 示例\n\n```python\ns = 'abc'\nit = iter(s)\nprint(it) # 输出迭代器对象\n\nprint(next(it)) # 输出'a'\nprint(next(it)) # 输出'b'\nprint(next(it)) # 输出'c'\nprint(next(it)) # 没有下一个值，抛出StopIteration异常\n\n# 输出\n<str_iterator object at 0x7fbe85382f60>\na\nb\nc\nTraceback (most recent call last):\n  File \"main.py\", line 9, in <module>\n    print(next(it))\nStopIteration\n```\n\n---\n\n### 生成器（本质是迭代器）\n#### 概念\n生成器是一种特殊的迭代器，它用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用`yield`语句。 每次对生成器调用`next()`时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。\n\n#### 特点\n - 惰性运算，开发者自定义\n - 本质是迭代器\n\n#### 应用\n - 生成器函数\n一个包含`yield`关键字的函数就是一个生成器函数。`yield`可以为我们从函数中返回值，但是`yield`又不同于`return`，`return`的执行意味着程序的结束，调用生成器函数不会得到返回的具体的值，而是得到一个可迭代的对象。每一次获取这个可迭代对象的值，就能推动函数的执行，获取新的返回值。直到函数执行结束。\n\n - 生成器函数进阶：`send()`\n  - send和next的作用相同\n  - 第一次不能用send\n  - 函数中的最后一个yield不能接受新的值\n\n - 生成器表达式\n类似于列表推导，但是生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。\n\n#### 示例\n - 简单应用\n\n```python\nimport time\ndef genrator_fun1():\n    a = 1\n    print('现在定义了a变量')\n    yield a\n    b = 2\n    print('现在又定义了b变量')\n    yield b\n\ng1 = genrator_fun1()\nprint('g1 : ',g1) #打印g1可以发现g1就是一个生成器\nprint('-'*20) #我是华丽的分割线\nprint(next(g1))\ntime.sleep(1) #sleep一秒看清执行过程\nprint(next(g1))\n```\n\n - 避免一次性读取数据到内存中导致内存溢出\n\n```python\nimport time\ndef tail(filename):\n    f = open(filename)\n    f.seek(0, 2) #从文件末尾算起\n    while True:\n        line = f.readline() # 读取文件中新的文本行\n        if not line:\n            time.sleep(0.1)\n            continue\n        yield line\n\ntail_g = tail('tmp')\nfor line in tail_g:\n    print(line)\n```\n\n - yield from\n\n```python\ndef gen1():\n    for c in 'AB':\n        yield c\n    for i in range(3):\n        yield i\nprint(list(gen1()))\n\n以上是将生成器中的数据以列表的方式打印\n以下的执行效果与上面相同，运用了yield from 语法\ndef gen2():\n    yield from 'AB'\n    yield from range(3)\n\nprint(list(gen2()))\n```\n\n - 生成器函数进阶：`send()`\n\n```python\n# 计算移动平均值的例子\ndef average():\n    sum = 0\n    count = 0\n    avg = 0\n    while True:\n        num = yield avg\n        sum += num\n        count += 1\n        avg = sum / count\n\navg_g = average()\navg_g.__next__()\n\nprint(avg_g.send(20))\nprint(avg_g.send(40))\nprint(avg_g.send(60))\n```\n\n - 预激生成器的装饰器\n\n```python\n# 预激生成器的装饰器——在装饰器中首先调用了__next__方法，方便用户直接进行调用\ndef init(func):\n    def wrapper(*args,**kwargs):\n        g = func(*args,**kwargs)\n        g.__next__()\n        return g\n    return wrapper\n\n@init\ndef average():\n    sum,avg,count = 0,0,0\n    while True:\n        num = yield avg\n        sum += num\n        count += 1\n        avg = sum/count\n\navg_g = average()\nprint(avg_g.send(10))\nprint(avg_g.send(20))\nprint(avg_g.send(30))\n```\n\n - 推导式汇总\n\n```python\n\n# -------------列表推导-------------\n'''\n[每一个元素或者是和元素相关的操作 for 元素 in 可迭代数据类型] #遍历之后挨个处理\n[满足条件的元素相关的操作 for 元素 in 可迭代数据类型 if 元素相关的条件] #筛选功能\n'''\n# -------------简单的列表推导-------------\nl = [i ** 3 for i in range(10)]\nprint(l)\n>>> [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n\n# -------------带筛选的列表推导-------------\nl = [i ** 3 for i in range(10) if i % 3 == 0]\nprint(l)\n>>> [0, 27, 216, 729]\n\n# -------------多层列表推导-------------\ndouble_l = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'],\n            ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]\nl = [name for lst in double_l for name in lst if name.count('e') >= 2]\nprint(l)\n>>> ['Jefferson', 'Wesley', 'Steven', 'Jennifer']\n\n\n# -------------字典推导-------------\n\n# 例一：将一个字典的key和value对调\nmcase = {'a': 10, 'b': 34}\nmcase_frequency = {mcase[k]: k for k in mcase}\nprint(mcase_frequency)\n>>> {34: 'b', 10: 'a'}\n\n# 例二：合并大小写对应的value值，将k统一成小写\nmcase = {'a': 10, 'b': 34, 'A': 7, 'Z': 3}\nmcase_frequency = {k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()}\nprint(mcase_frequency)\n>>> {'b': 34, 'a': 17, 'z': 3}\n\n\n# -------------集合推导-------------\n\n# 计算列表中每个值的平方，自带去重功能\nsquared = {x ** 2 for x in [1, -1, 2]}\nprint(squared)\n>>> {1, 4}\n\n```\n\n---\n\n### 关系图\n![](/images/post_imgs/iterator.png)\n\n\n\n\n","categories":["Python系列"]},{"title":"Python闭包&装饰器","url":"/2020/03/14/Python闭包&装饰器/","content":"\n\n## 闭包 & 装饰器\n### 开放封闭原则\n - 开放：对于添加新功能是开放的\n - 封闭：对于修改原功能是封闭的\n\n### 闭包\n\n#### 概念\n内部函数包含对外部作用域而非全剧作用域变量的引用，则称该内部函数称为闭包函数。\n\n#### 判断方法\n输出的`__closure__`是否有cell元素\n\n#### 作用\n - 为函数增加功能\n - 为函数提前赋值\n\n#### 示例\n```python\ndef foo():\n    x = 1\n    def bar(y):\n        return x+y\n    return bar\n```\n\n---\n\n### 装饰器（闭包应用）\n#### 作用\n在不更改原函数调用方式的前提下对原函数添加新功能\n\n#### 原理\n利用闭包原理，通过在内部函数中调用外部函数的变量，实现在不改变原函数调用方式的前提下对原函数添加新功能。\n\n#### 种类\n - 简单装饰器\n\n```python\ndef deco(f):\n    def wrapper():\n        \"\"\"原函数前添加的功能\"\"\"\n        f()\n        \"\"\"原函数后添加的功能\"\"\"\n    return wrapper\n\ndef func():\n    print('这是原函数！')\n\nfunc = deco(func)\nfunc()\n```\n\n - 装饰器的语法糖\n\n```python\ndef deco(f):\n    def wrapper():\n        \"\"\"原函数前添加的功能\"\"\"\n        f()\n        \"\"\"原函数后添加的功能\"\"\"\n    return wrapper\n\n@deco # ——>此处效果等同于 func = deco(func)\ndef func():\n    print('这是原函数')\n\nfunc()\n```\n\n - 带返回值的装饰器\n\n```python\ndef deco(f):\n    def wrapper():\n        \"\"\"原函数前添加的功能\"\"\"\n        res = f()\n        \"\"\"原函数后添加的功能\"\"\"\n        return res\n    return wrapper\n\n@deco\ndef func():\n    print('这是原函数')\n\nfunc()\n```\n \n - 带参数、带返回值的装饰器（标准格式）\n\n```python\ndef deco(f):\n    def wrapper(*args,**kwargs):\n        \"\"\"原函数前添加的功能\"\"\"\n        res = f(*args,**kwargs)\n        \"\"\"原函数后添加的功能\"\"\"\n        return res\n    return wrapper\n\n@deco\ndef func(*args,**kwargs):\n    print('这是原函数')\n\nfunc(*args,**kwargs)\n```\n\n - 多层装饰器\n\n```python\ndef deco(f):\n    def outer_wrapper(*args,**kwargs):\n        def inner_wrapper(*args,**kwargs):\n            \"\"\"原函数前添加的功能\"\"\"\n            res = f(*args,**kwargs)\n            \"\"\"原函数后添加的功能\"\"\"\n            return res\n        return inner_wrapper\n    return outer_wrapper\n\n@deco\ndef func(*args,**kwargs):\n    print('这是原函数')\n\nfunc(*args,**kwargs)\n```\n\n - 多个装饰器修饰同一个函数\n\n```python\ndef deco1(f):\n    def wrapper(*args,**kwargs):\n        \"\"\"原函数前添加的功能\"\"\"\n        res = f(*args,**kwargs)\n        \"\"\"原函数后添加的功能\"\"\"\n        return res\n    return wrapper\n\ndef deco2(f):\n    def wrapper(*args,**kwargs):\n        \"\"\"原函数前添加的功能\"\"\"\n        res = f(*args,**kwargs)\n        \"\"\"原函数后添加的功能\"\"\"\n        return res\n    return wrapper\n\n@deco1  # 其次执行\n@deco2  # 首先执行\ndef func(*args,**kwargs):\n    print('这是原函数')\n\nfunc(*args,**kwargs)\n```\n\n - 装饰器wraps版本（标准格式）\n\n```python\nfrom functools import wraps\n\ndef deco(func):\n    @wraps(func) #加在最内层函数正上方\n    def wrapper(*args,**kwargs):\n        return func(*args,**kwargs)\n    return wrapper\n\n@deco\ndef origin_func():\n    '''\n    这是原函数的注释\n    :return:\n    '''\n    print('这是原函数')\n\n# 虽然已经执行了装饰器，origin_func已经指向wrapper，但是如果用了@wraps(func)装饰器之后调用origin_func的双下划线方法依然是原函数origin_func的\nprint(origin_func.__name__)\n>>> origin_func\n\nprint(origin_func.__doc__)\n>>> 这是原函数的注释\n>>> :return:\n```","categories":["Python系列"]},{"title":"Python各种函数","url":"/2020/03/14/Python各种函数/","content":"\n\n## 各种函数\n\n### 内置函数\n#### 内置函数概念\n内置函数就是Python解释器已经写好可以提供给用户直接使用的函数。目前Python的内置函数一共是69个。\n\n#### Python内置函数\n\n| | |内置函数 | | |\n| :---: | :---: | :---: | :---: | :---: |\n| [abs()](https://docs.python.org/zh-cn/3.8/library/functions.html#abs \"abs\") | [delattr()](https://docs.python.org/zh-cn/3.8/library/functions.html#delattr \"delattr\") | [hash()](https://docs.python.org/zh-cn/3.8/library/functions.html#hash \"hash\") | [memoryview()](https://docs.python.org/zh-cn/3.8/library/functions.html#func-memoryview) | [set()](https://docs.python.org/zh-cn/3.8/library/functions.html#func-set) |\n| [all()](https://docs.python.org/zh-cn/3.8/library/functions.html#all \"all\") | [dict()](https://docs.python.org/zh-cn/3.8/library/functions.html#func-dict) | [help()](https://docs.python.org/zh-cn/3.8/library/functions.html#help \"help\") | [min()](https://docs.python.org/zh-cn/3.8/library/functions.html#min \"min\") | [setattr()](https://docs.python.org/zh-cn/3.8/library/functions.html#setattr \"setattr\") |\n| [any()](https://docs.python.org/zh-cn/3/library/functions.html?#any \"any\") | [dir()](https://docs.python.org/zh-cn/3/library/functions.html?#dir \"dir\") | [hex()](https://docs.python.org/zh-cn/3/library/functions.html?#hex \"hex\") | [next()](https://docs.python.org/zh-cn/3/library/functions.html?#next \"next\") | [slice()](https://docs.python.org/zh-cn/3/library/functions.html?#slice \"slice\") |\n| [ascii()](https://docs.python.org/zh-cn/3/library/functions.html?#ascii \"ascii\") | [divmod()](https://docs.python.org/zh-cn/3/library/functions.html?#divmod \"divmod\") | [id()](https://docs.python.org/zh-cn/3/library/functions.html?#id \"id\") | [object()](https://docs.python.org/zh-cn/3/library/functions.html?#object \"object\") | [sorted()](https://docs.python.org/zh-cn/3/library/functions.html?#sorted \"sorted\") |\n| [bin()](https://docs.python.org/zh-cn/3/library/functions.html?#bin \"bin\") | [enumerate()](https://docs.python.org/zh-cn/3/library/functions.html?#enumerate \"enumerate\") | [input()](https://docs.python.org/zh-cn/3/library/functions.html?#input \"input\") | [oct()](https://docs.python.org/zh-cn/3/library/functions.html?#oct \"oct\")  | [staticmethod()](https://docs.python.org/zh-cn/3/library/functions.html?#staticmethod \"staticmethod\") |\n| [bool()](https://docs.python.org/zh-cn/3/library/functions.html?#bool \"bool\") | [eval()](https://docs.python.org/zh-cn/3/library/functions.html?#eval \"eval\") | [int()](https://docs.python.org/zh-cn/3/library/functions.html?#int \"int\") | [open()](https://docs.python.org/zh-cn/3/library/functions.html?#open \"open\") | [str()](https://docs.python.org/zh-cn/3/library/functions.html?#func-str) |\n| [breakpoint()](https://docs.python.org/zh-cn/3/library/functions.html?#breakpoint \"breakpoint\") | [exec()](https://docs.python.org/zh-cn/3/library/functions.html?#exec \"exec\") | [isinstance()](https://docs.python.org/zh-cn/3/library/functions.html?#isinstance \"isinstance\") | [ord()](https://docs.python.org/zh-cn/3/library/functions.html?#ord \"ord\") | [sum()](https://docs.python.org/zh-cn/3/library/functions.html?#sum \"sum\") |\n| [bytearray()](https://docs.python.org/zh-cn/3/library/functions.html?#func-bytearray) | [filter()](https://docs.python.org/zh-cn/3/library/functions.html?#filter \"filter\") | [issubclass()](https://docs.python.org/zh-cn/3/library/functions.html?#issubclass \"issubclass\") | [pow()](https://docs.python.org/zh-cn/3/library/functions.html?#pow \"pow\") | [super()](https://docs.python.org/zh-cn/3/library/functions.html?#super \"super\") |\n| [bytes()](https://docs.python.org/zh-cn/3/library/functions.html?#func-bytes) | [float()](https://docs.python.org/zh-cn/3/library/functions.html?#float \"float\") | [iter()](https://docs.python.org/zh-cn/3/library/functions.html?#iter \"iter\") | [print()](https://docs.python.org/zh-cn/3/library/functions.html?#print \"print\") | [tuple()](https://docs.python.org/zh-cn/3/library/functions.html?#func-tuple) |\n| [callable()](https://docs.python.org/zh-cn/3/library/functions.html?#callable \"callable\") | [format()](https://docs.python.org/zh-cn/3/library/functions.html?#format \"format\") | [len()](https://docs.python.org/zh-cn/3/library/functions.html?#len \"len\") | [property()](https://docs.python.org/zh-cn/3/library/functions.html?#property \"property\") | [type()](https://docs.python.org/zh-cn/3/library/functions.html?#type \"type\") |\n| [chr()](https://docs.python.org/zh-cn/3/library/functions.html?#chr \"chr\") | [frozenset()](https://docs.python.org/zh-cn/3/library/functions.html?#func-frozenset) | [list()](https://docs.python.org/zh-cn/3/library/functions.html?#func-list) | [range()](https://docs.python.org/zh-cn/3/library/functions.html?#func-range) | [vars()](https://docs.python.org/zh-cn/3/library/functions.html?#vars \"vars\") |\n| [classmethod()](https://docs.python.org/zh-cn/3/library/functions.html?#classmethod \"classmethod\") | [getattr()](https://docs.python.org/zh-cn/3/library/functions.html?#getattr \"getattr\") | [locals()](https://docs.python.org/zh-cn/3/library/functions.html?#locals \"locals\") | [repr()](https://docs.python.org/zh-cn/3/library/functions.html?#repr \"repr\") | [zip()](https://docs.python.org/zh-cn/3/library/functions.html?#zip \"zip\") |\n| [compile()](https://docs.python.org/zh-cn/3/library/functions.html?#compile \"compile\") | [globals()](https://docs.python.org/zh-cn/3/library/functions.html?#globals \"globals\") | [map()](https://docs.python.org/zh-cn/3/library/functions.html?#map \"map\") | [reversed()](https://docs.python.org/zh-cn/3/library/functions.html?#reversed \"reversed\") | [\\_\\_import\\_\\_()](https://docs.python.org/zh-cn/3/library/functions.html?#__import__ \"__import__\") |\n| [complex()](https://docs.python.org/zh-cn/3/library/functions.html?#complex \"complex\") | [hasattr()](https://docs.python.org/zh-cn/3/library/functions.html?#hasattr \"hasattr\") | [max()](https://docs.python.org/zh-cn/3/library/functions.html?#max \"max\") | [round()](https://docs.python.org/zh-cn/3/library/functions.html?#round \"round\")  | |\n\n#### 内置函数分类\n - 数据类型相关\n\n```python\n# 一、基础数据类型\nbool(): 用于将给定参数转换为布尔类型，如果没有参数，返回 False。\nint(): 用于将一个字符串或数字转换为整型。\nfloat(): 用于将整数和字符串转换成浮点数。\ncomplex(): 用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数\nstr(): 将对象转化为字符串形式\nlist(): 用于将元组转换为列表。\ntuple(): 将列表转换为元组。\ndict(): 用于创建一个字典\nset(): 用于创建一个集合\nfrozenset(): 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素\n\n\n# 二、进制转换\nbin(): 返回一个整数 int 或者长整数 long int 的二进制表示。\noct(): 将一个整数转换成8进制字符串。\nhex(): 于将10进制整数转换成16进制，以字符串形式表示。\n\n\n# 三、数学运算\nabs(): 返回数字的绝对值。\ndivmod(): 把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)\nmin(): 返回给定参数的最小值，参数可以为序列\nmax(): 返回给定参数的最大值，参数可以为序列\nsum(): 对可迭代对象进行求和计算\nround(): 返回浮点数的四舍六入五留双\npow(): 返回 xy（x的y次方）的值\n\n\n# 四、字符串操作\nascii(): 类似 repr() 函数, 返回一个表示对象的字符串\nord(): 以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值\nchr(): 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符\nformat(): 格式化编辑字符串\nrepr(): 将对象转化为供解释器读取的形式\n\n\n# 五、序列操作（包含二进制序列）\nbytes(): 返回一个新的数组对象，这个数组对象不能对数组元素进行修改。\nbytearray(): 返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围:\nmemoryview(): 返回给定参数的内存查看对象(Momory view)。\nreversed(): 反转一个序列对象，将其元素从后向前颠倒构建成一个新的迭代器\nslice(): 实现切片对象，主要用在切片操作函数里的参数传递\n\n\n# 六、功能性方法\nlen(): 返回对象（字符、列表、元组等）长度或项目个数。\nsorted(): 对所有可迭代的对象进行排序操作；内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\nenumerate(): 用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\nall(): 用于判断给定的可迭代参数 iterable 中的所有元素是否不为 0、''、False 或者 iterable 为空，如果是返回 True，否则返回 False。\nany(): 用于判断给定的可迭代参数 iterable 是否全部为空对象，如果都为空、0、false，则返回 False，如果不都为空、0、false，则返回 True。\nzip(): 用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\nfilter(): 用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。\nmap(): 根据提供的函数对指定序列做映射。\n```\n\n\n - 作用域相关\n\n```python\nglobals(): 获取全局变量的字典。\nlocals(): 获取执行本方法所在命名空间内的局部变量的字典。\n```\n\n\n - 迭代器、生成器相关\n\n```python\nrange(): 创建一个整数列表，一般用在 for 循环中。\nnext(): 调用可迭代对象或迭代器的next方法，取到一个元素。\niter(): 将可迭代对象转化称迭代器。\n```\n\n\n - 面向对象相关\n\n```python\n# 一、对象\nobject(): 返回一个没有特征的新对象。object 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。\nid(): 返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。\nhash(): 返回该对象的哈希值（如果它有的话）。\nopen(): 打开 file 并返回对应的 file object。\ncallable(): 如果参数 object 是可调用的就返回 True，否则返回 False。 \ntype(): 传入一个参数时，返回 object 的类型。 返回值是一个 type 对象，通常与 object.__class__ 所返回的对象相同。\n\n# 二、类\nclassmethod(): 把一个方法封装成类方法。一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。\nstaticmethod(): 将方法转换为静态方法。静态方法不会接收隐式的第一个参数。\nisinstance(): 如果参数 object 是参数 classinfo 的实例或者是其 (直接、间接或 虚拟) 子类则返回 True。 如果 object 不是给定类型的对象，函数将总是返回 False。 \nissubclass(): 如果 class 是 classinfo 的 (直接、间接或 虚拟) 子类则返回 True。 \nsuper(): 返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。\nproperty(): 返回 property 属性。fget 是获取属性值的函数。 fset 是用于设置属性值的函数。 fdel 是用于删除属性值的函数。并且 doc 为属性对象创建文档字符串。\nvars(): 返回模块、类、实例或任何其它具有 __dict__ 属性的对象的 __dict__ 属性。\n```\n\n\n\n - 反射相关\n\n```python\nhasattr(): 该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 True，否则返回 False。\nsetattr(): 此函数与 getattr() 两相对应。 其参数为一个对象、一个字符串和一个任意值。 字符串指定一个现有属性或者新增属性。 函数会将值赋给该属性，只要对象允许这种操作。 \ngetattr(): 返回对象命名属性的值。name 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。\ndelattr(): setattr() 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。\n```\n\n\n - 代码执行\n\n```python\neval(): 数据字符串形式的表达式，python解释器可以直接执行。\nexec(): 这个函数支持动态执行 Python 代码。object 必须是字符串或者代码对象。\ncompile(): 将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。\n```\n\n - 其他\n\n```python\nhelp(): 启动内置的帮助系统（此函数主要在交互式中使用）。\nprint(): 将 objects 打印到 file 指定的文本流，以 sep 分隔并在末尾加上 end。 \ninput(): 如果存在 prompt 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。\ndir(): 如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。\nbreakpoint(): 此函数会在调用时将你陷入调试器中。（3.7 新版功能）\n__import__(): 此函数会由 import 语句发起调用。（不建议使用）\n```\n\n---\n\n### 自定义函数\n#### 定义函数的流程\n - 函数定义\n关键字`def`引入一个函数定义。\n它必须后跟函数名称和带括号的形式参数列表。\n构成函数体的语句从下一行开始，并且必须缩进。\n\n - 函数体\n函数体的第一个语句可以（可选的）是字符串文字；\n这个字符串文字是函数的文档字符串或 docstring 。\n有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；\n在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。\n\n - 函数执行\n函数的执行会引入一个用于函数局部变量的新符号表。\n更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。\n因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 global 语句中定义的全局变量，或者是在 nonlocal 语句中定义的外层函数的变量），尽管它们可以被引用。\n\n - 函数调用\n在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；\n因此，实参是通过按值调用传递的（其中值始终是对象 引用而不是对象的值）。\n当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。\n\n - 函数的使用\n函数定义会把函数名引入当前的符号表中。\n函数名称的值具有解释器将其识别为用户定义函数的类型。\n这个值可以分配给另一个名称，该名称也可以作为一个函数使用。\n\n - 函数返回值\n事实上，即使没有 return 语句的函数也会返回一个值, 称为 None（内置名称）。\n\n#### 定义函数举例\n\n```python\n# write Fibonacci series up to n\n>>> def fib(n):\n...     \"\"\"Print a Fibonacci series up to n.\"\"\"\n...     a, b = 0, 1\n...     while a < n:\n...         print(a, end=' ')\n...         a, b = b, a+b\n...     print()\n...\n>>> # Now call the function we just defined:\n... fib(2000)\n\n# return\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n```\n\n---\n\n### 嵌套函数\n#### 概念\n嵌套函数（Nested function）是在另一个函数（封闭函数）中定义的函数。\n\n#### 原理依据\n函数属于一类对象。在一个函数内部执行的`def`语句会定义一个局部函数并可被返回或传递。在嵌套函数中使用的自由变量可以访问包含该`def`语句的函数的局部变量。\n\n#### 示例\n\n```python\n>>> def foo():\n...     x=1\n...     def bar():\n...         y=2\n...         print x+y\n...     bar()\n```\n\n#### 总结\n - python支持嵌套函数。\n - 内层函数可以访问外层函数中定义的变量，但不能重新赋值。\n - 内层函数的local namespace不包含外层函数定义的变量。\n\n---\n\n### 递归函数\n#### 基本概念\n - 递归函数就是函数里调用其自身。\n - 递归函数必须有一个明确的递归结束条件，称之为递归出口，否则递归深度过深会发生堆栈溢出。\n - 递归的最大深度在python中也有限制，可以通过`sys.setrecursionlimit()`函数进行调整，除非很清楚应如何调整，否则不建议修改默认的最大递归深度。\n\n#### 递归函数示例\n\n```python\n# 实现阶乘：n! = 1 × 2 × 3 × … × n，或n! = (n-1)! × n\n\n# ----------迭代的实现方式----------\n>>> def factorial(n):\n...     result = 1\n...     for i in range(2, n+1):\n...         result *= i\n...     return result\n... \n\n>>> factorial(1)\n1\n>>> factorial(5)\n120\n>>> factorial(10)\n3628800\n\n# ----------递归的实现方式----------\n>>> def factorial(n):\n...     if n == 1:\n...         return 1\n...     else:\n...         return n * factorial(n - 1)\n... \n\n>>> factorial(1)\n1\n>>> factorial(5)\n120\n>>> factorial(10)\n3628800\n```\n\n#### 其他说明\n - 理论上，所有的递归函数都可以写成循环的方式。\n - 解决递归调用栈溢出的方法是通过尾递归优化。尾递归是指在函数返回的时候，调用其自身，并且return语句不能包含表达式。这样解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n\n\n---\n\n### 匿名函数 Lambda\n#### 基本概念\n可以用lambda关键字来创建匿名函数。Lambda函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量。\n\n#### Lambda函数语法\n`函数名 = lambda 参数 ：返回值`\n#### 示例\n\n```python\n# ----------示例一----------\n# lambda表达式来返回一个函数\n\n>>> def make_incrementor(n):\n...     return lambda x: x + n\n...\n>>> f = make_incrementor(42)\n>>> f(0)\n42\n>>> f(1)\n43\n\n# ----------示例二----------\n# 传递一个函数作为参数\n\n>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n>>> pairs.sort(key=lambda pair: pair[1])\n>>> pairs\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n```\n\n---\n\n### 高阶函数\n#### 基本概念\n函数的形参接受另外一个函数的函数名，则称这个函数为高阶函数。\n\n#### 示例\n\n```python\n>>> def add(x, y, f):\n...     return f(x) + f(y)\n\n>>> print(add(-5, 6, abs))\n\n# return\n11\n```\n\n#### 常用的高阶函数\n```python\n1、filter()\n功能：用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。\n调用：filter（function，sequence）\n示例：\n# 找出偶数\n>>> x = [1, 2, 3, 4, 5]\n>>> list(filter(lambda x:x%2 == 0,x)) \n\n# return\n[2, 4]\n\n\n2、map()\n功能：返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。\n调用：map(function, iterable, ...)\n示例：\n# 计算列表各个元素的平方\n>>> del square(x):\n...     return x ** 2\n \n>>> map(square,[1,2,3,4,5])\n \n# return\n[1,4,9,16,25]\n\n\n3、reduce()\n功能：将两个参数的 function 从左至右积累地应用到 iterable 的条目，以便将该可迭代对象缩减为单一的值。\n调用：functools.reduce(function, iterable[, initializer])\n示例：\n# 计算列表和\n>>> def add(x, y): \n...     return x + y\n... \n>>> reduce(add, [1,2,3,4,5])\n\n# return\n15\n```\n\n---\n\n### 偏函数\n#### 基本概念\n - 返回一个新的部分对象，当被调用时其行为类似于func附带位置参数args和关键字参数keywords被调用。 如果为调用提供了更多的参数，它们会被附加到args。如果提供了额外的关键字参数，它们会扩展并重载keywords。\n - 偏函数是将所要承载的函数作为partial()函数的第一个参数，原函数的各个参数依次作为partial()函数后续的参数，除非使用关键字参数。\n\n#### 示例\n\n```python\n# ----------无关键字参数----------\n>>> from functools import partial\n\n>>> def mod( n, m ):\n...     return n % m\n \n>>> mod_by_100 = partial( mod, 100 )\n>>> print mod(100, 7)\n# return\n2\n>>> print mod_by_100(7)\n# return\n2\n\n# ----------有关键字参数----------\n>>> from functools import partial\n \n>>> bin2dec = partial( int, base=2 )\n>>> print bin2dec( '0b10001' )\n# return\n17\n>>> print bin2dec( '10001' )\n# return\n17\n>>> hex2dec = partial( int, base=16 )\n>>> print hex2dec( '0x67' )\n# return\n103\n>>> print hex2dec( '67' )\n# return\n103\n\n```\n","categories":["Python系列"]},{"title":"Python初识函数","url":"/2020/02/26/Python初识函数/","content":"\n\n## 初识函数\n\n### 函数的概念\nwiki百科中解释：函数是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。\n简而言之，函数就是具有输入参数、输出参数的，并且可以独立完成特定功能的程序代码。\n\n### 函数与方法的区别\n#### 函数\n - 通过`函数名()`的方式调用\n\n#### 方法\n - 通过`类的实例.方法名()`的方式调用\n\n#### 判断函数or方法\n\n```python\n#!/usr/bin/python\nfrom types import FunctionType, MethodType\n\nclass Foo(object):\n    def __init__(self):\n        pass\n    def func(self):\n        print(self,\"in func\")\n\nfoo = Foo()  # foo是类Foo的实例\nfoo.func()  # 类Foo的实例调用func\nFoo.func(foo)  # 类Foo调用func，并传入foo实例\n\nprint(isinstance(foo.func, FunctionType))  # False\nprint(isinstance(foo.func, MethodType))   # True   #说明这是一个方法\n\nprint(isinstance(Foo.func, FunctionType))  # True   #说明这是一个函数。\nprint(isinstance(Foo.func, MethodType))  # False\n```\n\n### 命名空间\nwiki百科中的解释：它表示着一个标识符的可见范围。\n简而言之，命名空间就是对象或变量的作用范围。\npython中的命名空间：内置命名空间、全局命名空间、局部命名空间\n - 内置命名空间: python编译器启动时就可以使用的名字存在内置命名空间中\n - 全局命名空间: 除函数外的代码部分\n - 局部命名空间: 函数内部的代码部分\n\n### 作用域\nwiki百科中解释：作用域是名字（name）与实体（entity）的绑定保持有效的那部分计算机程序。\n简而言之，作用域就是变量有效的代码区域。\npython中的作用域分为：全局变量作用域、局部变量作用域\n - 全局变量作用域：是整个代码范围。\n - 局部变量作用域：是定义该变量的子程序的代码范围。\n - 同名变量在全局和局部变量作用域如何划分：在局部变量作用域代码范围内，局部变量起作用;在其他地方全局变量起作用。\n\n### 参数\n\n#### 参数的概念\n参数可以理解为函数的输入值。\n\n#### 参数的种类\n - 形参的角度（函数定义阶段）\n\n```python\n# 位置参数：必须传，且有多少就必须传多少\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三','男')\n>>> 姓名是:张三\n>>> 性别是:男\n\n# 默认参数：可传可不传，不传则使用默认值\ndef name_sex(name, sex='男'):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三')\n>>> 姓名是:张三\n>>> 性别是:男\n\n# *args：接收的是按照位置传参的值，组织成一个元组\ndef name_sex(*args):\n    print(args)\nname_sex('张三','男')\n>>>('张三', '男')\n\n# **kwargs：接受的是按照关键字传参的值，组织成一个字典\ndef name_sex(**kwargs):\n    print(kwargs)\nname_sex(姓名='张三',性别='男')\n>>> {'性别': '男', '姓名': '张三'}\n\n```\n\n - 实参的角度（函数调用阶段）\n\n```python\n# 按位置传参\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三', '男')\n>>>姓名是:张三\n>>>性别是:男\n\n# *按关键字传参\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex(sex='男',name='张三')\n>>>姓名是:张三\n>>>性别是:男\n\n# *按位置、按关键字混合传参：必须按照位置参数，再按照关键字传参，不能将参数赋予多个值\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三',sex='男')\n>>>姓名是:张三\n>>>性别是:男\n```\n\n#### 多种参数混合的顺序\n - 位置参数 -> \\*args -> 默认参数 -> \\*\\*kwargs\n\n#### 动态参数的另一个传参方式\n - 站在形参的角度上，给变量加上\\*，就是组合所有传来的值。\n - 站在实参的角度上，给一个序列加上\\*，就是将这个序列按照顺序打散\n\n\n#### 默认参数的陷阱\n - 默认参数是可变数据类型\n\n```python\n#!/usr/bin/python\n\ndef foo(arg,lst = []):\n    lst.append(arg)\n    print(lst)\n\nfoo('python')\nfoo('java')\n```\n\n### 返回值\n\n#### 返回值的概念\n返回值可以理解为函数的输出值。\n\n#### 返回值的种类\n - 没有返回值，默认返回None\n  - 只有return：结束一个函数的继续\n  - 没有return\n  - return None：不常用\n - 一个返回值\n  - 可以返回任何数据类型\n  - 只要返回就可以接收到\n  - 如果在一个函数中有多个return，只返回第一个\n - 多个返回值\n  - 用多个变量接收：有多少返回值就要有多少变量接收\n  - 用一个变量接收：接收到的是一个元组\n","categories":["Python系列"]},{"title":"Python文件操作","url":"/2020/02/12/Python文件操作/","content":"\n\n## 文件操作\n\n### 文件操作介绍\n众所周知，文件是存储在硬盘或者其他外部存储设备之中的，我们想要操作文件对其内容进行修改的话就涉及到了应用程序对硬件的操作，但是应用程序是无法直接操作硬件设备的，需要操作系统对硬件设备进行操作，所以我们所说的文件操作，其本质上是应用程序利用操作系统所提供的的接口间接的对硬件设备进行操作的。\nPython语言进行文件操作需要利用open()函数，open()函数获取文件流来对文件内容进行操作，这个流实际上就是一个I/O通道，即通常所说文件描述符。\n\n---\n\n### 文件打开方式\n#### 文件句柄方式\n```python\n# 1. 打开文件，得到文件句柄并赋值给一个变量\nf = open('target_file.txt', mode='r', encoding='utf-8')\n\n# 2. 通过句柄对文件进行操作\ncontent = f.read()\n\n# 3.输出读取到的结果\nprint(content)\n\n# 4. 关闭文件\nf.close()\n\n>>> 文件中的内容：\n>>> python\n>>> java\n```\n\n#### 上下文方式\n```python\n# 1. with关键字引导上下文方式打开文件，并将句柄赋予别名f\nwith open('target_file.txt', mode='r', encoding='utf-8') as f:\n\n# 2. 通过句柄对文件进行操作\n    content = f.read()\n\n# 3.输出读取到的结果，用with上下文方式对文件进行操作会在结束操作时默认关闭文件，不必要主动close()\n    print(content)\n```\n\n---\n\n### 操作文件\n`语法：open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`\n\n|操作符| 作用|\n|:------: | :--|\n|'r'| 读取文件（默认）|\n|'w'| 覆盖写入文件|\n|'a'| 追加写入文件|\n|'b'| 二进制模式|\n|'t'| 文本模式（默认）|\n|'+'| 更新文件（读取与写入）|\n|`~~'U'~~`| universal newline mode (在 Python 3.0 中成为默认行为)|\n\n#### 读\n - `mode='r'`：只读，文件不存在则报错\n\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r', encoding='utf-8') as f:\n    content = f.read()\n    print(content)\n>>> 人生苦短，我用python\n```\n\n - `mode='rb'`：以bytes类型读\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='rb') as f:\n    content = f.read()\n    print(content)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python'\n```\n\n - `mode='r+'`：读写，文件不存在不会创建，写则会在指针后添加内容\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r+',encoding='utf-8') as f:\n    content = f.read()\n    f.write('\\n新添加：Life is short , I use python')\n    print(content)\n>>> 人生苦短，我用python\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n>>> 新添加：Life is short , I use python\n```\n\n\n - `mode='r+b'`：以bytes类型读写\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r+b') as f:\n    content = f.read()\n    f.write('\\n新添加：Life is short , I use python'.encode('utf-8'))\n    print(content)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python'\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n>>> 新添加：Life is short , I use python\n```\n\n#### 写\n - `mode='w'`：只写，文件不存在则创建，文件存在则清空再写\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\nwith open('target_file.txt', mode='w', encoding='utf-8') as f:\n    content = f.write('人生苦短，我用python')\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n```\n\n - `mode='x'`：只写，文件不存在则创建，文件存在则报错\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='x', encoding='utf-8') as f:\n    content = f.write('人生苦短，我用python')\n# target_file.txt存在：\n>>> Traceback (most recent call last):\n>>> File \"D:/file_operate.py\", line 94, in <module>\n>>> with open('target_file.txt', mode='x', encoding='utf-8') as f:\n>>> FileExistsError: [Errno 17] File exists: 'target_file.txt'\n# target_file.txt不存在：\n>>> 人生苦短，我用python\n```\n\n - `mode='wb'`：以bytes类型写\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='wb') as f:\n    content = f.write('人生苦短，我用python'.encode('utf-8'))\n>>> 人生苦短，我用python\n\n# # ④w+——写读，文件不存在则创建，写会覆盖之前的内容\nwith open('target_file.txt', mode='w+') as f:\n    content = f.write('hello,world')\n    date = f.read()\n    print(date)\n>>>\n# target_file.txt中的内容为：\n>>> hello,world\n```\n\n - `mode='w+b'`：以bytes类型写读\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='w+b') as f:\n    content = f.write('hello,world'.encode('utf-8'))\n    date = f.read()\n    print(date)\n>>> b''\n# target_file.txt中的内容为：\n>>> hello,world\n```\n\n#### 追加\n - `mode='a'`：追加，文件不存在则创建，文件存在则追加\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a', encoding='utf-8') as f:\n    content = f.write('谁用谁知道')\ntarget_file.txt中的内容为：\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='ab'`：以bytes类型追加\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='ab') as f:\n    content = f.write('谁用谁知道'.encode('utf-8'))\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='a+'`：可读可写，文件不存在则创建，写则追加\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a+',encoding='utf-8') as f:\n    content = f.write('谁用谁知道')\n    f.seek(0)\n    date = f.read()\n    print(date)\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='a+b'`：以bytes类型可读可写\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a+b') as f:\n    content = f.write('谁用谁知道'.encode('utf-8'))\n    f.seek(0)\n    date = f.read()\n    print(date)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python\\xe8\\xb0\\x81\\xe7\\x94\\xa8\\xe8\\xb0\\x81\\xe7\\x9f\\xa5\\xe9\\x81\\x93'\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python谁用谁知道\n```\n\n#### 文件修改\n\n> python没有提供直接修改文件的函数，只能新建文件，将源文件的内容修改完成后写入新文件中，再把原文件删除，新文件重命名\n\n```python\nimport os\n\nwith open('源文件', encoding='utf-8') as f, open('源文件.bak', mode='w', encoding='utf-8') as f_w:\n    for i in f:\n        if '源文件' in i:\n            i = i.replace('源文件', '更改后的源文件')\n        f_w.write(i)\n\nos.remove('源文件')\nos.rename('源文件.bak','源文件')\n\n```\n\n#### 其他操作\n - seek() 移动光标指针位置\nseek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的\n\n - tell() 返回当前指针所在的位置\ntell对于英文字符就是占一个,中文字符占三个,参数表示的是字节数区分与read()的不同。\n\n - truncate() 截断文件\ntruncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果。\n\n - readline() 读取一行\n\n - readlines() 读取多行，返回为列表\n\n - readable() 文件是否可读\n\n - writeline() 写入一行\n\n - writelines() 写入多行\n\n - writable() 文件是否可读\n\n - closed() 文件是否关闭\n\n - encoding='utf-8' 如果文件打开模式为b,则没有该属性\n\n - flush() 立刻将文件内容从内存刷到硬盘\n\n - for循环文件句柄\n```python\nwith open('target_file.txt', mode='r',encoding='utf-8') as f:\n    for i in f:\n        print(i)\n>>> 人生苦短，我用python\n>>> 谁用谁知道\n```\n","categories":["Python系列"]},{"title":"Python字符集&编码详解","url":"/2020/02/01/Python字符集&编码详解/","content":"\n\n## 字符集&编码详解\n### 1 定义\n- 编码/解码（encode/decode）：计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，称为\"编码\"；反之，将存储在计算机中的二进制数解析显示出来，称为\"解码\"。如果使用了错误的解码规则，则导致解码错误或者乱码。\n- 字符集（charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等\n- 字符编码（character Encoding）：是一套法则，使用该法则能够在符号集合与数字系统之间建立对应关系。\n\n### 2 字符集的发展过程\n#### 2.1. ASCII 字符集&编码\nASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。\n\n - ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n\n - ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：\n ![](/images/post_imgs/ascii_1.png)\n ![](/images/post_imgs/ascii_2.png)\n\n#### 2.2. GBXXXX 字符集&编码\n计算机发明之初只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。但是当中国也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。中国为了解决这个问题规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。上述编码规则就是中国大陆通用的GB2312。GB2312或GB2312-80是中国国家标准简体中文字符集。新加坡等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。\n\n由于GB2312-80只收录6763个汉字，有不少汉字，并未收录在内。于是微软利用GB 2312-80未使用的编码空间，收录GB13000.1-93全部字符制定了GBK编码，后续国家标准GB18030技术上兼容GBK。\n ![](/images/post_imgs/gb2312.png)\n\n#### 2.3. BIG5 字符集&编码\nBig5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13060个汉字。2003年，Big5被收录到CNS11643中文标准交换码的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。\n\n#### 2.4. Unicode字符集 & UTF编码\n> Unicode是字符集，UTF-32 / UTF-16 / UTF-8是三种字符编码方案\n\n当计算机传到世界各个国家时，为了适合当地语言和字符，设计和实现类似GB232/GBK/GB18030/BIG5的编码方案。这样各搞一套，在本地使用没有问题，一旦出现在网络中，由于不兼容，互相访问就出现了乱码现象。\n为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号或者表意文字。每个数字代表唯一的至少在某种语言中使用的符号。被几种语言共用的字符通常使用相同的数字来编码，每个字符对应一个数字，每个数字对应一个字符，即不存在二义性。\n在计算机科学领域中，Unicode（统一码、万国码、单一码、标准万国码）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character Set）的标准来发展，并且同时也以书本的形式对外发表。Unicode 还不断在扩增，每个新版本插入更多新的字符。直至目前为止的第六版，Unicode 就已经包含了超过十万个字符、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一套包含了上标字、下标字等字符特性的枚举等。\n\n - UCS & UNICODE\n通用字符集（Universal Character Set，UCS）是由ISO制定的ISO 10646标准所定义的标准字符集。历史上存在两个独立的尝试创立单一字符集的组织，即国际标准化组织（ISO）和多语言软件制造商组成的统一码联盟。前者开发的 ISO/IEC 10646 项目，后者开发的统一码项目。因此最初制定了不同的标准。\n1991年前后，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，虽然两个项目仍都存在，并独立地公布各自的标准。但统一码联盟和ISO/IEC JTC1/SC2都同意保持两者标准的码表兼容，并紧密地共同调整任何未来的扩展。在发布的时候，Unicode一般都会采用有关字码最常见的字型，但ISO 10646一般都尽可能采用Century字型。\n\n - UTF-32\n上述使用4字节的数字来表达每个字母、符号，或者表意文字，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称UCS-4是一种将Unicode字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。\n这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。\n\n - UTF-16\n尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。UTF-16将0–65535范围内的字符编码成2个字节。UTF-16编码最明显的优点是它在空间效率上比UTF-32高两倍，因为每个字符只需要2个字节来存储（除去65535范围以外的），而不是UTF-32中的4个字节。\n\n - UTF-8\nUTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码（定长码），也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。\n\n```txt\n一、UTF-8优点\n1、UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。\n2、使用标准的面向字节的排序例程对UTF-8排序将产生与基于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）\n3、UTF-8和UTF-16都是可扩展标记语言文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。\n4、任何面向字节的字符串搜索算法都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。\n5、UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看W3 FAQ: Multilingual Forms上的验证UTF-8字符串的正则表达式）。\n\n二、UTF-8缺点\n1、因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作——即串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。\n```\n\n#### 2.5. 字符编码发展图\nASCII → GB2312 → GBK1.0 → GB18030 → Unicode → UTF-32 → UTF-16 → UTF-8\n\n\n","categories":["Python系列"]},{"title":"Python运算符","url":"/2020/01/15/Python运算符/","content":"\n## 运算符\n\n### 算术运算符\n|运算符|描述|示例|\n|---|---|---|\n|+|加：对两个可相加对象进行加法运算，并返回结果|a = 10 b = 20 => a+b = 30|\n|-|减：对两个可相减对象进行加法运算，并返回结果|a = 10 b = 20 => b-a = 10|\n|*|乘：对两个可相乘对象进行加法运算，并返回结果|a = 10 b = 20 => a*b = 200|\n|/|除：对两个可相除对象进行加法运算，并返回结果|a = 10 b = 20 => b/a = 2|\n|%|取模：返回除法的余数|a = 10 b = 20 => b%a = 0|\n|**|幂：返回乘方的结果|a = 2 b = 4 => a**b = 16|\n|//|取整除：返回商的整数部分|a = 2 b = 5 => b%a = 2|\n\n\n### 关系运算符\n|运算符|描述|示例|\n|---|---|---|\n|==|等于：比较两个可比较对象是否相等，并返回布尔结果|a = 10 b = 20 => a==b 返回 false|\n|!=|不等于：比较两个可比较对象是否不相等，并返回布尔结果|a = 10 b = 20 => a!=b 返回 true|\n|>|大于：比较对象A是否大于对象B，并返回布尔结果|a = 10 b = 20 => a > b 返回 false|\n|<|小于：比较对象A是否小于对象B，并返回布尔结果|a = 10 b = 20 => a < b 返回 true|\n|\\>=|大于等于：比较对象A是否大于等于对象B，并返回布尔结果|a = 10 b = 20 => a >= b 返回 false|\n|<=|小于等于：比较对象A是否小于等于对象B，并返回布尔结果|a = 10 b = 20 => a <= b 返回 true|\n\n\n### 赋值运算符\n|运算符|描述|示例|\n|---|---|---|\n|=|简单赋值运算：将=右边变量赋值给=左边变量|a = 10 => b = a, b = 10|\n|+=|加法赋值运算|b += a 等效于 b = b + a|\n|-=|减法赋值运算|b -= a 等效于 b = b - a|\n|*=|乘法赋值运算|b \\*= a 等效于 b = b \\* a|\n|/=|除法赋值运算|b /= a 等效于 b = b / a|\n|%=|取模赋值运算|b %= a 等效于 b = b % a|\n|**=|幂赋值运算|b \\*\\*= a 等效于 b = b \\*\\* a|\n|//=|取整除赋值运算|b //= a 等效于 b = b // a|\n\n\n### 逻辑运算符\n|运算符|描述|示例|\n|---|---|---|\n|and|布尔与：a and b, 若a为false，a and b返回 false, 否则返回b的计算值|a = 10 b = 20 => a and b 返回20|\n|or|布尔或：a or b, 若a为非0，a or b返回 a 的值, 否则返回 b 的计算值|a = 10 b = 20 => a or b 返回10|\n|not|布尔非：not a, 若 a 为 true, 返回false，否则返回true|not a / not b 返回 false|\n\n\n#### 布尔与\n - 在Python 中，and 和 or 执行布尔逻辑演算，如你所期待的一样，但是它们并不返回布尔值；而是，返回它们实际进行比较的值之一。\n - 在布尔上下文中从左到右演算表达式的值，如果布尔上下文中的所有值都为真，那么 and 返回最后一个值。\n - 如果布尔上下文中的某个值为假，则 and 返回第一个假值\n\n\n#### 布尔或\n - 使用 or 时，在布尔上下文中从左到右演算值，就像 and 一样。如果有一个值为真，or 立刻返回该值\n - 使如果所有的值都为假，or 返回最后一个假值\n - 使注意 or 在布尔上下文中会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值\n\n\n#### 布尔非\n - 结合了前面的两种语法，推理即可。\n - 为加强程序可读性，最好与括号连用，例如： （1 and ‘x’) or ‘y’\n\n\n### 位运算符\n|运算符|描述|示例|\n|---|---|---|\n|&|按位与运算：参与运算的两对应位都为1，则该位返回1，否则返回0|a = 60 b = 13 => a & b = 12 (0000 1100)|\n|\\||按位或运算：参与运算的两对应位有一个为1，则该位返回1，否则返回0|a = 60 b = 13 => a \\| b = 61 (0011 1101)|\n|^|按位异或：参与运算的两对应位相异时，则该位返回1，否则返回0|a = 60 b = 13 => a ^ b = 49 (0011 0001)|\n|~|按位取反运算：参与运算的数每位取反，即0、1互换|a = 60 => ~a = -61 (1100 0011)有符号二进制数的补码形式 |\n|<<|左移运算：参与运算的数每位向左移动若干位，高位丢弃，低位补0|a = 60 => a << 2 = 240 (1111 0000)) |\n|\\>\\>|右移运算：参与运算的数每位向右移动若干位，高位补0，低位丢弃|a = 60 => a >> 2 = 15 (0000 1111)) |\n\n - tips\n`~ 举例： ~5 = -6 解释： 将二进制数+1之后乘以-1，即~x = -(x+1)，-(101 + 1) = -110`\n\n\n### 成员运算符\n|运算符|描述|示例|\n|---|---|---|\n|in|如果在指定的序列中找到则返回true，否则false|a = 'yang' b = 'ya' => b in a, 返回true|\n|not in|如果在指定的序列中找不到则返回true，否则false|a = 'yang' b = 'ay' => b not in a, 返回true|\n\n\n### 身份运算符\n|运算符|描述|示例|\n|---|---|---|\n|is|判断两个变量是不是引用自同一个对象|a is b => 若 id(a) == id(b), 则返回1|\n|is not|判断两个变量是不是引用自不同对象|a is not b => 若 id(a) != id(b), 则返回1|\n\n\n### 运算符优先级（由低到高）\n|运算符|描述|\n|---|---|\n|lambda|Lambda表达式|\n|or|布尔'或'|\n|and|布尔'与'|\n|not x|布尔'非'|\n|in，not in|成员运算|\n|is，is not|身份运算|\n|<，<=，>，>=，!=，==|\t比较运算|\n|\\||按位或|\n|^|按位异或|\n|&|按位与|\n|<<，>>|位运算|\n|+，-|加法与减法|\n|*，/，%|乘法、除法与取余|\n|+x，-x|正负号|\n|~x|按位翻转(取补码)|\n|**|指数|\n|x.attribute|属性参考|\n|x[index]|下标|\n|x[index:index]|寻址段|\n|f(arguments...)|函数调用|\n|(experession,...)|绑定或元组显示|\n|[expression,...]|列表显示|\n|{key:datum,...}|字典显示|\n|'expression,...'|字符串转换|\n\n\n### 重要运算符说明\n#### join和符号”+“区别\n - \"+\"\n我们知道在python中，字符串是不可变数据类型。所以当多个字符串利用\"+\"进行拼接时，会每次都做一次申请内存的操作，并将拼接后的字符串存入新内存中。\n - join\n与\"+\"不同，join操作时会先计算字符操作所用到的空间总和大小，之后将需要拼接的所有字符串一次性都拼接完成存入新内存中。这就比\"+\"节省了每次申请新内存的时间。\n\n#### is和”==“区别\n\n - \"==\"\n用来比较两个对象的值是否相同。\n - is\n用来比较对象所处的内存地址是否相同。","categories":["Python系列"]},{"title":"Python数据类型之类型转换内置函数汇总","url":"/2020/01/07/Python数据类型之类型转换内置函数汇总/","content":"\n## 类型转换内置函数\n\n### 数字类型\n - `int(x [,base])`：将x转换为一个整数\n - `float(x)`：将x转换为一个浮点数\n - `complex([real[, imag]])`：返回一个值为real + imag*1j的复数\n - `chr(x)`：将整数x转换为一个字符\n - `unichr(x)`：将整数x转换为Unicode字符 \n\n### 字符串类型\n - `str(x)`：将x转换为字符串\n - `repr(x)`：将x转换为表达式字符串\n - `eval(str)`：用于计算在字符串中的有效python表达式，并返回对象\n - `ord(x)`：将字符串x转换为整数\n - `hex(x)`：将字符串x转换为十六进制字符串\n - `oct(x)`：将字符串x转换为八进制字符串\n\n### 列表类型\n - `list(s)`：将序列s转换为一个列表\n\n### 元组类型\n - `tuple(s)`：将序列s转换为一个元组\n\n### 字典类型\n - `dict(d)`：创建字典，d需要是形如(key,value)的元组\n\n### 集合类型\n - `set(s)`：将s转换为可变集合\n - `frozenset(s)`：将s转换伟不可变集合\n\n### 类型间相互转换\n - 字符串、列表相互转换\n\n```python\n# list -> string（list中的元素需为字符串）\n\nl = ['y','a','n','g']\ns = ''.join(l)\nprint(s)\n>>> 'yang'\n\n# string -> list\ns = 'y, a, n, g'\nl = s.split(',')\nprint(l)\n>>> ['y','a','n','g']\n\n```\n\n - 列表/元组转换为字典\n\n```python\n# list/tuple -> dict\nl = ['a', 'b']\nd = dict.fromkeys(l)\nprint(d)\n>>> {'a': None, 'b': None}\n```\n\n","categories":["Python系列"]},{"title":"Python数据类型之py2与py3字符串类型区别","url":"/2019/12/26/Python数据类型之py2与py3字符串类型区别/","content":"\n## Python2.x字符串 VS Python3.x字符串\n\n### 1. Python2.X的字符类型\n#### 1.1 str类型 & unicode类型\n```python\n>>> s1 = '中'\n>>> s2 = u'中'\n\n# 分别看下s1与s2的类型\n>>> print(type(s1))\n<type 'str'>\n\n>>> print(type(s2))\n<type 'unicode'>\n```\n#### 1.2 str类型与unicode类型的转换\n```python\n# utf-xxx是unicode字符集的具体编码形式，所以str类型转为unicode类型需要进行encode编码\n>>> s1 = u'中'\n>>> print(type(s1))\n<type 'unicode'>\n>>> new_s1 = s1.encode('utf8')\n>>> print(type(new_s1))\n<type 'str'>\n\n# 反之，unicode类型转为str类型则是将unicode类型解码为str类型，用decode进行解码\n>>> s2 = '中'\n>>> print(type(s2))\n<type 'str'>\n>>> new_s2 = s2.decode('utf8')\n>>> print(type(new_s1))\n<type 'unicode'>\n\n```\n\n### 2. Python3.X的字符类型\n#### 2.1 str类型 & bytes类型\n```python\n>>> s1 = 'yang'\n>>> s2 = b'yang'\n\n# 分别看下s1与s2的类型\n>>> print(type(s1))\n<class 'str'>\n\n>>> print(type(s2))\n<class 'bytes'>\n\n```\n### 2.2 str类型与bytes类型的转换\n```python\n# 在python3.X中，str类型对应unicode数据，bytes类型对应bytes数据，文本都是unicode数据，对应str类型\n# str类型转为bytes类型需要进行encode编码\n>>> s1='yang'\n>>> print(type(s1))\n<class 'str'>\n>>> new_s1 = s1.encode('utf8')\n>>> print(type(new_s1))\n<class 'bytes'>\n\n# 反之，bytes类型转为str类型则是将unicode数据用decode进行解码\n>>> s2=b'yang'\n>>> print(type(s2))\n<class 'bytes'>\n>>> new_s2 = s2.decode('utf8')\n>>> print(type(s2))\n<class 'str'>\n\n```\n\n### 3. 总结\n* Python3.X最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分，不再会对bytes字节串进行自动解码。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。\n* Python3.X不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。用户不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）。\n* 无论py2，还是py3,与明文直接对应的就是unicode数据，打印unicode数据就会显示相应的明文(包括英文和中文)\n\n - Python2.X中\n```python\n# str类型和unicode类型连接\n>>> print('Elijah'+u'Yang')\n\nElijahYang\n```\n\n - Python3.X中\n```python\n#字节串和unicode连接\n>>> print(b'Elijah'+'Yang')\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't concat str to bytes\n```\n\n","categories":["Python系列"]},{"title":"Python数据类型之集合","url":"/2019/12/12/Python数据类型之集合/","content":"\n## 集合类型(set)\n\n### 1. 集合介绍\n由不同元素组成的集合，集合中是一组无序排列的可hash值，可以作为字典的key\n\n#### 1.1 定义方式\n```python\n# 定义：由不同元素组成的集合，集合中是一组无序排列的可hash值，可以作为字典的key\n\n# 定义方法\n>>> set([iterable])\n\n>>> set1 = set('yang')\n>>> print(set1)\n\n{'yang'}\n\n```\n\n------------\n\n### ★2. 常用集合方法\n#### 2.1 交集、并集、差集、对称差集\n**语法说明**\n*交集*\n> set1 & set2\n\n*并集*\n> set1 | set2\n\n*差集*\n> set1 - set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 交集：set1和set2同时具有的元素的集合\n>>> set1 & set2\n{'A', '1'}\n\n# 并集：set1和set2的所有元素的集合\n>>> set1 | set2\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n\n# 差集：在set1中但是不在set2中的所有元素集合\n>>> set1 - set2\n{'D', 'B', 'C'}\n\n# 对称差集：在set1或set2中，但不会同时出现在二者中\n>>> set1 ^ set2\n{'D', 'C', '4', '3', 'B', '2'}\n```\n\n#### 2.2 添加元素\n**语法说明**\n> 添加一项元素\n> set1.add()\n\n> 添加多项元素\n> set1.update()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 添加一项元素\n>>> set1.add('E')\n>>> set1\n{'E', 'D', 'C', 'A', '1', 'B'}\n\n# 添加多项元素\n>>> set1.update(['2','3','4'])\n>>> set1\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n```\n\n#### 2.3 删除元素\n**语法说明**\n> 删除元素\n> set1.remove()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 删除一项元素\n>>> set1.remove('A')\n>>> set1\n{'D', 'C', '1', 'B'}\n```\n\n#### 2.4 集合长度\n**语法说明**\n> len(set1)\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> len(set1)\n5\n```\n\n#### 2.5 判断元素是否是集合成员\n**语法说明**\n> x in set1（同理 x not in set1判断元素是否不是集合成员）\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> 'B' in set1\nTrue\n```\n\n#### 2.6 判断set1集合中每一个元素都在set2中\n**语法说明**\n> set1.issubset(set2)\n> 同：set1 <= set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.issubset(set2)\nFalse\n```\n\n#### 2.7 判断set2集合中的每一个元素都在set1中\n**语法说明**\n> set1.issuperset(set2)\n> 同：set1 >= set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.issuperset(set2)\nFalse\n```\n\n#### 2.8 set1和set2的合集，返回包含两集合中的每一个元素的集合\n**语法说明**\n> set1.union(set2)\n> 同：set1|set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.union(set2)\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n```\n\n#### 2.9 set1和set2的交集，返回两集合的共同部分\n**语法说明**\n> set1.intersection(set2)\n> 同：set1 & set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.intersection(set2)\n{'A', '1'}\n```\n\n#### 2.10 set1与set2的差集，返回set1中存在但是set2中不存在的元素\n**语法说明**\n> set1.difference(set2)\n> 同：set1 - set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.difference(set2)\n{'D', 'B', 'C'}\n```\n\n#### 2.11 set1和set2的对称差集，返回set1与set2中不重复的元素\n**语法说明**\n> set1.symmetric_difference(set2)\n> 同：set1 ^ set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.symmetric_difference(set2)\n{'D', 'C', '4', '3', 'B', '2'}\n```\n\n#### 2.12 set1浅复制\n**语法说明**\n> set1.copy()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n\n>>> set3 = set1.copy()\n>>> set3\n{'B', 'D', 'C', 'A', '1'}\n\n```\n\n#### 2.13 不可变集合frozenset\n**语法说明**\n> frozenset([iterable]])\n> 不可添加、删除元素、可哈希的、能用作字典的键、能做其他集合的元素\n\n```python\n>>> set1 = set([1, 2, 3, 4])\n>>> set1\n{1, 2, 3, 4}\n>>> f_set = frozenset(set1)\n>>>f_set\nfrozenset({1, 2, 3, 4})\n>>>set1.add('a')\n{1, 2, 3, 4, 'a'}\n\n# 不可变集合不能更改集合\n>>>f_set.add('b')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'frozenset' object has no attribute 'add'\n```\n\n#### 2.14 set应用-去除列表里重复元素\n```python\n# 去除海量列表里重复元素\n>>> list_a = [A,B,C,D,A,B]\n>>> set_b = set(list_a)\n>>> set_b\nset([A,B,C,D])\n>>> list_c = [i for i in set_b]\n>>> list_c\n[A,B,C,D]\n```\n\n#### 参考资料\nhttp://www.iplaypy.com/jichu/set.html\n\nhttp://www.runoob.com/python/python-func-set.html\n\nhttp://blog.csdn.net/dragonyangang/article/details/72808992\n\nhttp://blog.csdn.net/business122/article/details/7541486","categories":["Python系列"]},{"title":"Python数据类型之字典","url":"/2019/12/02/Python数据类型之字典/","content":"\n## 字典类型(dict)\n\n### 1. 字典介绍\n字典是另一种可变容器模型，且可存储任意类型对象。\n\n#### 1.1 定义方式\n```python\n# 定义：字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号{}中\n\n# 定义方法\n>>> d = {key1 : value1, key2 : value2 }\n\n# 键必须是唯一的，但值则不必；值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。\n>>> dict1 = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}\n>>> dict2 = { 'abc': 456 }\n>>> dict3 = { 'abc': 123, 98.6: 37 }\n```\n\n------------\n\n### ★2. 常用字典方法\n#### 2.1 dict[key] 访问字典中的值\n**语法说明**\n> 把相应的键放入方括号\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print (\"dict['Name']: \", dict['Name'])\n>>> print (\"dict['Age']: \", dict['Age'])\n\ndict['Name']:  Yang\ndict['Age']:  7\n\n# 如果用字典里没有的键访问数据，会输出错误\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print (\"dict['Alice']: \", dict['Alice'])\n\nTraceback (most recent call last):\n  File \"test_dict.py\", line 5, in <module>\n    print (\"dict['Alice']: \", dict['Alice'])\nKeyError: 'Alice'\n```\n\n#### 2.2 修改字典元素\n**语法说明**\n> 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n# 更新 Age\n>>> dict['Age'] = 8\n# 添加信息\n>>> dict['School'] = \"程序员学院\"\n>>> print (\"dict['Age']: \", dict['Age'])\n>>> print (\"dict['School']: \", dict['School'])\n\ndict['Age']:  8\ndict['School']:  程序员学院\n```\n\n#### 2.3 删除字典元素\n**语法说明**\n> 能删单一的元素也能清空字典，清空只需一项操作；删除一个字典用del命令\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n\n# 删除键 'Name'\n>>> del dict['Name']\n# 删除字典\n>>> dict.clear()\n# 删除字典\n>>> del dict\n>>> print (\"dict['Age']: \", dict['Age'])\n>>> print (\"dict['School']: \", dict['School'])\n\n# 会引发一个异常，因为用执行 del 操作后字典不再存在\nTraceback (most recent call last):\n  File \"test_dict.py\", line 9, in <module>\n    print (\"dict['Age']: \", dict['Age'])\nTypeError: 'type' object is not subscriptable\n```\n\n#### 2.4 字典键的特性\n* 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。\n* 两个重要的点需要记住：\n    1. 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住\n    ```python\n    >>> dict = {'Name': 'Yang', 'Age': 7, 'Name': '小菜鸟'}\n    >>> print (\"dict['Name']: \", dict['Name'])\n\n    dict['Name']:  小菜鸟\n    ```\n    2. 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行\n    ```python\n    >>> dict = {['Name']: 'Yang', 'Age': 7}\n    >>> print (\"dict['Name']: \", dict['Name'])\n\n    Traceback (most recent call last):\n      File \"test_dict.py\", line 3, in <module>\n        dict = {['Name']: 'Runoob', 'Age': 7}\n    TypeError: unhashable type: 'list'\n    ```\n\n#### 2.5 len(dict) 计算字典元素个数，即键的总数\n\n**语法说明**\n> len(dict)\n\n**参数说明**\n* dict -- 字典对象\n\n**返回值**\n> 该方法返回字典键的总数\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print(len(dict))\n\n3\n```\n\n#### 2.6 str() 输出字典，以可打印的字符串表示\n\n**语法说明**\n> str(dict)\n\n**参数说明**\n* dict -- 字典对象\n\n**返回值**\n> 该方法返回输出字典，以可打印的字符串表示\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> str(dict)\n\n\"{'Name': 'Yang', 'Class': 'First', 'Age': 7}\"\n```\n\n#### 2.7 type() 返回输入的变量类型，如果变量是字典就返回字典类型\n\n**语法说明**\n> type(variable)\n\n**参数说明**\n* variable -- 变量\n\n**返回值**\n> 该方法返回输入的变量类型\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> type(dict)\n\n<class 'dict'>\n```\n\n#### 2.8 dict.clear() 删除字典内所有元素\n\n**语法说明**\n> dict.clear()\n\n**参数说明**\n* 无\n\n**返回值**\n> 该函数没有任何返回值\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7}\n>>> print (\"字典长度 : %d\" %  len(dict))\n>>> dict.clear()\n>>> print (\"字典删除后长度 : %d\" %  len(dict))\n\n字典长度 : 2\n字典删除后长度 : 0\n```\n\n#### 2.9 dict.copy() 返回一个字典的浅复制\n\n**语法说明**\n> dict.copy()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个字典的浅复制返回一个字典的浅复制\n\n```python\n>>> dict1 = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> dict2 = dict1.copy()\n>>> print (\"新复制的字典为 : \",dict2)\n\n新复制的字典为 :  {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n```\n\n#### 2.10 fromkeys() 函数用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。\n\n**语法说明**\n> dict.fromkeys(seq[, value]))\n\n**参数说明**\n* seq -- 字典键值列表\n* value -- 可选参数, 设置键序列（seq）的值\n\n**返回值**\n> 该方法返回列表\n\n```python\n>>> seq = ('name', 'age', 'sex')\n\n>>> dict = dict.fromkeys(seq)\n>>> print (\"新的字典为 : %s\" %  str(dict))\n\n>>> dict = dict.fromkeys(seq, 10)\n>>> print (\"新的字典为 : %s\" %  str(dict))\n\n新的字典为 : {'name': None, 'age': None, 'sex': None}\n新的字典为 : {'name': 10, 'age': 10, 'sex': 10}\n```\n\n#### 2.11 get() 函数返回指定键的值，如果值不在字典中返回默认值\n\n**语法说明**\n> dict.get(key, default=None)\n\n**参数说明**\n* key -- 字典中要查找的键。\n* default -- 如果指定键的值不存在时，返回该默认值值。\n\n**返回值**\n> 返回指定键的值，如果值不在字典中返回默认值 None\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n>>> print (\"Age 值为 : %s\" %  dict.get('Age'))\n>>> print (\"Sex 值为 : %s\" %  dict.get('Sex', \"NA\"))\n\nAge 值为 : 26\nSex 值为 : NA\n```\n\n#### 2.12 in 操作符用于判断键是否存在于字典中，返回布尔值\n\n**语法说明**\n> key in dict\n\n**参数说明**\n* key -- 要在字典中查找的键\n\n**返回值**\n> 如果键在字典里返回true，否则返回false\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n# 检测键 Age 是否存在\n>>> if  'Age' in dict:\n>>>     print(\"键 Age 存在\")\n>>> else :\n>>>     print(\"键 Age 不存在\")\n\n# 检测键 Sex 是否存在\n>>> if  'Sex' in dict:\n>>>     print(\"键 Sex 存在\")\n>>> else :\n>>>     print(\"键 Sex 不存在\")\n\n键 Age 存在\n键 Sex 不存在\n\n```\n\n#### 2.13 items() 方法以列表返回可遍历的(键, 值) 元组数组\n\n**语法说明**\n> dict.items()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回可遍历的(键, 值) 元组数组\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> print (\"Value : %s\" %  dict.items())\n\nValue : dict_items([('Name', 'Yang'), ('Age', 26)])\n```\n\n#### 2.14 keys() 方法以列表返回一个字典所有的键\n\n**语法说明**\n> dict.keys()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个字典所有的键\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> print (\"字典所有的键为 : %s\" %  dict.keys())\n\n字典所有的键为 : dict_keys(['Age', 'Name'])\n```\n\n#### 2.15 setdefault() 与get()方法类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值\n\n**语法说明**\n> dict.setdefault(key, default=None)\n\n**参数说明**\n* key -- 查找的键值。\n* default -- 键不存在时，设置的默认键值。\n\n**返回值\n> 该方法没有任何返回值\n\n```python\n# 与get()方法类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值。\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n>>> print (\"Age 键的值为 : %s\" %  dict.setdefault('Age', None))\n>>> print (\"Sex 键的值为 : %s\" %  dict.setdefault('Sex', None))\n>>> print (\"新字典为：\", dict)\n\nAge 键的值为 : 26\nSex 键的值为 : None\n新字典为： {'Name': 'Yang', 'Age': 26, 'Sex': None}\n```\n\n#### 2.16 update() 函数把字典dict2的键/值对更新到dict里\n\n**语法说明**\n> dict.update(dict2)\n\n**参数说明**\n* dict2 -- 添加到指定字典dict里的字典\n\n**返回值**\n> 无\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> dict2 = {'Sex': 'female' }\n\n>>> dict.update(dict2)\n>>> print (\"更新字典 dict : \", dict)\n\n更新字典 dict :  {'Sex': 'female', 'Age': 26, 'Name': 'Yang'}\n```\n\n#### 2.17 values() 方法以列表返回字典中的所有值\n\n**语法说明**\n> dict.values()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回字典中的所有值\n\n```python\n>>> dict = {'Sex': 'male', 'Age': 26, 'Name': 'Yang'}\n>>> print (\"字典所有值为 : \",  list(dict.values()))\n\n字典所有值为 :  ['male', 26, 'Yang']\n```\n\n#### 2.18 pop() 方法删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出,否则，返回default值\n\n**语法说明**\n> pop(key[,default])\n\n**参数说明**\n* key: 要删除的键值\n* default: 如果没有 key，返回 default 值\n\n\n**返回值**\n> 返回被删除的值\n\n```python\n>>> site= {'name': '程序员学院', 'alexa': 10000, 'url': 'www.engineer.com'}\n>>> pop_obj=site.pop('name')\n>>> print(pop_obj)\n\n程序员学院\n```\n\n#### 2.19 popitem() 方法随机返回并删除字典中的一对键和值(一般删除末尾对)。\n> 如果字典已经为空，却调用了此方法，就报出KeyError异常。\n\n**语法说明**\n> popitem()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个键值对(key,value)形式\n\n```python\nsite= {'name': '程序员学院', 'alexa': 10000, 'url': 'www.engineer.com'}\npop_obj=site.popitem()\nprint(pop_obj)\nprint(site)\n\n('url', 'www.engineer.com')\n{'name': '程序员学院', 'alexa': 10000}\n```\n\n\n\n","categories":["Python系列"]},{"title":"Python数据类型之元组.md","url":"/2019/11/19/Python数据类型之元组/","content":"\n## 元组类型(tuple)\n\n### 1. 元组介绍\nPython的元组与列表类似，同样可通过索引访问，支持异构，任意嵌套。不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。\n\n#### 1.1 定义方式\n```python\n# 定义：()内可以有多个任意类型的值，逗号分隔\n\n# 定义方法-定义元组\n>>> tup1 = ('physics', 'chemistry', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5 )\n>>> tup3 = \"a\", \"b\", \"c\", \"d\"\n>>> print(tup1)\n>>> print(tup2)\n>>> print(tup3)\n\n('physics', 'chemistry', 1997, 2000)\n(1, 2, 3, 4, 5)\n('a', 'b', 'c', 'd')\n\n# 定义方法-定义空元组\n>>> tup1 = ()\n>>> print(tup1)\n\n()\n\n# 定义方法-元组中只包含一个元素时，需要在元素后面添加逗号\n>>> tup1 = ('yang',)\n>>> print(tup1)\n\n('yang',)\n\n# 定义方法2\n>>> tup1=tuple(('apple', 'banana', 'peach'))\n>>> print(tup1)\n\n('apple', 'banana', 'peach')\n```\n\n------------\n### ★2. 常用元组方法\n#### 2.1 tuple[index] 访问元组中的值\n**语法说明**\n> 使用下标索引来访问列表中的值，下标从0开始计数\n\n```python\n# 使用下标索引来访问列表中的值，下标从0开始计数\n\n>>> tup1 = ('physics', 'chemistry', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5, 6, 7 )\n\n>>> print(\"tup1[0]: \",tup1[0])\n>>> print(\"tup2[1:5]: \",tup2[1:5])\n>>> print(\"tup2[1:]: \",tup2[1:]:)\n>>> print(\"tup2[-2]: \",tup2[-2]:)\n\ntup1[0]: physics\ntup2[1:5]: (2, 3, 4, 5)\ntup2[1:]: (2, 3, 4, 5, 6, 7)\ntup2[-2]: 6\n```\n\n#### 2.2 修改元组\n> 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合\n\n```python\n# 以下修改元组元素操作是非法的。\n# tup1[0] = 100\n\n>>> tup1 = (12, 34.56);\n>>> tup2 = ('abc', 'xyz')\n\n# 创建一个新的元组\n>>> tup3 = tup1 + tup2\n>>> print(tup3)\n\n(12, 34.56, 'abc', 'xyz')\n```\n\n#### 2.3 删除元组\n> 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\n\n```python\n>>> tup = ('physics', 'chemistry', 1997, 2000)\n>>> print(tup)\n>>> del tup\n>>> print(\"After deleting tup : \",tup)\n\n# 以上实例元组被删除后，输出变量会有异常信息\n('physics', 'chemistry', 1997, 2000)\nAfter deleting tup :\nTraceback (most recent call last):\n  File \"test_deltup.py\", line 9, in <module>\n    print tup;\nNameError: name 'tup' is not defined\n```\n\n#### 2.4 元组运算符\n> 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。\n\n|Python 表达式|结果结果|描述|\n|:----: | :----: | :----: |\n|len((1, 2, 3))|3|计算元素个数|\n|(1, 2, 3) + (4, 5, 6)|(1, 2, 3, 4, 5, 6)|连接|\n|('copy',) * 4|('copy', 'copy', 'copy', 'copy')|复制 |\n|3 in (1, 2, 3)|True|元素是否存在|\n|for x in (1, 2, 3): print x,|1 2 3|迭代|\n\n#### 2.5 无关闭分隔符\n> 任意无符号的对象，以逗号隔开，默认为元组\n\n```python\n>>> tup1 = 1,2,3,4,5\n>>> tup2 = 'A','B','C','D','E'\n>>> print(tup1)\n>>> print(tup2)\n\n(1, 2, 3, 4, 5)\n('A', 'B', 'C', 'D', 'E')\n```\n\n#### 2.6 len() 计算元组元素个数\n**语法说明**\n> len(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回元组中元素个数\n\n```python\n>>> tuple1 = ('Google', 'Baidu', 'Taobao')\n>>> print(len(tuple1))\n\n3\n```\n\n#### 2.7 max() 返回元组中元素最大值\n\n**语法说明**\n> max(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回元组中元素最大值。\n\n```python\n>>> tuple2 = ('5', '4', '8')\n>>> print(max(tuple2))\n\n8\n```\n\n#### 2.8 min() 返回元组中元素最小值\n\n**语法说明**\n> min(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回值返回元组中元素最小值\n\n```python\n>>> tuple2 = ('5', '4', '8')\n>>> print(min(tuple2))\n\n4\n```\n\n#### 2.9 tuple() 将列表转换为元组\n\n**语法说明**\n> tuple(seq)\n\n**参数说明**\n* seq -- 序列对象，如列表\n\n**返回值**\n> 该方法返回值转换后的元组对象\n\n```python\n>>> list1= ['Google', 'Taobao', 'Facebook', 'Baidu']\n>>> tuple1=tuple(list1)\n>>> print(tuple1)\n\n('Google', 'Taobao', 'Facebook', 'Baidu')\n```","categories":["Python系列"]},{"title":"Python数据类型之列表","url":"/2019/10/30/Python数据类型之列表/","content":"\n## 列表类型(list)\n\n\n### 1. 列表介绍\n列表是我们最以后最常用的数据类型之一，通过列表可以对数据实现最方便的存储、修改等操作。\n\n#### 1.1 定义方式\n```python\n# 定义：[]内可以有多个任意类型的值，逗号分隔\n\n# 定义方法1\n>>> l=['apple','banana','peach']\n>>> print(l)\n['apple', 'banana', 'peach']\n\n# 定义方法2\n>>> l=list(['apple','banana','peach'])\n>>> print(l)\n['apple', 'banana', 'peach']\n```\n\n------------\n\n\n### ★2. 常用列表方法\n#### 2.1 list[index] 访问列表中的值\n**语法说明**\n> 使用下标索引来访问列表中的值，下标从0开始计数\n\n```python\n# 通过下标访问列表中的值，下标从0开始计数\n>>> list1 = ['Google', 'Facebook', 'Baidu', 'Apple']\n>>> list1[0]\n'Google'\n```\n\n#### 2.2 list[index_start：index_end] 切片:取多个元素\n**语法说明**\n> 使用方括号的形式截取字符\n\n```python\n# 通过[]索引截取列表中的元素\n\n# 取下标1至下标4之间的数字，包括1，不包括4\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[1:4]\n['B', 'C', 'D']\n\n# 取下标1至-1的值，不包括-1\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[1:-1]\n['B', 'C', 'D', 'E']\n\n# 取下标0至3的值\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[0:3]\n['A', 'B', 'C']\n\n# 如果是从头取，则和上面例子相同，取下标0至3的值\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[:3]\n['A', 'B', 'C']\n\n# 如果想取最后一个，必须不能写-1，只能这么写\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[3:]\n['D', 'E', 'F']\n\n# 如果不想取最后一个，则要这样写，这样-1就不会被包含了\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[3:-1]\n['D', 'E']\n\n# 后面的2是代表，每隔一个元素，就取一个\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[0::2]\n['A', 'C', 'E']\n\n# 后面的2是代表，每隔一个元素，就取一个\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[::2]\n['A', 'C', 'E']\n```\n\n#### 2.3 append() 列表追加\n**语法说明**\n> list.append(obj)\n\n**参数说明**\n* obj -- 添加到列表末尾的对象。\n\n**返回值**\n> 该方法无返回值，但是会修改原来的列表。\n\n```python\n# append()对列表进行追加原色\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l.append(\"Baidu\")\n>>> list1\n[\"Google\", \"Facebook\", \"Taobao\",\"Baidu\"]\n```\n\n#### 2.4 insert() 列表元素插入\n**语法说明**\n> list.insert(index, obj)\n\n**参数说明**\n* index -- 对象obj需要插入的索引位置。\n* obj -- 要插入列表中的对象。\n\n**返回值**\n> 该方法没有返回值，但会在列表指定位置插入对象。\n\n```python\n# insert() 将指定对象插入列表的指定位置。\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l.insert(1, \"Baidu\")\n>>> l\n[\"Google\", \"Baidu\", \"Facebook\", \"Taobao\"]\n```\n\n#### 2.5 列表修改\n**语法说明**\n> list[index] = new_obj\n\n**参数说明**\n* index -- 对象new_obj需要写入的索引位置。\n\n**返回值**\n> 该方法没有返回值，但会在列表指定位置更新对象。\n\n```python\n# 将新对象赋值到指定位置\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l[1] = \"Baidu\"\n>>> l\n[\"Google\", \"Baidu\", \"Taobao\"]\n```\n\n#### 2.6 列表元素删除\n**语法说明**\n> del list[index]\n> list.remove(obj)\n> list.pop()\n\n**参数说明**\n* index -- 列表的索引位置。\n* obj -- 列表中的对象。\n\n**返回值**\n> 以上三种方法没有返回值，但会更新列表对元素对象，将指定元素删除\n\n - 2.6.1 del list[index]\n```python\n# del list[index] 删除列表指定位置的元素\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> del l[1]\n>>> l\n[\"Google\",\"Baidu\", \"Taobao\"]\n```\n\n - 2.6.2 list.remove(obj)\n```python\n# list.remove(obj) 删除列表指定对象\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> l.remove(\"Facebook\")\n>>> l\n[\"Google\",\"Baidu\", \"Taobao\"]\n```\n\n - 2.6.3 list.pop()\n```python\n# list.pop() 删除列表中最后一个对象\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> l.pop()\n>>> l\n[\"Google\", \"Facebook\", \"Baidu\"]\n```\n\n#### 2.7 extend() 列表扩展元素\n**语法说明**\n> list.extend(seq)\n\n**参数说明**\n* seq -- 元素列表。\n\n**返回值**\n> 该方法没有返回值，但会在已存在的列表中添加新的列表内容。\n\n```python\n# extend()用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。\n\n# 将由0至4的新列表l2扩展到l1列表最后\n>>> l1 = [\"Google\", \"Facebook\", \"Taobao\"]\n>>> l2=list(range(5))\n>>> l1.extend(l2)\n>>> l1\n[\"Google\", \"Facebook\", \"Taobao\", 0, 1, 2, 3, 4]\n```\n\n#### 2.8 count() 统计列表中某个元素出现的个数\n**语法说明**\n> list.count(obj)\n\n**参数说明**\n* obj -- 列表中统计的对象。\n\n**返回值**\n> 返回元素在列表中出现的次数。\n\n```python\n# count()用于统计某个元素在列表中出现的次数。\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\", \"Baidu\", \"Google\"]\n>>> l.count(\"Google\")\n2\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\", \"Baidu\", \"Google\"]\n>>> l.count(\"Facebook\")\n1\n```\n\n#### 2.9 sort() 列表排序\n**语法说明**\n> list.sort([func])\n\n**参数说明**\n* func -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。\n\n**返回值**\n> 该方法没有返回值，但是会对列表的对象进行排序。\n\n```python\n# sort()用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。\n\n# 列表中的元素都是数字，进行排序\n>>> l=[1,2,3,4,5,6,7,8,9]\n>>> l.sort()\n>>> l\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 列表中的元素都是字符串，进行排序\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.sort()\n>>> l\n['Baidu', 'Facebook', 'Google', 'Taobao']\n```\n\n#### 2.10 reverse() 列表翻转\n**语法说明**\n> list.reverse()\n\n**返回值**\n> 该方法没有返回值，但是会对列表的元素进行反向排序。\n\n```python\n# reverse()用于反向列表中元素。\n\n# 将列表中的元素反向排序至列表中\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.reverse()\n>>> l\n['Taobao', 'Facebook', 'Google', 'Baidu']\n```\n\n#### 2.11 index() 获取列表指定元素下标\n**语法说明**\n> list.index(obj)\n\n**参数说明**\n* obj -- 查找的对象。\n\n**返回值**\n> 该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。\n\n```python\n# index()用于从列表中找出某个值第一个匹配项的索引位置。\n\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.index(\"Taobao\")\n3\n```\n\n#### ☆2.12 copy() 浅拷贝 / copy.deepcopy() 深拷贝\n**语法说明**\n***copy()***\n> list.copy()\n\n***copy.deepcopy()***\n> copy.deepcopy(origin_list)\n\n**参数说明**\n* origin_list表示深拷贝所拷贝的原始列表\n\n**返回值**\n> 返回复制后的新列表。\n\n - 2.12.1 copy() 浅拷贝\n```python\n# copy()用于复制列表，类似于 a[:]\n\n# 将l1列表拷贝至l2列表中，l1与l2两列表元素相同\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = l1.copy()\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n\n# 注意，上述例子中如果在l1原始列表进行更改，l2列表会随之改变，此即为浅拷贝\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = l1.copy()\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n>>> l1[3].append(\"NewComer\")\n>>> l1\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n```\n\n - 2.12.2 copy.deepcopy() 深拷贝\n```python\n# copy.deepcopy()深拷贝，copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。\n\n# 与浅拷贝不同，深拷贝的情况下，如果在l1原始列表进行更改，l2列表不会随之改变，此即为深拷贝\n>>> import copy\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = copy.deepcopy(l1)\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n>>> l1[3].append(\"NewComer\")\n>>> l1\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n```\n\n - 2.12.3 深浅拷贝原理解析\n* ##### 浅拷贝\n![](/images/post_imgs/shallow.png)\n* ##### 深拷贝\n![](/images/post_imgs/deep.png)\n\n\n","categories":["Python系列"]},{"title":"Python数据类型之字符串类型","url":"/2019/10/24/Python数据类型之字符串类型/","content":"\n## 字符串类型(string)\n\n### 字符串介绍\n#### 定义方式\n在单引号、双引号、三引号内，由一串字符组成\n\n```python   \n#单引号\nname='Elijah'\n\n#双引号\ntitle=\"Python developer\"\n\n#三引号，表示多行的字符串，可以在三引号中自由的使用单引号和双引号\nmessage=\n'''\n立志成为一名\"身体健康\"的'开发者'\n'''\n```\n\n---\n\n### ★常用字符串方法\n#### strip() / lstrip() / rstrip() 去除指定字符串(默认去除空格)\n\n```python\n# strip() 去掉字符串前后的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.strip()\n\"Hello World\"\n\n# lstrip() 去掉字符串左边(left)的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.lstrip()\n\"Hello World   \"\n\n# rstrip() 去掉字符串右边(right)的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.rstrip()\n\"   Hello World\"\n\n# strip(\"str_args\") 去掉字符串前后的指定字符(传入指定字符参数情况下)\n# lstrip(\"str_args\")与rstrip(\"str_args\")同理\n>>> s = \"***Hello World***\"\n>>> s.strip('*')\n\"Hello World\"\n```\n\n#### startswith() / endswith() 判断字符串开头/结尾\n\n```python\n# startswith(\"str_args\") 判断目标字符串是否以指定字符串开头\n>>> s=\"Hello_World\"\n>>> s.startswith(\"Hello\")\nTrue\n\n>>> s=\"Hello_World\"\n>>> s.startswith(\"ello\")\nFalse\n\n# endswith(\"str_args\") 判断目标字符串是否以指定字符串结尾\n>>> s=\"Hello_World\"\n>>> s.endswith(\"World\")\nTrue\n\n>>> s=\"Hello_World\"\n>>> s.endswith(\"Worl\")\nFalse\n```\n\n\n#### replace() 替换字符串\n**语法说明**\n> str.replace(old, new[, max])\n\n**参数说明**\n* old -- 将被替换的子字符串。\n* new -- 新字符串，用于替换old子字符串\n* max -- 可选字符串, 替换不超过 max 次\n\n```python\n# replace() 替换字符串，传入参数依次为旧字符串、新字符串、替换最大次数\n>>> s=\"Hello World\"\n>>> s.replace(\"World\",\"Python\")\n\"Hello Python\"\n\n>>> s=\"In the apple case, there is a red apple beside the green apple.\"\n>>> s.replace(\"apple\",\"peach\",2)\n\"In the peach case, there is a red peach beside the green apple.\"\n```\n\n#### format() 格式化字符串\n**语法说明**\n>* 格式化字符串的函数 str.format()，它增强了字符串格式化的功能\n>* 基本语法是通过 {} 和 : 来代替以前的 %\n>* format 函数可以接受不限个参数，位置可以不按顺序\n\n```python\n# format() 格式化字符串，不设置指定位置，按默认顺序\n>>>\"{} {}\".format(\"hello\", \"world\")\n'hello world'\n\n# format() 格式化字符串，设置指定位置\n>>> \"{arg_2} {arg_1}\".format(arg_2=\"hello\", arg_1=\"world\")\n'hello world'\n\n# format() 格式化字符串，设置指定位置\n>>> \"{1} {0} {1}\".format(\"hello\", \"world\")\n'world hello world'\n```\n\n - 2.4.1 数字格式化\n> 下表展示了 str.format() 格式化数字的多种方法：\n\n```python\n>>> print(\"{:.2f}\".format(3.1415926));\n3.14\n```\n\n**格式化符号说明**\n\n* '^'、'<'、'>' 分别是居中、左对齐、右对齐，后面带宽度， ':' 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。\n* '+' 表示在正数前显示 '+'，负数前显示 '-'\n* ' '（空格）表示在正数前加空格\n* 'b'、'd'、'o'、'x' 分别是二进制、十进制、八进制、十六进制。\n* 此外我们可以使用大括号 '{}' 来转义大括号，如下实例\n\n```python\n>>> print (\"{} 对应的位置是 {{0}}\".format(\"yang\"))\nyang 对应的位置是 {0}\n```\n\n| 数字| 格式 | 输出| 描述|\n|---|---|---|---|\n| 3.1415926  | {:.2f}           | 3.14      | 保留小数点后两位            |\n| 3.1415926  | {:+.2f}          | +3.14     | 带符号保留小数点后两位       |\n| -1         | {:+.2f}          | -1.00     | 带符号保留小数点后两位       |\n| 2.71828    | {:.0f}           | 3         | 不带小数                    |\n| 5          | {:0>2d}          | 05        | 数字补零 (填充左边, 宽度为2) |\n| 5          | {:x<4d}          | 5xxx      | 数字补x (填充右边, 宽度为4)  |\n| 10         | {:x<4d}          | 10xx      | 数字补x (填充右边, 宽度为4)  |\n| 1000000    | {:,}             | 1,000,000 | 以逗号分隔的数字格式         |\n| 0.25       | {:.2%}           | 25.00%    | 百分比格式                  |\n| 1000000000 | {:.2e}           | 1.00e+09  | 指数记法                    |\n| 13         | {:10d}           | 13        | 右对齐 (默认, 宽度为10)      |\n| 13         | {:<10d}          | 13        | 左对齐 (宽度为10)           |\n| 13         | {:^10d}          | 13        | 中间对齐 (宽度为10)         |\n| 11         |'{:b}'.format(11) | 1011      | 进制                       |\n|            |'{:d}'.format(11) |11         |                            |\n|            |'{:o}'.format(11) |13         |                            |\n|            |'{:x}'.format(11) |b          |                            |\n|            |'{:#x}'.format(11)|0xb        |                            |\n|            |'{:#X}'.format(11)|0xB        |                            ||\n\n#### find() / rfind() 查找字符串位置、index() / rindex() 查找字符串位置、count() 查找字符串出现次数\n\n**语法说明**\n***find()***\n> str.find(str, beg=0, end=len(string))\n\n***index()***\n> str.index(str, beg=0, end=len(string))\n\n***count()***\n> str.count(str, beg= 0,end=len(string))\n\n**参数说明**\n* str -- 指定检索的字符串\n* beg -- 开始索引，默认为0\n* end -- 结束索引，默认为字符串的长度\n\n**返回值**\n***find()***\n> 如果包含子字符串返回开始的索引值，否则返回-1。\n> rfind() 返回字符串最后一次出现的位置，其他属性与find()相同\n\n***index()***\n> 如果包含子字符串返回开始的索引值，否则报异常。\n> rindex() 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，可以指定可选参数[beg:end]设置查找的区间。\n\n***count()***\n> 该方法返回子字符串在字符串中出现的次数,顾头不顾尾,如果不指定范围则查找所有\n\n - find() / rfind() 查找字符串位置\n \n```python\n# find() 查找字符串位置/ rfind()返回字符串最后一次出现的位置，其他属性与find()相同\n\n# 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0\n>>> s='abca'\n>>> s.find('a')\n0\n\n# 从下标1开始，查找在字符串里第一个出现的子串：返回结果3\n>>> s='abca'\n>>> s.find('a',1)\n3\n\n# 查找不到返回-1\n>>> s='abca'\n>>> s.find('3')\n-1\n>>>\n```\n\n - index() / rindex() 查找字符串位置\n \n```python\n# index() 查找字符串位置/ rindex()返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，可以指定可选参数[beg:end]设置查找的区间。\n\n# 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0\n>>> s='abca'\n>>> s.index('a')\n0\n# 从下标1开始，查找在字符串里第一个出现的子串：返回结果3\n>>> s='abca'\n>>> s.index('a',1)\n3\n# 查找不到报异常\n>>> s='abca'\n>>> s.find('3')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: substring not found\n```\n\n - count() 查找字符串出现次数\n \n```python\n# count() 该方法返回子字符串在字符串中出现的次数,顾头不顾尾,如果不指定范围则查找所有。\n\n# 查找a出现的次数，没有指定范围默认查找所有\n>>> s='abca'\n>>> s.count('a')\n2\n\n# 查找a出现的次数，指定范围从1到4,返回1次\n>>> s='abca'\n>>> s.count('a',1,4)\n1\n\n# 查找z出现的次数，没有则返回0次\n>>> s='abca'\n>>> s.count('z')\n0\n```\n\n\n#### split() / rsplit() 切分字符串\n\n**语法说明**\n> str.split(str=\"\", num=string.count(str))\n\n**参数说明**\n* str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。\n* num -- 分割次数。\n\n**返回值**\n> 返回分割后的字符串列表。返回分割后的字符串列表。\n> rsplit()表示从右向左开始切分\n\n```python\n# split() 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 / rsplit() 表示从右向左开始进行切分，其他同split()\n\n# 默认以空格进行分割，也就是下例中的\\n\n>>> s=\"Line1-abcdef \\nLine2-abc \\nLine4-abcd\";\n>>> s.split( )\n['Line1-abcdef', 'Line2-abc', 'Line4-abcd']\n\n# 指定的切片次数为1次，所以后面的两个\\n保留\n>>> s.split(' ', 1 )\n['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd']\n\n# rsplit() 从右向左以'|'字符进行切分，切分次数为1次\n>>> s='a|b|c'\n>>> s.rsplit('|',1)\n['a|b', 'c']\n```\n\n\n#### join() 连接字符串\n**语法说明**\n> str.join(sequence)\n\n**参数说明**\n* sequence -- 要连接的元素序列。\n\n**返回值**\n> 返回通过指定字符连接序列中元素后生成的新字符串。\n\n```python\n# join() 连接字符串\n\n# 将序列seq中的元素'a','b','c'以指定的字符'-'连接生成一个新的字符串。\n>>> s=\"-\"\n>>> seq=(\"a\", \"b\", \"c\")\n>>> s.join(seq)\n\"a-b-c\"\n```\n\n\n#### center() / ljust() / rjust() / zfill() 填充字符串\n**语法说明**\n***center()***\n> str.center(width[, fillchar])\n\n***ljust()***\n> str.ljust(width[, fillchar])\n\n***rjust()***\n> str.rjust(width[, fillchar])\n\n***zfill()***\n> str.zfill(width)\n\n\n**参数说明**\n* width -- 指定字符串长度。\n* fillchar -- 填充字符，默认为空格。\n\n**返回值**\n***center()***\n> 返回一个指定的宽度 width 居中的字符串，如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充。\n\n***ljust()***\n> 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n***rjust()***\n> 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。\n\n***zfill()***\n> 返回指定长度的字符串。\n\n - center() 填充字符串\n \n```python\n# center() 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。\n\n# 指定字符串长度为40，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.center(40, '*')\n\"**********[www.elijahyang.com]**********\"\n```\n\n - ljust() 填充字符串(左对齐)\n \n```python\n# ljust() 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n# 指定字符串长度为40，左对齐，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.ljust(40, '*')\n\"[www.elijahyang.com]********************\"\n```\n\n - rjust() 填充字符串(右对齐)\n \n```python\n# rjust() 返回一个原字符串右对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n# 指定字符串长度为40，右对齐，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.rjust(40, '*')\n\"********************[www.elijahyang.com]\"\n```\n\n - zfill() 填充字符串(右对齐,填充0)\n \n```python\n# zfill() 返回指定长度的字符串，原字符串右对齐，前面填充0。\n\n# 指定字符串长度为40，右对齐，用0来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.zfill(40)\n\"00000000000000000000[www.elijahyang.com]\"\n```\n\n\n#### expandtabs() 把tab转换成空格\n**语法说明**\n> str.join(sequence)\n\n**参数说明**\n* tabsize -- 指定转换字符串中的 tab 符号('\\t')转为空格的字符数。\n\n**返回值**\n> 该方法返回字符串中的 tab 符号('\\t')转为空格后生成的新字符串。\n\n```python\n# expandtabs() 指定转换字符串中的 tab 符号('\\t')转为空格的字符数。\n\n# 将s字符串中\\t转换为空格(默认\\t空格数为8)\n# 实际操作中\\t的默认转换为空格数为1\n>>> s=\"this is\\tstring example\"\n>>> s.expandtabs()\n\"this is string example\"\n\n# 将s字符串中\\t转换为空格(指定\\t空格数为16)\n>>> s=\"this is\\tstring example\"\n>>> s.expandtabs(16)\n\"this is         string example\"\n```\n\n\n#### lower() / upper() 字符串英文大小写转换\n**语法说明**\n> str.lower()\n> str.upper()\n\n**返回值**\n> 返回将字符串中所有大写字符转换为小写后生成的字符串。\n> 返回将字符串中所有大写字符转换为大写后生成的字符串。\n\n - lower() 字符转换为小写\n \n```python\n# lower() 将字符串中所有字符转换为小写\n\n>>> s=\"HELLO WORLD\"\n>>> s.lower()\n\"hello world\"\n```\n\n - upper() 字符转换为大写\n \n```python\n# upper() 将字符串中所有字符转换为大写\n\n>>> s=\"hello world\"\n>>> s.upper()\n\"HELLO WORLD\"\n```\n\n\n#### capitalize() 首字母大写 / swapcase() 大小写翻转 / title() 每个单词的首字母大写\n\n**语法说明**\n> str.capitalize()\n> str.swapcase()\n> str.title()\n\n**返回值**\n***capitalize()***\n> 该方法返回一个首字母大写的字符串。\n\n***swapcase()***\n> 返回大小写字母转换后生成的新字符串。\n\n***title()***\n> 返回\"标题化\"的字符串,就是说所有单词都是以大写开始。\n\n\n - capitalize() 首字母大写\n \n```python\n# capitalize() 首字母大写\n\n>>> s=\"this is string example from yang\"\n>>> s.capitalize()\n\"This is string example from yang\"\n```\n\n - swapcase() 大小写字母互换\n \n```python\n# swapcase() 大小写字母互换\n\n>>> s=\"tHiS Is sTrINg eXaMPle FRoM YaNg\"\n>>> s.swapcase()\n\"ThIs iS StRinG ExAmpLE frOm yAnG\"\n```\n\n - title() 每个单词的首字母大写\n```python\n# title() 每个单词的首字母大写\n\n>>> s=\"this is string example from yang\"\n>>> s.title()\n\"This Is String Example From Yang\"\n```\n\n\n#### maketrans() 字符串对照表翻译\n\n**语法说明**\n> str.maketrans(intab, outtab)\n\n**参数说明**\n* intab -- 字符串中要替代的字符组成的字符串。\n* outtab -- 相应的映射字符的字符串。\n\n**返回值**\n>返回字符串转换后生成的新字符串。\n\n```python\n# maketrans() 用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。\n\n# 用12345来代替原本字符串那种的aeiou字符\n>>> intab = \"aeiou\"\n>>> outtab = \"12345\"\n>>> trantab = str.maketrans(intab, outtab)\n>>> str = \"this is string example\"\n>>> str.translate(trantab)\n\"th3s 3s str3ng 2x1mpl2\"\n```\n\n\n#### len() 字符串长度\n\n**语法说明**\n> len( s )\n\n**参数说明**\n* s -- 对象。\n\n**回值**\n>返回对象长度。\n\n```python\n#  字符串长度\n\n>>> s=\"yang\"\n>>> len(s)\n4\n```\n\n\n#### str[::-1] 字符串翻转*\n\n```python\n# [::-1]通过步进反转\n\n>>> s = 'abcd'\n>>> new_s = s[::-1]\n>>> new_s\n'dcba'\n```\n\n### 其他字符串方法\n#### is数字系列(在python3中)\n\n - isdigt() 判断是否是数字(bytes、unicode)\n > 对于bytes、unicode使用isdigt()方法，返回True，其他返回False\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum1.isdigit()\nTrue\nnum2.isdigit()\nTrue\nnum3.isdigit()\nFalse\nnum4.isdigit()\nFalse\n```\n\n - isdecimal() 判断是否只包含十进制字符(unicode)\n>对于unicode使用isdecimal()方法，返回True，其他返回False\n>bytes类型无isdecimal()方法\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum2.isdecimal()\nTrue\nnum3.isdecimal()\nFalse\nnum4.isdecimal()\nFalse\n```\n\n - isnumeric() 判断是否是否只由数字组成(unicode)\n> 对于unicode使用isnumeric()方法，返回True，其他返回False\n> bytes类型无isnumeric()方法\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum2.isnumeric()\nTrue\nnum3.isnumeric()\nTrue\nnum4.isnumeric()\nTrue\n```\n\n - Tips\n> 以上isdigit() 、 isdecimal() 、 isnumeric() 均不能判断浮点数\n\n\n\n#### is其他系列(在python3中)\n - isalnum() 判断是否由字母和数字组成\n> 字符串至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False\n\n```python\n>>> str = \"yang0827\"\n>>> str.isalnum()\nTrue\n\n>>> str = \"www.baidu.com\"\n>>> str.isalnum()\nFalse\n```\n\n - isalpha() 判断是否只由字母组成\n> 如果字符串至少有一个字符并且所有字符都是字母则返回 True,否则返回 False\n\n```python\n>>> s=\"yang\"\n>>> s.isalpha()\nTrue\n\n>>> s=\"yang example....!!!\"\n>>> s.isalpha()\nFalse\n```\n\n - isidentifier() 判断是否是合法的标识符\n> 如果字符串是合法的标识符则返回 True,否则返回 False\n\n```python\n>>> s=\"_a\"\n>>> s.isidentifier()\nTrue\n\n>>> s=\"中国\"\n>>> s.isidentifier()\nTrue\n\n>>> s=\"3a\"\n>>> s.isidentifier()\nFalse\n```\n\n - islower() 判断是否由小写字母组成\n> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False\n\n```python\n>>> s=\"this is a example\"\n>>> s.islower()\nTrue\n\n>>> s=\"This is a example\"\n>>> s.islower()\nFalse\n```\n\n - isupper() 判断是否由大写字母组成\n> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False\n\n```python\n>>> s=\"THIS IS A EXAMPLE\"\n>>> s.isupper()\nTrue\n\n>>> s=\"This Is A Example\"\n>>> s.isupper()\nFalse\n```\n\n - isspace() 判断是否只由空白字符组成\n> 如果字符串中只包含空格，则返回 True，否则返回 False\n\n```python\n>>> s=\"      \"\n>>> s.isspace()\nTrue\n\n>>> s=\"this is a example\"\n>>> s.isspace()\nFalse\n```\n\n -istitle() 判断是否字符串中所有的单词拼写首字母是否为大写，且其他字母为小写\n> 如果字符串中所有的单词拼写首字母是否为大写，且其他字母为小写则返回 True，否则返回 False\n\n```python\n>>> s=\"This is a example\"\n>>> s.istitle()\nTrue\n\n>>> s=\"This Is A Example\"\n>>> s.istitle()\nFalse\n```","categories":["Python系列"]},{"title":"Python数据类型之布尔类型","url":"/2019/10/13/Python数据类型之布尔类型/","content":"\n## 布尔类型(boolean)\n布尔值只有True和False，同时True对应二进制中1，False对应二进制中0\n\n### 布尔运算\n> 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。\n#### 与运算\n> 只有两个布尔值都为 True 时，计算结果才为 True。\n\n| 值 | 运算符 | 值 | 结果 |\n|:----: | :----: | :----: | :----: |\n| True | and | True | True |\n| True | and | False | False |\n| False| and | True | False |\n| False| and | False | False |\n\n#### 或运算\n>只要有一个布尔值为 True，计算结果就是 True。\n\n| 值 | 运算符 | 值 | 结果 |\n|:----: | :----: | :----: | :----: |\n| True | or | True | True |\n| True | or | False | True |\n| False| or | True | True |\n| False| or | False | False |\n\n#### 非运算\n>把True变为False，或者把False变为True：\n\n| 运算符 | 值 | 结果 |\n| :----: | :----: | :----: |\n| not | True | False |\n| or | False | True |\n\n#### 短路计算\n在Python中，布尔类型还可以与其他数据类型做 and、or和not运算\n\n```python\na = True\nprint a and 'a=T' or 'a=F\n```\n\n计算结果不是布尔类型，而是字符串 'a=T'，这是为什么呢？\n因为Python把0、空字符串''和None看成 False，其他数值和非空字符串都看成 True，所以：\n\n```python\nTrue and 'a=T' 计算结果是 'a=T'\n继续计算 'a=T' or 'a=F' 计算结果还是 'a=T'\n```\n\n要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。\n - 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。\n - 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。\n\n`所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果`","categories":["Python系列"]},{"title":"Python数据类型之数字","url":"/2019/10/11/Python数据类型之数字/","content":"\n## 数字类型(integer)\n\n### 整型(int)\n在32位机器上，整数的位数为32位，取值范围为-2\\*\\*31～2\\*\\*31-1，即-2147483648～2147483647\n在64位系统上，整数的位数为64位，取值范围为-2\\*\\*63～2\\*\\*63-1，即-9223372036854775808～9223372036854775807\n\n### 长整型(long) \n和C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。 \n自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。\n\n```python\n# 在python2.x 中（python3.x中没有长整型的概念）：\n>>> num=2L\n>>> type(num)\n    <type 'long'>\n```\n\n### 浮点型(float)\n浮点数用来处理实数，也就是带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。\n\n### 复数(complex)  \n复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。\n\n\n```python\n>>> x=1-2j\n>>> x.real\n1.0\n>>> x.imag\n-2.0\n```\n\n### 进制转换\n\n```txt\nbin(var) # 把变量转换为2进制\noct(var) # 把变量转换为8进制\nint(var) # 把变量转换为10进制\nhex(var) # 把变量转换为16进制\n```\n\n### 小知识点\n - Python中存在小数字池：`-5 ～ 256，即[-5,257]`\n\nPython对小整数的定义是[-5,257]这些整数对象是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。\n同理，单个字母也是这样的。\n\n在一般情况下当变量被赋值后，内存和变量的关系如下：\n\n```python\n# 方式一\nn1 = 123\nn2 = 123\n```\n![](/images/post_imgs/integer_1.png)\n\n\n```python\n# 方式二\nn1 = 123\nn2 = n1\n```\n\n![](/images/post_imgs/integer_2.png)\n\n\n由于python内的优化机制，不论是2.x还是3.x都存在，在-5~257之间的数，如果使用第一种赋值方式，那么他们依然属于同一块内存\n\n```python\nprint(id(n1)) # 查看变量的内存地址\n```\n\n\n","categories":["Python系列"]},{"title":"python IDE介绍 & 环境搭建","url":"/2019/09/25/python IDE介绍&环境搭建/","content":"\n## Python2.x VS Python3.x\n### 为什么会有Python3.x\n相信但凡接触过python语言的朋友在接触之初会有“到底用python2还是python3？”的纠结。其实我也有这方面的疑问，为什么python的核心团队不能统一一下呢？非要搞个2.x和3.x，而且3.x还不能向下兼容，这中操作让曾经已经用python2.x编写完成的项目情何以堪，还要费神费力去升级成python3.x，到底是什么因素导致必须要重构python核心内容呢？\n通过多方调查，终于在Python的核心成员**Brett Cannon**的文章中略知其中一二。首先，我们先来看以下下面这个字符串表示什么意思？\n```python\n'abcd'\n```\n一目了然，代表由字母'a'、'b'、'c'、'c'组成的字符串，但是，如果你是个python2的使用者，你也可能会说代表ASCII码对应的数值97、98、99、100，至此，大家就会看出问题了，那在python2.x中，字符串默认是以ASCII码的形式呈现的，这样的设计就会产生我们上面这样的歧义。正如python之禅中所说\"there should be one -- and preferably only one -- obvious way to do it\"，对于python的代码，应该做到一种呈现只对应一种可能，而上述例子中显然就违背了这样的原则。而这种歧义的产生，不单单是违背了语言的设计初衷，更严重的是这种歧义会在程序的开发中让人抓狂，因为对于字符串而言，开发者必须时刻清楚的知道它代表的到底是字符串还是二进制的数据，否则对于大型程序而言，后果不堪设想。\n相信上面的内容会让大家清楚Python2.x所存在的重大缺陷，但是我们的问题依然没有得到很好的回答，我们还会抱有疑问“那为什么不在最开始设计的时候就避免出现这种缺陷呢？一定要在之后再做这种不兼容的修复？”，这就要回到python的诞生了，Guido于1989年12月开始对Python进行编码，并于1991年2月首次以开源形式发布。而Unicode标准的第一卷是在1991年10月发布的，这说明python在设计之初并没有所谓的unicode和ASCII编码的问题，但是随着python的应用程度越来越广泛，ASCII码已经不能满足其需要，而且unicode编码的应用和推广也越来越广泛，python2的缺陷也就显得越来越不可调和，最终导致核心团队必须将其升级来修复这个致命的问题。\n多说一句，针对为什么python3不向下兼容的问题，Brett Cannon是这样说的，python的核心团队在设计推广python3的时候以为python社区会针对python2进行bugfix，同时转到python3，但是事实并未如此，核心团队也吃一堑长一智，并保证今后不会再有类似的不可兼容的更新升级了。\n\n\n### 官方对于Python2.x和Python3.x的总结\n**In summary** : Python 2.x is legacy, Python 3.x is the present and future of the language Python 3.0 was released in 2008. The final 2.x version 2.7 release came out in mid-2010, with a statement of extended support for this end-of-life release. The 2.x branch will see no new major releases after that. 3.x is under active development and has already seen over five years of stable releases, including version 3.3 in 2012, 3.4 in 2014, and 3.5 in 2015. This means that all recent standard library improvements, for example, are only available by default in Python 3.x.\n\n**Guido van Rossum** (the original creator of the Python language) decided to clean up Python 2.x properly, with less regard for backwards compatibility than is the case for new releases in the 2.x range. The most drastic improvement is the better Unicode support (with all text strings being Unicode by default) as well as saner bytes/Unicode separation.\n\n**Besides**, several aspects of the core language (such as print and exec being statements, integers using floor division) have been adjusted to be easier for newcomers to learn and to be more consistent with the rest of the language, and old cruft has been removed (for example, all classes are now new-style, \"range()\" returns a memory efficient iterable, not a list as in 2.x).\n\n---\n\n## Python IDE介绍\n### Pycharm\n> http://www.jetbrains.com/pycharm/download/\n\nPycharm是由JetBrains公司推出的一款专门针对python开发者的IDE，秉承JetBrains的一贯风格，Pycharm具有调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制等基本功能。同时Pycharm对于Django、Flask等常用Web框架也做到了很好的支持。需要重点提出的是Pycharm还支持IronPython解释器。\n\n![](/images/post_imgs/pycharm.jpeg)\n\n### Sublime \n> https://www.sublimetext.com/3\n\n'A sophisticated text editor for code, markup and prose.'这是Sublime对自己的定位，不得不说sublime的强大、轻量和便捷。相比Pycharm等其他IDE的庞大，sublime作为一种“记事本”类型的IDE，深受追求简洁的开发者的热爱，同时轻量并不代表功能简单，其拥有的各种插件也是没有找不到，只有想不到。相信只要用过sublime的人就一定不会舍弃他。\n\n![](/images/post_imgs/sublime.jpg)\n\n### Visual Studio Code \n> https://code.visualstudio.com/\n\nVS code也是一款极为优秀的IDE。这款IDE拥有丰富的python扩展工具以便开发者可以更高效的进行项目的开发，包括代码静态分析语法自动不全、科学计算工具，与Jupyter 等工具的集成，重构，单元测试，调试等等。\n\n![](/images/post_imgs/vs_code.png)\n\n### Eclipse + Pydev\n> https://www.eclipse.org/ide/\n\n使用这种搭配的开发者基本上已经是个经验丰富的developer了，或者更明确的说很可能是一名Java开发老手，Eclipse这款IDE更广泛的被众多Java开发者所使用，如果已经习惯了Eclipse的操作，可以配以Pydev进行python项目的开发，可以在Eclipse中点击Help→Install new Software，添加pydev的安装地址：http://pydev.org/updates/，获取python的相关套件。具体操作方法请自行查阅，不过多赘述。\n\n\n### 其他\n当然python作为一种世界的编程语言，更何况现在的发展势头越来越火，IDE作为方便开发者的工具更是必不可少，以上只是介绍了极为有限的几款比较热门的python开发IDE，更多的python开发IDE请参阅：https://wiki.python.org/moin/PythonEditors\n\n---\n\n## Python开发环境搭建\n### 两种python虚拟环境工具介绍\n\n#### virtualenv\n> https://virtualenv.pypa.io/en/latest/#\n\n - 基本介绍\n**virtualenv**是用于创建隔离的Python环境，以达到不同的项目环境互不影响的目的。\n\n - virtualenv安装与使用\n\n```txt\n1、pip安装virtualenv\n>>> pip install virtualenv\n\n2、验证安装是否成功\n>>> virtualenv --version\n\n3、为项目创建隔离的python\n>>> cd  python_project\n>>> virtualenv python_project_env  # 这样是使用默认python解释器创建出来的项目\n\n4、也可以指定python解释器创建项目\n>>> virtualenv -p /usr/bin/python3.7 python3_project_env\n\n5、以上就完成了python虚拟环境的创建，该环境是一个独立的python运行环境，我们在需要使用该环境时可以将其激活\n>>> source python_project_env/bin/activate\n\n6、退出虚拟环境\n>>> deactivate\n\n```\n\n\n#### pipenv\n> https://pypi.org/project/pipenv/\n\n - 基本介绍\n**pipenv** 是 Pipfile 、requests 作者 Kenneth Reitz 写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile和pipenv本来都是Kenneth Reitz的个人项目，后来贡献给了pypa组织。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。\n**Pipfile的基本理念是：**Pipfile 文件是 TOML 格式而不是 requirements.txt 这样的纯文本。一个项目对应一个 Pipfile，支持开发环境与正式环境区分。默认提供 default 和 development 区分。提供版本锁支持，存为 Pipfile.lock。\n\n - pipenv安装与使用\n\n```txt\n1、pip安装pipenv\n>>> pip install pipenv\n\n2、验证安装是否成功\n>>> pipenv --version\n\n3、切换到项目目录\n>>> cd  python_project\n\n4、创建虚拟环境，可以指定用python2 或者 python3作为当前虚拟环境的python版本\n>>> pipenv --two\n>>> pipenv --three\n>>> pipenv --python 3.7  # 也可以指定Python版本来创建虚拟环境\n\n4、激活当前虚拟环境\n>>> pipenv shell\n\n5、在虚拟环境下给项目安装需要的模块，并将其写入到pipfile\n>>> pipenv install django=1.11.11\n\n6、退出虚拟环境\n>>> exit\n\n```\n\n - pipenv其他常用操作\n\n```txt\n1、查看项目位置\n>>> pipenv --where\n\n2、查看虚拟环境位置\n>>> pipenv --venv\n\n3、查看解释器信息\n>>> pipenv --py\n\n4、查看包的依赖结构\n>>> pipenv graph\n\n5、卸载模块\n>>> pipenv uninstall django\n\n6、卸载全部包并从Pipfile中移除\n>>> pipenv uninstall --all\n\n7、检查安全漏洞\n>>> pipenv check\n\n```\n\n### Windows下Python环境搭建\n\n与大多数UNIX系统和服务不同，Windows系统没有预安装Python。为了使Python可用，很多年来CPython 团队已经编译了每一个 [release](https://www.python.org/download/releases/) 的Windows安装程序（MSI 包）。这些安装程序主要用于每个用户单独安装Python时，添加核心解释器和库。安装程序还可以为一台机器的所有用户安装，并且可以为应用程序本地分发提供单独的zip文件。\n\n#### 安装包种类\n> https://www.python.org/downloads/\n\n - 32位/64位Python2.x安装包\n - 32位/64位Python3.x安装包\n - web installer（网络安装包）是一个小的初始化工具，它将在安装过程中，根据需要自动下载所需的组件。\n - offline installer（离线安装包）内含默认安装所需的组件，可选择功能仍需要Internet连接下载\n\n#### 官网下载python安装包\n\n> 此处以安装64位python3.x为例\n\n![](/images/post_imgs/win_installer.png)\n\n如果选择`立即安装`：\n - 不需要管理员权限\n - Python将安装到用户目录中\n - 将根据第一页底部的选项安装\n - 将安装标准库，测试套件，启动器和pip\n - 如果选择将安装目录将添加到 `PATH`\n - 快捷方式仅对当前用户可见\n\n如果选择`自定义安装`：\n - 要安装的功能\n - 安装位置\n - 其他选项或安装后的操作。\n - 如果要安装调试符号或二进制文件，需要使用此选项。\n\n#### ☆无UI安装\n - 要完全隐藏安装程序UI并静默安装Python，可以使用 `/quiet` 选项。\n - 要跳过用户交互但仍然显示进度和错误，可以使用 `/passive` 选项。\n - 可以通过 `/uninstall` 选项立即开始删除Python，即不会显示任何提示。\n - 例如，要以静默方式全局安装默认的Python，使用以下命令:\n\n```python\npython-3.7.4.exe /quiet InstallAllUsers=1 PrependPath=1 Include_test=0\n```\n\n#### 验证安装\n - 在命令行输入`python --version`以验证是否安装成功\n\n![](/images/post_imgs/version.png)\n\n\n### Linux(CentOS7.x)下Python环境搭建\n由于CentOS等大多数Linux发行版中默认安装了python2.7版本，但是对于python开发者而言python3.x的许多特性才是未来，所以本文介绍如何在CentOS7.x操作系统下安装python3.x。\n\n#### 安装依赖包\n - 在CentOS系统中安装python需要 GCC 编译器和 make 编译工具，其包含在 Development tools 软件组中，所以需要安装Development tools 软件组。\n```shell\nsudo yum groupinstall \"Development tools\"\n```\n\n - Python3.x 源文件使用 zlib 格式打包，所以需要安装 zlib 软件包,同时python在编译安装时需要使用 zlib 的头文件和链接库，所以需要安装 zlib 的头文件和链接库 zlib-devel 软件包。\n```shell\nsudo yum -y install zlib zlib-devel\n```\n\n - Python3.x 有个内置模块 ctypes，它是 Python3.x 的外部函数库，需要使用系统外部函数库（libffi）的头文件和链接库，所以需要安装外部函数库（libffi）头文件和链接库 libffi-devel 软件包。\n```shell\nsudo yum -y install libffi-devel\n```\n\n - 同时还需要一些其他python安装需要的模块，在此不一一做解释\n```shell\nsudo yum -y install bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n```\n\n#### 下载安装包解压\n```shell\ncd 安装包下载目录\nwget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tar.xz\ntar -xvJf  Python-3.7.4.tar.xz\n```\n\n#### 编译安装\n```shell\nmkdir /usr/local/python3  # 创建编译安装目录\ncd Python-3.7.4\n./configure --prefix=/usr/local/python3\nmake && make install\n```\n\n#### 创建软链接\n```shell\nln -s /usr/local/python3/bin/python3 /usr/local/bin/python3\nln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n```\n\n#### 验证安装\n- 在命令行输入`python --version`以验证是否安装成功\n\n\n### MacOS下Python环境搭建\nMacOS附带Apple预安装的Python2.7。同样，对于python开发者而言，肯定是需要python3.x环境的，那么如果选择从python官网安装较新的 Python 版本，那么Mac上将安装两个不同版本的Python ，因此在使用过程中python解释器的路径与想要执行的python版本一致非常重要。\n\n#### 官网下载python安装包\n> https://www.python.org/downloads/release/python-374/\n\n![](/images/post_imgs/mac-python.jpg)\n\n#### 验证安装\n - 在命令行输入`python --version`以验证是否安装成功\n\n#### 配置环境变量\n - 打开`.bash_profile`\n```shell\nvi ~/.bash_profile\n```\n\n - 添加别名，使python命令指向python3.x解释器\n```shell\nalias python=/usr/local/bin/python3.7\n```\n\n - 生效文件\n```shell\nsource .bash_profile\n```\n","categories":["Python系列"]},{"title":"Go语言起源","url":"/2019/09/22/Go语言起源/","content":"\n## Go语言的前世今生\n### 时代背景\n当今社会主流语言基本都诞生于上世纪90年代或者更早，例如Python(1991)、Java(1995)、C(1972)、C++(1983)、JavaScript(1995)、C#(2001)、PHP(1995)等等，同时我们也需要明白计算机硬件的发展，在2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了，那就是双核和多核处理器的时代。我们结合这些标志性的事件来看就不难发现，主流的服务端语言诞生的年代还都是单核年代，也就是说，当时的编程语言还是单核环境下，也就没有我们现在大家耳熟能详的并发编程概念。\n\n[![2019年9月编程语言趋势](/images/post_imgs/trending.png \"2019年9月编程语言趋势\")](https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019?utm_source=spectrum-hero \"2019年9月编程语言趋势\")\n\n---\n\n### Go语言的诞生\nGo（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。\n罗伯特·格瑞史莫，罗勃·派克（Rob Pike）及肯·汤普逊于2007年9月开始设计Go，谷歌把Go作为一个20%项目开始研发，即让员工抽出本职工作之外时间的20%，投入在该项目上，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。Go于2009年11月正式宣布推出，成为开放源代码项目，支持Linux、Mac OS X、Windows等操作系统。\n对比上文所举的编程语言，在Go语言诞生的2007年，那时候已经处于双核时代，这就造就了Go语言在设计之初就考虑到了多核CPU下的程序运行，这也就造就了Go语言天生支持多核环境下编程的天赋技能。\n\n---\n\n### Go语言的主要特性\nGoogle是这样描述Go语言的：“[试图将像Python这样的动态语言的工作开发速度与C或C ++等编译语言的性能和安全性结合起来。在我们的Go to date实验中，典型的构建感觉瞬间完成; 甚至大型二进制文件只需几秒钟即可编译。编译后的代码接近C的速度.Go旨在让您快速移动。我们希望Go成为一种优秀的系统编程语言，支持多处理和面向对象设计的全新轻量化，具有真正的闭包和反射等一些很酷的功能。](https://techcrunch.com/2009/11/10/google-go-language/ \"试图将像Python这样的动态语言的工作开发速度与C或C ++等编译语言的性能和安全性结合起来。在我们的Go to date实验中，典型的构建感觉瞬间完成; 甚至大型二进制文件只需几秒钟即可编译。编译后的代码接近C的速度.Go旨在让您快速移动。我们希望Go成为一种优秀的系统编程语言，支持多处理和面向对象设计的全新轻量化，具有真正的闭包和反射等一些很酷的功能。\")”\n\n#### GO语言的主要特性主要包括\n\n - 并发与协程\n - 基于消息传递的通信方式\n - 丰富实用的内置数据类型\n - 函数多返回值\n - defer机制\n - 反射(reflect)\n - 高性能HTTP Server\n - 工程管理\n - 编程规范\n\n---\n\n### Go语言的应用前景\nGo语言凭借着天生的并发优势，出众的性能以及亲民的语法，迅速的蹿红各类IT领域，在人工智能、云计算开发、容器虚拟化、⼤数据开发、数据分析及科学计算、运维开发、爬虫开发、游戏开发等领域都有着广泛的应用。\n\n以下是应用Go语言的公司：\n![](/images/post_imgs/go_companies.jpg)\n\n","categories":["Go系列"]},{"title":"python语言起源","url":"/2019/09/16/python语言起源/","content":"\n## Python语言的前世今生\n\n### Python的诞生\npython的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范·罗苏姆（中文名字：龟叔）为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。  \n\n（龟叔：2005年加入谷歌至2012年，2013年加入Dropbox直到现在，依然掌握着Python发展的核心方向，被称为仁慈的独裁者）。\n![](/images/post_imgs/Guido_van_Rossum.jpg)\n\n---\n\n### Python版本发展\n - 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。\n - 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。\n - Granddaddy of Python web frameworks, Zope 1 was released in 1999\n - Python 1.0 - January 1994 增加了 lambda, map, filter and reduce.\n - Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础\n - Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生\n - Python 2.5 - September 19, 2006\n - Python 2.6 - October 1, 2008\n - Python 2.7 - July 3, 2010\n - **In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible**\n - Python 3.0 - December 3, 2008\n - Python 3.1 - June 27, 2009\n - Python 3.2 - February 20, 2011\n - Python 3.3 - September 29, 2012\n - Python 3.4 - March 16, 2014\n - Python 3.5 - September 13, 2015\n - Python 3.6 - December 23, 2016\n - Python 3.7 - June 27, 2018\n\n---\n\n### Python的各类解释器\n - CPython：官方的解释器，也是使用最广的Python解释器。在CPython解释器下有GIL限制，一个CPU同一时刻只能运行一个线程。\n - IPython：是一种比较流行的解释器\n - PyPy：一种专注于执行速度的解释器。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。\n - Jython：运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行，Jython可以直接调用Java的各种函数库。\n - IronPython：和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。\n - ZhPy：周蟒，支持使用繁/简中文语句编写程序的Python语言\n\n---\n\n### Python应用领域\n目前Python主要应用领域：\n - 云计算: 云计算最火的语言， 典型应用OpenStack\n - WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣等等，典型WEB框架有Django、Flask、Tornado、sanic\n - 科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas\n - 系统运维: 运维人员必备语言\n - 金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。\n - 原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c、c++、java,尤其擅长策略回测\n - 图形GUI: PyQT、WxPython、TkInter\n","categories":["Python系列"]},{"title":"Python系列汇总","url":"/2019/09/16/Python系列/","content":"\n### Python_基础篇\n> 文章若无特别指出均表示python3.x版本下\n\n前提准备\n - 01 - [语言起源](http://elijahyg.github.io/2019/09/16/python%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90/)\n - 02 - [IDE介绍 & 环境搭建](http://elijahyg.github.io/2019/09/25/python%20IDE%E4%BB%8B%E7%BB%8D&%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)\n \n语法基础\n - 01 - 数据类型\n  - [数字类型 Integer](http://elijahyg.github.io/2019/10/11/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E5%AD%97/)\n  - [布尔类型 Boolean](http://elijahyg.github.io/2019/10/13/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/)\n  - [字符串类型 String](http://elijahyg.github.io/2019/10/24/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/)\n  - [列表类型 List](http://elijahyg.github.io/2019/10/30/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/)\n  - [元组类型 Tuple](http://elijahyg.github.io/2019/11/19/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%85%83%E7%BB%84/)\n  - [字典类型 Dict](http://elijahyg.github.io/2019/12/02/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8/)\n  - [集合类型 Set](http://elijahyg.github.io/2019/12/12/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/)\n  - [Py2与Py3字符串类型区别](http://elijahyg.github.io/2019/12/26/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bpy2%E4%B8%8Epy3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB/)\n  - [类型转换内置函数汇总](http://elijahyg.github.io/2020/01/07/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/)\n - 02 - [运算符](http://elijahyg.github.io/2020/01/15/Python%E8%BF%90%E7%AE%97%E7%AC%A6/)\n - 03 - [字符集&编码详解](http://elijahyg.github.io/2020/02/01/Python%E5%AD%97%E7%AC%A6%E9%9B%86&%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/#%E5%AD%97%E7%AC%A6%E9%9B%86-amp-%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3)\n - 04 - [文件操作](http://elijahyg.github.io/2020/02/12/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/)\n \n函数\n - 01 - [初识函数](http://elijahyg.github.io/2020/02/26/Python%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/)\n - 02 - [各种函数](http://elijahyg.github.io/2020/03/14/Python%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0/)\n - 03 - [闭包&装饰器](http://elijahyg.github.io/2020/03/14/Python%E9%97%AD%E5%8C%85&%E8%A3%85%E9%A5%B0%E5%99%A8/)\n - 04 - [迭代器&生成器](http://elijahyg.github.io/2020/03/28/Python%E8%BF%AD%E4%BB%A3%E5%99%A8&%E7%94%9F%E6%88%90%E5%99%A8/)\n \n\n模块 & 包\n - 01 - [模块](http://elijahyg.github.io/2020/04/07/Python%E6%A8%A1%E5%9D%97/)\n - 02 - [包](http://elijahyg.github.io/2020/04/14/Python%E5%8C%85/)\n - 03 - [常用的模块&包](http://elijahyg.github.io/2020/05/10/Python%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97&%E5%8C%85/)\n\n面向对象\n - 01 - [面向对象初识](http://elijahyg.github.io/2020/06/07/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E8%AF%86/)\n - 02 - [方法](http://elijahyg.github.io//2020/07/14/Python%E6%96%B9%E6%B3%95/)\n - 03 - [异常处理](http://elijahyg.github.io/2020/11/22/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/)\n\n网络编程\n - 01 - [网络编程初识](http://elijahyg.github.io/2021/01/10/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%88%9D%E8%AF%86/)\n - 02 - [Socket（套接字）](http://elijahyg.github.io/2021/01/10/PythonSocket-%E5%A5%97%E6%8E%A5%E5%AD%97/)\n - 03 - [黏包问题](http://elijahyg.github.io/2021/01/10/Python%E9%BB%8F%E5%8C%85%E9%97%AE%E9%A2%98/)\n - 04 - [SocketServer实现多并发](http://elijahyg.github.io/2021/01/10/PythonSocketServer%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B9%B6%E5%8F%91/)\n \n并发编程\n - 01 - [进程线程初识](http://elijahyg.github.io/2021/01/10/Python%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%88%9D%E8%AF%86/)\n - 02 - [(多)进程](http://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%EF%BC%88%E5%A4%9A%EF%BC%89%E8%BF%9B%E7%A8%8B/)\n - 03 - [(多)线程](http://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%EF%BC%88%E5%A4%9A%EF%BC%89%E7%BA%BF%E7%A8%8B/)\n - 04 - [协程](http://elijahyg.github.io/2021/01/10/Python%E4%B8%AD%E5%8D%8F%E7%A8%8B/)\n - 05 - [IO多路复用](http://elijahyg.github.io/2021/01/10/PythonIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/)\n\n原理探究\n","categories":["Python系列"]},{"title":"基于Github搭建Hexo个人博客","url":"/2019/09/13/基于Github搭建Hexo个人博客/","content":"### 一、准备工作\n - Github账号\n - nodejs\n - npm\n - git for windows\n\n### 二、创建github仓库\n - 创建以`你的用户名.github.io`的仓库\n\n### 三、域名绑定(可选)\n\n### 四、配置SSH key\n> 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n\n - 用git bash执行如下命令,如果提示：No such file or directory 说明你是第一次使用git\n`$ cd ~/. ssh #检查本机已存在的ssh密钥`\n\n - 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key；将刚复制的内容粘贴到key那里，title随便填，保存。\n`ssh-keygen -t rsa -C \"邮件地址\"`\n\n - 测试SSH-Key是否设置成功\n\n```txt\n ssh -T git@github.com # 注意邮箱地址不用改\n\n# 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\n# Hi 【用户名】! You’ve successfully authenticated, but GitHub does not provide shell access.\n# 看到这个信息说明SSH已配置成功！\n```\n\n - 配置全局用户名和邮箱\n\n```txt\n$ git config --global user.name \"用户名\" # 你的github用户名，非昵称\n$ git config --global user.email \"邮箱\" # 填写你的github注册邮箱\n```\n\n### 五、Hexo部分\n - 安装Hexo\n\n`npm install -g hexo`\n\n - 初始化Hexo\n\n```txt\ncd /d/workspaces/hexo/ # 工作目录\nhexo init\n```\n\n - 部署、启动服务\n\n```txt\nhexo g # 生成\nhexo s # 启动服务\n```\n\n - 本地预览问题\n\n```txt\nhexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故\n```\n\n### 六、修改Hexo主题\n\n - 官网主题\n`https://hexo.io/themes/`\n\n - 新推荐极简主题\n`https://github.com/aircloud/hexo-theme-aircloud`\n\n - 更换主题(以yilia为例)\n```txt\nhttps://github.com/litten/hexo-theme-yilia\n\n - 进入目录下载主题\ncd /d/workspaces/hexo/\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n - 修改配置文件\n\n```txt\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n```\n\n### 七、上传到github\n - 修改配置文件\n\n```txt\n...\ndeploy:\n  type: git\n  repository: git@github.com:用户名/用户名.github.io.git\n  branch: master\n...\n```\n\n - 安装插件\n\n```txt\n# 部署前还需要安装插件，git bash执行\nnpm install hexo-deployer-git --save\n```\n\n - 提交至Github\n\n```txt\n# 如果一切正常，可以执行hexo d将代码上传至github，之后就可以打开https://用户名.github.io/浏览你的个人博客了\nhexo d\n```\n\n### 八、常用hexo命令\n\n - 常见命令\n\n```txt\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n```\n\n - 缩写\n\n```txt\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n - 组合命令\n\n```txt\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n### 九、写博客\n - 写博客\n```txt\n# 定位到hexo目录，执行下面语句，hexo会帮我们在_posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了\nhexo new 'my-first-blog'\n```\n\n - 一般完整格式如下\n\n```md\n---\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n以下是正文\n```","categories":["其他"]}]