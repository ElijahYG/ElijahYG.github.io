[{"title":"Python初识函数","url":"/2020/02/26/Python初识函数/","content":"\n\n## 初识函数\n\n### 函数的概念\nwiki百科中解释：函数是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。\n简而言之，函数就是具有输入参数、输出参数的，并且可以独立完成特定功能的程序代码。\n\n### 函数与方法的区别\n#### 函数\n - 通过`函数名()`的方式调用\n\n#### 方法\n - 通过`类的实例.方法名()`的方式调用\n\n#### 判断函数or方法\n\n```python\n#!/usr/bin/python\nfrom types import FunctionType, MethodType\n\nclass Foo(object):\n    def __init__(self):\n        pass\n    def func(self):\n        print(self,\"in func\")\n\nfoo = Foo()  # foo是类Foo的实例\nfoo.func()  # 类Foo的实例调用func\nFoo.func(foo)  # 类Foo调用func，并传入foo实例\n\nprint(isinstance(foo.func, FunctionType))  # False\nprint(isinstance(foo.func, MethodType))   # True   #说明这是一个方法\n\nprint(isinstance(Foo.func, FunctionType))  # True   #说明这是一个函数。\nprint(isinstance(Foo.func, MethodType))  # False\n```\n\n### 命名空间\nwiki百科中的解释：它表示着一个标识符的可见范围。\n简而言之，命名空间就是对象或变量的作用范围。\npython中的命名空间：内置命名空间、全局命名空间、局部命名空间\n - 内置命名空间: python编译器启动时就可以使用的名字存在内置命名空间中\n - 全局命名空间: 除函数外的代码部分\n - 局部命名空间: 函数内部的代码部分\n\n### 作用域\nwiki百科中解释：作用域是名字（name）与实体（entity）的绑定保持有效的那部分计算机程序。\n简而言之，作用域就是变量有效的代码区域。\npython中的作用域分为：全局变量作用域、局部变量作用域\n - 全局变量作用域：是整个代码范围。\n - 局部变量作用域：是定义该变量的子程序的代码范围。\n - 同名变量在全局和局部变量作用域如何划分：在局部变量作用域代码范围内，局部变量起作用;在其他地方全局变量起作用。\n\n### 参数\n\n#### 参数的概念\n参数可以理解为函数的输入值。\n\n#### 参数的种类\n - 形参的角度（函数定义阶段）\n\n```python\n# 位置参数：必须传，且有多少就必须传多少\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三','男')\n>>> 姓名是:张三\n>>> 性别是:男\n\n# 默认参数：可传可不传，不传则使用默认值\ndef name_sex(name, sex='男'):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三')\n>>> 姓名是:张三\n>>> 性别是:男\n\n# *args：接收的是按照位置传参的值，组织成一个元组\ndef name_sex(*args):\n    print(args)\nname_sex('张三','男')\n>>>('张三', '男')\n\n# **kwargs：接受的是按照关键字传参的值，组织成一个字典\ndef name_sex(**kwargs):\n    print(kwargs)\nname_sex(姓名='张三',性别='男')\n>>> {'性别': '男', '姓名': '张三'}\n\n```\n\n - 实参的角度（函数调用阶段）\n\n```python\n# 按位置传参\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三', '男')\n>>>姓名是:张三\n>>>性别是:男\n\n# *按关键字传参\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex(sex='男',name='张三')\n>>>姓名是:张三\n>>>性别是:男\n\n# *按位置、按关键字混合传参：必须按照位置参数，再按照关键字传参，不能将参数赋予多个值\ndef name_sex(name, sex):\n    print('姓名是:' + name + '\\n性别是:' + sex)\nname_sex('张三',sex='男')\n>>>姓名是:张三\n>>>性别是:男\n```\n\n#### 多种参数混合的顺序\n - 位置参数 -> \\*args -> 默认参数 -> \\*\\*kwargs\n\n#### 动态参数的另一个传参方式\n - 站在形参的角度上，给变量加上\\*，就是组合所有传来的值。\n - 站在实参的角度上，给一个序列加上\\*，就是将这个序列按照顺序打散\n\n\n#### 默认参数的陷阱\n - 默认参数是可变数据类型\n\n```python\n#!/usr/bin/python\n\ndef foo(arg,lst = []):\n    lst.append(arg)\n    print(lst)\n\nfoo('python')\nfoo('java')\n```\n\n### 返回值\n\n#### 返回值的概念\n返回值可以理解为函数的输出值。\n\n#### 返回值的种类\n - 没有返回值，默认返回None\n  - 只有return：结束一个函数的继续\n  - 没有return\n  - return None：不常用\n - 一个返回值\n  - 可以返回任何数据类型\n  - 只要返回就可以接收到\n  - 如果在一个函数中有多个return，只返回第一个\n - 多个返回值\n  - 用多个变量接收：有多少返回值就要有多少变量接收\n  - 用一个变量接收：接收到的是一个元组\n","categories":["Python系列"]},{"title":"Python文件操作","url":"/2020/02/12/Python文件操作/","content":"\n\n## 文件操作\n\n### 文件操作介绍\n众所周知，文件是存储在硬盘或者其他外部存储设备之中的，我们想要操作文件对其内容进行修改的话就涉及到了应用程序对硬件的操作，但是应用程序是无法直接操作硬件设备的，需要操作系统对硬件设备进行操作，所以我们所说的文件操作，其本质上是应用程序利用操作系统所提供的的接口间接的对硬件设备进行操作的。\nPython语言进行文件操作需要利用open()函数，open()函数获取文件流来对文件内容进行操作，这个流实际上就是一个I/O通道，即通常所说文件描述符。\n\n---\n\n### 文件打开方式\n#### 文件句柄方式\n```python\n# 1. 打开文件，得到文件句柄并赋值给一个变量\nf = open('target_file.txt', mode='r', encoding='utf-8')\n\n# 2. 通过句柄对文件进行操作\ncontent = f.read()\n\n# 3.输出读取到的结果\nprint(content)\n\n# 4. 关闭文件\nf.close()\n\n>>> 文件中的内容：\n>>> python\n>>> java\n```\n\n#### 上下文方式\n```python\n# 1. with关键字引导上下文方式打开文件，并将句柄赋予别名f\nwith open('target_file.txt', mode='r', encoding='utf-8') as f:\n\n# 2. 通过句柄对文件进行操作\n    content = f.read()\n\n# 3.输出读取到的结果，用with上下文方式对文件进行操作会在结束操作时默认关闭文件，不必要主动close()\n    print(content)\n```\n\n---\n\n### 操作文件\n`语法：open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`\n\n|操作符| 作用|\n|:------: | :--|\n|'r'| 读取文件（默认）|\n|'w'| 覆盖写入文件|\n|'a'| 追加写入文件|\n|'b'| 二进制模式|\n|'t'| 文本模式（默认）|\n|'+'| 更新文件（读取与写入）|\n|`~~'U'~~`| universal newline mode (在 Python 3.0 中成为默认行为)|\n\n#### 读\n - `mode='r'`：只读，文件不存在则报错\n\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r', encoding='utf-8') as f:\n    content = f.read()\n    print(content)\n>>> 人生苦短，我用python\n```\n\n - `mode='rb'`：以bytes类型读\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='rb') as f:\n    content = f.read()\n    print(content)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python'\n```\n\n - `mode='r+'`：读写，文件不存在不会创建，写则会在指针后添加内容\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r+',encoding='utf-8') as f:\n    content = f.read()\n    f.write('\\n新添加：Life is short , I use python')\n    print(content)\n>>> 人生苦短，我用python\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n>>> 新添加：Life is short , I use python\n```\n\n\n - `mode='r+b'`：以bytes类型读写\n```python\n# target_file.txt文件中原始内容为：人生苦短，我用python\n\nwith open('target_file.txt', mode='r+b') as f:\n    content = f.read()\n    f.write('\\n新添加：Life is short , I use python'.encode('utf-8'))\n    print(content)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python'\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n>>> 新添加：Life is short , I use python\n```\n\n#### 写\n - `mode='w'`：只写，文件不存在则创建，文件存在则清空再写\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\nwith open('target_file.txt', mode='w', encoding='utf-8') as f:\n    content = f.write('人生苦短，我用python')\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python\n```\n\n - `mode='x'`：只写，文件不存在则创建，文件存在则报错\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='x', encoding='utf-8') as f:\n    content = f.write('人生苦短，我用python')\n# target_file.txt存在：\n>>> Traceback (most recent call last):\n>>> File \"D:/file_operate.py\", line 94, in <module>\n>>> with open('target_file.txt', mode='x', encoding='utf-8') as f:\n>>> FileExistsError: [Errno 17] File exists: 'target_file.txt'\n# target_file.txt不存在：\n>>> 人生苦短，我用python\n```\n\n - `mode='wb'`：以bytes类型写\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='wb') as f:\n    content = f.write('人生苦短，我用python'.encode('utf-8'))\n>>> 人生苦短，我用python\n\n# # ④w+——写读，文件不存在则创建，写会覆盖之前的内容\nwith open('target_file.txt', mode='w+') as f:\n    content = f.write('hello,world')\n    date = f.read()\n    print(date)\n>>>\n# target_file.txt中的内容为：\n>>> hello,world\n```\n\n - `mode='w+b'`：以bytes类型写读\n\n```python\n# target_file.txt文件中原始内容为空，需要向其中写入：人生苦短，我用python\n\nwith open('target_file.txt', mode='w+b') as f:\n    content = f.write('hello,world'.encode('utf-8'))\n    date = f.read()\n    print(date)\n>>> b''\n# target_file.txt中的内容为：\n>>> hello,world\n```\n\n#### 追加\n - `mode='a'`：追加，文件不存在则创建，文件存在则追加\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a', encoding='utf-8') as f:\n    content = f.write('谁用谁知道')\ntarget_file.txt中的内容为：\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='ab'`：以bytes类型追加\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='ab') as f:\n    content = f.write('谁用谁知道'.encode('utf-8'))\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='a+'`：可读可写，文件不存在则创建，写则追加\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a+',encoding='utf-8') as f:\n    content = f.write('谁用谁知道')\n    f.seek(0)\n    date = f.read()\n    print(date)\n>>> 人生苦短，我用python谁用谁知道\n```\n\n - `mode='a+b'`：以bytes类型可读可写\n\n```python\n# 此处target_file.txt文件中原始内容为：人生苦短，我用python，需要在后面添加'谁用谁知道'内容\n\nwith open('target_file.txt', mode='a+b') as f:\n    content = f.write('谁用谁知道'.encode('utf-8'))\n    f.seek(0)\n    date = f.read()\n    print(date)\n>>> b'\\xe4\\xba\\xba\\xe7\\x94\\x9f\\xe8\\x8b\\xa6\\xe7\\x9f\\xad\\xef\\xbc\\x8c\\xe6\\x88\\x91\\xe7\\x94\\xa8python\\xe8\\xb0\\x81\\xe7\\x94\\xa8\\xe8\\xb0\\x81\\xe7\\x9f\\xa5\\xe9\\x81\\x93'\n# target_file.txt中的内容为：\n>>> 人生苦短，我用python谁用谁知道\n```\n\n#### 文件修改\n\n> python没有提供直接修改文件的函数，只能新建文件，将源文件的内容修改完成后写入新文件中，再把原文件删除，新文件重命名\n\n```python\nimport os\n\nwith open('源文件', encoding='utf-8') as f, open('源文件.bak', mode='w', encoding='utf-8') as f_w:\n    for i in f:\n        if '源文件' in i:\n            i = i.replace('源文件', '更改后的源文件')\n        f_w.write(i)\n\nos.remove('源文件')\nos.rename('源文件.bak','源文件')\n\n```\n\n#### 其他操作\n - seek() 移动光标指针位置\nseek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的\n\n - tell() 返回当前指针所在的位置\ntell对于英文字符就是占一个,中文字符占三个,参数表示的是字节数区分与read()的不同。\n\n - truncate() 截断文件\ntruncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果。\n\n - readline() 读取一行\n\n - readlines() 读取多行，返回为列表\n\n - readable() 文件是否可读\n\n - writeline() 写入一行\n\n - writelines() 写入多行\n\n - writable() 文件是否可读\n\n - closed() 文件是否关闭\n\n - encoding='utf-8' 如果文件打开模式为b,则没有该属性\n\n - flush() 立刻将文件内容从内存刷到硬盘\n\n - for循环文件句柄\n```python\nwith open('target_file.txt', mode='r',encoding='utf-8') as f:\n    for i in f:\n        print(i)\n>>> 人生苦短，我用python\n>>> 谁用谁知道\n```\n","categories":["Python系列"]},{"title":"Python字符集&编码详解","url":"/2020/02/01/Python字符集&编码详解/","content":"\n\n## 字符集&编码详解\n### 1 定义\n- 编码/解码（encode/decode）：计算机中储存的信息都是用二进制数表示的；而我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果。通俗的说，按照何种规则将字符存储在计算机中，称为\"编码\"；反之，将存储在计算机中的二进制数解析显示出来，称为\"解码\"。如果使用了错误的解码规则，则导致解码错误或者乱码。\n- 字符集（charset）：是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等\n- 字符编码（character Encoding）：是一套法则，使用该法则能够在符号集合与数字系统之间建立对应关系。\n\n### 2 字符集的发展过程\n#### 2.1. ASCII 字符集&编码\nASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。\n\n - ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n\n - ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：\n ![](/images/post_imgs/ascii_1.png)\n ![](/images/post_imgs/ascii_2.png)\n\n#### 2.2. GBXXXX 字符集&编码\n计算机发明之初只用应用于美国及西方一些发达国家，ASCII能够很好满足用户的需求。但是当中国也有了计算机之后，为了显示中文，必须设计一套编码规则用于将汉字转换为计算机可以接受的数字系统的数。中国为了解决这个问题规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。上述编码规则就是中国大陆通用的GB2312。GB2312或GB2312-80是中国国家标准简体中文字符集。新加坡等地也采用此编码。GB2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率。对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。\n\n由于GB2312-80只收录6763个汉字，有不少汉字，并未收录在内。于是微软利用GB 2312-80未使用的编码空间，收录GB13000.1-93全部字符制定了GBK编码，后续国家标准GB18030技术上兼容GBK。\n ![](/images/post_imgs/gb2312.png)\n\n#### 2.3. BIG5 字符集&编码\nBig5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录13060个汉字。2003年，Big5被收录到CNS11643中文标准交换码的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。\n\n#### 2.4. Unicode字符集 & UTF编码\n> Unicode是字符集，UTF-32 / UTF-16 / UTF-8是三种字符编码方案\n\n当计算机传到世界各个国家时，为了适合当地语言和字符，设计和实现类似GB232/GBK/GB18030/BIG5的编码方案。这样各搞一套，在本地使用没有问题，一旦出现在网络中，由于不兼容，互相访问就出现了乱码现象。\n为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。它使用4字节的数字来表达每个字母、符号或者表意文字。每个数字代表唯一的至少在某种语言中使用的符号。被几种语言共用的字符通常使用相同的数字来编码，每个字符对应一个数字，每个数字对应一个字符，即不存在二义性。\n在计算机科学领域中，Unicode（统一码、万国码、单一码、标准万国码）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character Set）的标准来发展，并且同时也以书本的形式对外发表。Unicode 还不断在扩增，每个新版本插入更多新的字符。直至目前为止的第六版，Unicode 就已经包含了超过十万个字符、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一套包含了上标字、下标字等字符特性的枚举等。\n\n - UCS & UNICODE\n通用字符集（Universal Character Set，UCS）是由ISO制定的ISO 10646标准所定义的标准字符集。历史上存在两个独立的尝试创立单一字符集的组织，即国际标准化组织（ISO）和多语言软件制造商组成的统一码联盟。前者开发的 ISO/IEC 10646 项目，后者开发的统一码项目。因此最初制定了不同的标准。\n1991年前后，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，虽然两个项目仍都存在，并独立地公布各自的标准。但统一码联盟和ISO/IEC JTC1/SC2都同意保持两者标准的码表兼容，并紧密地共同调整任何未来的扩展。在发布的时候，Unicode一般都会采用有关字码最常见的字型，但ISO 10646一般都尽可能采用Century字型。\n\n - UTF-32\n上述使用4字节的数字来表达每个字母、符号，或者表意文字，每个数字代表唯一的至少在某种语言中使用的符号的编码方案，称为UTF-32。UTF-32又称UCS-4是一种将Unicode字符编码的协定，对每个字符都使用4字节。就空间而言，是非常没有效率的。\n这种方法有其优点，最重要的一点就是可以在常数时间内定位字符串里的第N个字符，因为第N个字符从第4×Nth个字节开始。虽然每一个码位使用固定长定的字节看似方便，它并不如其它Unicode编码使用得广泛。\n\n - UTF-16\n尽管有Unicode字符非常多，但是实际上大多数人不会用到超过前65535个以外的字符。因此，就有了另外一种Unicode编码方式，叫做UTF-16(因为16位 = 2字节)。UTF-16将0–65535范围内的字符编码成2个字节。UTF-16编码最明显的优点是它在空间效率上比UTF-32高两倍，因为每个字符只需要2个字节来存储（除去65535范围以外的），而不是UTF-32中的4个字节。\n\n - UTF-8\nUTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码（定长码），也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。\n\n```txt\n一、UTF-8优点\n1、UTF-8是ASCII的一个超集。因为一个纯ASCII字符串也是一个合法的UTF-8字符串，所以现存的ASCII文本不需要转换。为传统的扩展ASCII字符集设计的软件通常可以不经修改或很少修改就能与UTF-8一起使用。\n2、使用标准的面向字节的排序例程对UTF-8排序将产生与基于Unicode代码点排序相同的结果。（尽管这只有有限的有用性，因为在任何特定语言或文化下都不太可能有仍可接受的文字排列顺序。）\n3、UTF-8和UTF-16都是可扩展标记语言文档的标准编码。所有其它编码都必须通过显式或文本声明来指定。\n4、任何面向字节的字符串搜索算法都可以用于UTF-8的数据（只要输入仅由完整的UTF-8字符组成）。但是，对于包含字符记数的正则表达式或其它结构必须小心。\n5、UTF-8字符串可以由一个简单的算法可靠地识别出来。就是，一个字符串在任何其它编码中表现为合法的UTF-8的可能性很低，并随字符串长度增长而减小。举例说，字符值C0,C1,F5至FF从来没有出现。为了更好的可靠性，可以使用正则表达式来统计非法过长和替代值（可以查看W3 FAQ: Multilingual Forms上的验证UTF-8字符串的正则表达式）。\n\n二、UTF-8缺点\n1、因为每个字符使用不同数量的字节编码，所以寻找串中第N个字符是一个O(N)复杂度的操作——即串越长，则需要更多的时间来定位特定的字符。同时，还需要位变换来把字符编码成字节，把字节解码成字符。\n```\n\n#### 2.5. 字符编码发展图\nASCII → GB2312 → GBK1.0 → GB18030 → Unicode → UTF-32 → UTF-16 → UTF-8\n\n\n","categories":["Python系列"]},{"title":"Python运算符","url":"/2020/01/15/Python运算符/","content":"\n## 运算符\n\n### 算术运算符\n|运算符|描述|示例|\n|---|---|---|\n|+|加：对两个可相加对象进行加法运算，并返回结果|a = 10 b = 20 => a+b = 30|\n|-|减：对两个可相减对象进行加法运算，并返回结果|a = 10 b = 20 => b-a = 10|\n|*|乘：对两个可相乘对象进行加法运算，并返回结果|a = 10 b = 20 => a*b = 200|\n|/|除：对两个可相除对象进行加法运算，并返回结果|a = 10 b = 20 => b/a = 2|\n|%|取模：返回除法的余数|a = 10 b = 20 => b%a = 0|\n|**|幂：返回乘方的结果|a = 2 b = 4 => a**b = 16|\n|//|取整除：返回商的整数部分|a = 2 b = 5 => b%a = 2|\n\n\n### 关系运算符\n|运算符|描述|示例|\n|---|---|---|\n|==|等于：比较两个可比较对象是否相等，并返回布尔结果|a = 10 b = 20 => a==b 返回 false|\n|!=|不等于：比较两个可比较对象是否不相等，并返回布尔结果|a = 10 b = 20 => a!=b 返回 true|\n|>|大于：比较对象A是否大于对象B，并返回布尔结果|a = 10 b = 20 => a > b 返回 false|\n|<|小于：比较对象A是否小于对象B，并返回布尔结果|a = 10 b = 20 => a < b 返回 true|\n|\\>=|大于等于：比较对象A是否大于等于对象B，并返回布尔结果|a = 10 b = 20 => a >= b 返回 false|\n|<=|小于等于：比较对象A是否小于等于对象B，并返回布尔结果|a = 10 b = 20 => a <= b 返回 true|\n\n\n### 赋值运算符\n|运算符|描述|示例|\n|---|---|---|\n|=|简单赋值运算：将=右边变量赋值给=左边变量|a = 10 => b = a, b = 10|\n|+=|加法赋值运算|b += a 等效于 b = b + a|\n|-=|减法赋值运算|b -= a 等效于 b = b - a|\n|*=|乘法赋值运算|b \\*= a 等效于 b = b \\* a|\n|/=|除法赋值运算|b /= a 等效于 b = b / a|\n|%=|取模赋值运算|b %= a 等效于 b = b % a|\n|**=|幂赋值运算|b \\*\\*= a 等效于 b = b \\*\\* a|\n|//=|取整除赋值运算|b //= a 等效于 b = b // a|\n\n\n### 逻辑运算符\n|运算符|描述|示例|\n|---|---|---|\n|and|布尔与：a and b, 若a为false，a and b返回 false, 否则返回b的计算值|a = 10 b = 20 => a and b 返回20|\n|or|布尔或：a or b, 若a为非0，a or b返回 a 的值, 否则返回 b 的计算值|a = 10 b = 20 => a or b 返回10|\n|not|布尔非：not a, 若 a 为 true, 返回false，否则返回true|not a / not b 返回 false|\n\n\n#### 布尔与\n - 在Python 中，and 和 or 执行布尔逻辑演算，如你所期待的一样，但是它们并不返回布尔值；而是，返回它们实际进行比较的值之一。\n - 在布尔上下文中从左到右演算表达式的值，如果布尔上下文中的所有值都为真，那么 and 返回最后一个值。\n - 如果布尔上下文中的某个值为假，则 and 返回第一个假值\n\n\n#### 布尔或\n - 使用 or 时，在布尔上下文中从左到右演算值，就像 and 一样。如果有一个值为真，or 立刻返回该值\n - 使如果所有的值都为假，or 返回最后一个假值\n - 使注意 or 在布尔上下文中会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值\n\n\n#### 布尔非\n - 结合了前面的两种语法，推理即可。\n - 为加强程序可读性，最好与括号连用，例如： （1 and ‘x’) or ‘y’\n\n\n### 位运算符\n|运算符|描述|示例|\n|---|---|---|\n|&|按位与运算：参与运算的两对应位都为1，则该位返回1，否则返回0|a = 60 b = 13 => a & b = 12 (0000 1100)|\n|\\||按位或运算：参与运算的两对应位有一个为1，则该位返回1，否则返回0|a = 60 b = 13 => a \\| b = 61 (0011 1101)|\n|^|按位异或：参与运算的两对应位相异时，则该位返回1，否则返回0|a = 60 b = 13 => a ^ b = 49 (0011 0001)|\n|~|按位取反运算：参与运算的数每位取反，即0、1互换|a = 60 => ~a = -61 (1100 0011)有符号二进制数的补码形式 |\n|<<|左移运算：参与运算的数每位向左移动若干位，高位丢弃，低位补0|a = 60 => a << 2 = 240 (1111 0000)) |\n|\\>\\>|右移运算：参与运算的数每位向右移动若干位，高位补0，低位丢弃|a = 60 => a >> 2 = 15 (0000 1111)) |\n\n - tips\n`~ 举例： ~5 = -6 解释： 将二进制数+1之后乘以-1，即~x = -(x+1)，-(101 + 1) = -110`\n\n\n### 成员运算符\n|运算符|描述|示例|\n|---|---|---|\n|in|如果在指定的序列中找到则返回true，否则false|a = 'yang' b = 'ya' => b in a, 返回true|\n|not in|如果在指定的序列中找不到则返回true，否则false|a = 'yang' b = 'ay' => b not in a, 返回true|\n\n\n### 身份运算符\n|运算符|描述|示例|\n|---|---|---|\n|is|判断两个变量是不是引用自同一个对象|a is b => 若 id(a) == id(b), 则返回1|\n|is not|判断两个变量是不是引用自不同对象|a is not b => 若 id(a) != id(b), 则返回1|\n\n\n### 运算符优先级（由低到高）\n|运算符|描述|\n|---|---|\n|lambda|Lambda表达式|\n|or|布尔'或'|\n|and|布尔'与'|\n|not x|布尔'非'|\n|in，not in|成员运算|\n|is，is not|身份运算|\n|<，<=，>，>=，!=，==|\t比较运算|\n|\\||按位或|\n|^|按位异或|\n|&|按位与|\n|<<，>>|位运算|\n|+，-|加法与减法|\n|*，/，%|乘法、除法与取余|\n|+x，-x|正负号|\n|~x|按位翻转(取补码)|\n|**|指数|\n|x.attribute|属性参考|\n|x[index]|下标|\n|x[index:index]|寻址段|\n|f(arguments...)|函数调用|\n|(experession,...)|绑定或元组显示|\n|[expression,...]|列表显示|\n|{key:datum,...}|字典显示|\n|'expression,...'|字符串转换|\n\n\n### 重要运算符说明\n#### join和符号”+“区别\n - \"+\"\n我们知道在python中，字符串是不可变数据类型。所以当多个字符串利用\"+\"进行拼接时，会每次都做一次申请内存的操作，并将拼接后的字符串存入新内存中。\n - join\n与\"+\"不同，join操作时会先计算字符操作所用到的空间总和大小，之后将需要拼接的所有字符串一次性都拼接完成存入新内存中。这就比\"+\"节省了每次申请新内存的时间。\n\n#### is和”==“区别\n\n - \"==\"\n用来比较两个对象的值是否相同。\n - is\n用来比较对象所处的内存地址是否相同。","categories":["Python系列"]},{"title":"Python数据类型之类型转换内置函数汇总","url":"/2020/01/07/Python数据类型之类型转换内置函数汇总/","content":"\n## 类型转换内置函数\n\n### 数字类型\n - `int(x [,base])`：将x转换为一个整数\n - `float(x)`：将x转换为一个浮点数\n - `complex([real[, imag]])`：返回一个值为real + imag*1j的复数\n - `chr(x)`：将整数x转换为一个字符\n - `unichr(x)`：将整数x转换为Unicode字符 \n\n### 字符串类型\n - `str(x)`：将x转换为字符串\n - `repr(x)`：将x转换为表达式字符串\n - `eval(str)`：用于计算在字符串中的有效python表达式，并返回对象\n - `ord(x)`：将字符串x转换为整数\n - `hex(x)`：将字符串x转换为十六进制字符串\n - `oct(x)`：将字符串x转换为八进制字符串\n\n### 列表类型\n - `list(s)`：将序列s转换为一个列表\n\n### 元组类型\n - `tuple(s)`：将序列s转换为一个元组\n\n### 字典类型\n - `dict(d)`：创建字典，d需要是形如(key,value)的元组\n\n### 集合类型\n - `set(s)`：将s转换为可变集合\n - `frozenset(s)`：将s转换伟不可变集合\n\n### 类型间相互转换\n - 字符串、列表相互转换\n\n```python\n# list -> string（list中的元素需为字符串）\n\nl = ['y','a','n','g']\ns = ''.join(l)\nprint(s)\n>>> 'yang'\n\n# string -> list\ns = 'y, a, n, g'\nl = s.split(',')\nprint(l)\n>>> ['y','a','n','g']\n\n```\n\n - 列表/元组转换为字典\n\n```python\n# list/tuple -> dict\nl = ['a', 'b']\nd = dict.fromkeys(l)\nprint(d)\n>>> {'a': None, 'b': None}\n```\n\n","categories":["Python系列"]},{"title":"Python数据类型之py2与py3字符串类型区别","url":"/2019/12/26/Python数据类型之py2与py3字符串类型区别/","content":"\n## Python2.x字符串 VS Python3.x字符串\n\n### 1. Python2.X的字符类型\n#### 1.1 str类型 & unicode类型\n```python\n>>> s1 = '中'\n>>> s2 = u'中'\n\n# 分别看下s1与s2的类型\n>>> print(type(s1))\n<type 'str'>\n\n>>> print(type(s2))\n<type 'unicode'>\n```\n#### 1.2 str类型与unicode类型的转换\n```python\n# utf-xxx是unicode字符集的具体编码形式，所以str类型转为unicode类型需要进行encode编码\n>>> s1 = u'中'\n>>> print(type(s1))\n<type 'unicode'>\n>>> new_s1 = s1.encode('utf8')\n>>> print(type(new_s1))\n<type 'str'>\n\n# 反之，unicode类型转为str类型则是将unicode类型解码为str类型，用decode进行解码\n>>> s2 = '中'\n>>> print(type(s2))\n<type 'str'>\n>>> new_s2 = s2.decode('utf8')\n>>> print(type(new_s1))\n<type 'unicode'>\n\n```\n\n### 2. Python3.X的字符类型\n#### 2.1 str类型 & bytes类型\n```python\n>>> s1 = 'yang'\n>>> s2 = b'yang'\n\n# 分别看下s1与s2的类型\n>>> print(type(s1))\n<class 'str'>\n\n>>> print(type(s2))\n<class 'bytes'>\n\n```\n### 2.2 str类型与bytes类型的转换\n```python\n# 在python3.X中，str类型对应unicode数据，bytes类型对应bytes数据，文本都是unicode数据，对应str类型\n# str类型转为bytes类型需要进行encode编码\n>>> s1='yang'\n>>> print(type(s1))\n<class 'str'>\n>>> new_s1 = s1.encode('utf8')\n>>> print(type(new_s1))\n<class 'bytes'>\n\n# 反之，bytes类型转为str类型则是将unicode数据用decode进行解码\n>>> s2=b'yang'\n>>> print(type(s2))\n<class 'bytes'>\n>>> new_s2 = s2.decode('utf8')\n>>> print(type(s2))\n<class 'str'>\n\n```\n\n### 3. 总结\n* Python3.X最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分，不再会对bytes字节串进行自动解码。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。\n* Python3.X不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。用户不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）。\n* 无论py2，还是py3,与明文直接对应的就是unicode数据，打印unicode数据就会显示相应的明文(包括英文和中文)\n\n - Python2.X中\n```python\n# str类型和unicode类型连接\n>>> print('Elijah'+u'Yang')\n\nElijahYang\n```\n\n - Python3.X中\n```python\n#字节串和unicode连接\n>>> print(b'Elijah'+'Yang')\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't concat str to bytes\n```\n\n","categories":["Python系列"]},{"title":"Python数据类型之集合","url":"/2019/12/12/Python数据类型之集合/","content":"\n## 集合类型(set)\n\n### 1. 集合介绍\n由不同元素组成的集合，集合中是一组无序排列的可hash值，可以作为字典的key\n\n#### 1.1 定义方式\n```python\n# 定义：由不同元素组成的集合，集合中是一组无序排列的可hash值，可以作为字典的key\n\n# 定义方法\n>>> set([iterable])\n\n>>> set1 = set('yang')\n>>> print(set1)\n\n{'yang'}\n\n```\n\n------------\n\n### ★2. 常用集合方法\n#### 2.1 交集、并集、差集、对称差集\n**语法说明**\n*交集*\n> set1 & set2\n\n*并集*\n> set1 | set2\n\n*差集*\n> set1 - set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 交集：set1和set2同时具有的元素的集合\n>>> set1 & set2\n{'A', '1'}\n\n# 并集：set1和set2的所有元素的集合\n>>> set1 | set2\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n\n# 差集：在set1中但是不在set2中的所有元素集合\n>>> set1 - set2\n{'D', 'B', 'C'}\n\n# 对称差集：在set1或set2中，但不会同时出现在二者中\n>>> set1 ^ set2\n{'D', 'C', '4', '3', 'B', '2'}\n```\n\n#### 2.2 添加元素\n**语法说明**\n> 添加一项元素\n> set1.add()\n\n> 添加多项元素\n> set1.update()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 添加一项元素\n>>> set1.add('E')\n>>> set1\n{'E', 'D', 'C', 'A', '1', 'B'}\n\n# 添加多项元素\n>>> set1.update(['2','3','4'])\n>>> set1\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n```\n\n#### 2.3 删除元素\n**语法说明**\n> 删除元素\n> set1.remove()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n# 删除一项元素\n>>> set1.remove('A')\n>>> set1\n{'D', 'C', '1', 'B'}\n```\n\n#### 2.4 集合长度\n**语法说明**\n> len(set1)\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> len(set1)\n5\n```\n\n#### 2.5 判断元素是否是集合成员\n**语法说明**\n> x in set1（同理 x not in set1判断元素是否不是集合成员）\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> 'B' in set1\nTrue\n```\n\n#### 2.6 判断set1集合中每一个元素都在set2中\n**语法说明**\n> set1.issubset(set2)\n> 同：set1 <= set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.issubset(set2)\nFalse\n```\n\n#### 2.7 判断set2集合中的每一个元素都在set1中\n**语法说明**\n> set1.issuperset(set2)\n> 同：set1 >= set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.issuperset(set2)\nFalse\n```\n\n#### 2.8 set1和set2的合集，返回包含两集合中的每一个元素的集合\n**语法说明**\n> set1.union(set2)\n> 同：set1|set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.union(set2)\n{'3', 'D', 'C', '4', 'A', '1', 'B', '2'}\n```\n\n#### 2.9 set1和set2的交集，返回两集合的共同部分\n**语法说明**\n> set1.intersection(set2)\n> 同：set1 & set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.intersection(set2)\n{'A', '1'}\n```\n\n#### 2.10 set1与set2的差集，返回set1中存在但是set2中不存在的元素\n**语法说明**\n> set1.difference(set2)\n> 同：set1 - set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.difference(set2)\n{'D', 'B', 'C'}\n```\n\n#### 2.11 set1和set2的对称差集，返回set1与set2中不重复的元素\n**语法说明**\n> set1.symmetric_difference(set2)\n> 同：set1 ^ set2\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n>>> set2 = set(['1','2','3','4','A'])\n\n>>> set1.symmetric_difference(set2)\n{'D', 'C', '4', '3', 'B', '2'}\n```\n\n#### 2.12 set1浅复制\n**语法说明**\n> set1.copy()\n\n```python\n>>> set1 = set(['A','B','C','D','1'])\n\n>>> set3 = set1.copy()\n>>> set3\n{'B', 'D', 'C', 'A', '1'}\n\n```\n\n#### 2.13 不可变集合frozenset\n**语法说明**\n> frozenset([iterable]])\n> 不可添加、删除元素、可哈希的、能用作字典的键、能做其他集合的元素\n\n```python\n>>> set1 = set([1, 2, 3, 4])\n>>> set1\n{1, 2, 3, 4}\n>>> f_set = frozenset(set1)\n>>>f_set\nfrozenset({1, 2, 3, 4})\n>>>set1.add('a')\n{1, 2, 3, 4, 'a'}\n\n# 不可变集合不能更改集合\n>>>f_set.add('b')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'frozenset' object has no attribute 'add'\n```\n\n#### 2.14 set应用-去除列表里重复元素\n```python\n# 去除海量列表里重复元素\n>>> list_a = [A,B,C,D,A,B]\n>>> set_b = set(list_a)\n>>> set_b\nset([A,B,C,D])\n>>> list_c = [i for i in set_b]\n>>> list_c\n[A,B,C,D]\n```\n\n#### 参考资料\nhttp://www.iplaypy.com/jichu/set.html\n\nhttp://www.runoob.com/python/python-func-set.html\n\nhttp://blog.csdn.net/dragonyangang/article/details/72808992\n\nhttp://blog.csdn.net/business122/article/details/7541486","categories":["Python系列"]},{"title":"Python数据类型之字典","url":"/2019/12/02/Python数据类型之字典/","content":"\n## 字典类型(dict)\n\n### 1. 字典介绍\n字典是另一种可变容器模型，且可存储任意类型对象。\n\n#### 1.1 定义方式\n```python\n# 定义：字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号{}中\n\n# 定义方法\n>>> d = {key1 : value1, key2 : value2 }\n\n# 键必须是唯一的，但值则不必；值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。\n>>> dict1 = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}\n>>> dict2 = { 'abc': 456 }\n>>> dict3 = { 'abc': 123, 98.6: 37 }\n```\n\n------------\n\n### ★2. 常用字典方法\n#### 2.1 dict[key] 访问字典中的值\n**语法说明**\n> 把相应的键放入方括号\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print (\"dict['Name']: \", dict['Name'])\n>>> print (\"dict['Age']: \", dict['Age'])\n\ndict['Name']:  Yang\ndict['Age']:  7\n\n# 如果用字典里没有的键访问数据，会输出错误\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print (\"dict['Alice']: \", dict['Alice'])\n\nTraceback (most recent call last):\n  File \"test_dict.py\", line 5, in <module>\n    print (\"dict['Alice']: \", dict['Alice'])\nKeyError: 'Alice'\n```\n\n#### 2.2 修改字典元素\n**语法说明**\n> 向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n# 更新 Age\n>>> dict['Age'] = 8\n# 添加信息\n>>> dict['School'] = \"程序员学院\"\n>>> print (\"dict['Age']: \", dict['Age'])\n>>> print (\"dict['School']: \", dict['School'])\n\ndict['Age']:  8\ndict['School']:  程序员学院\n```\n\n#### 2.3 删除字典元素\n**语法说明**\n> 能删单一的元素也能清空字典，清空只需一项操作；删除一个字典用del命令\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n\n# 删除键 'Name'\n>>> del dict['Name']\n# 删除字典\n>>> dict.clear()\n# 删除字典\n>>> del dict\n>>> print (\"dict['Age']: \", dict['Age'])\n>>> print (\"dict['School']: \", dict['School'])\n\n# 会引发一个异常，因为用执行 del 操作后字典不再存在\nTraceback (most recent call last):\n  File \"test_dict.py\", line 9, in <module>\n    print (\"dict['Age']: \", dict['Age'])\nTypeError: 'type' object is not subscriptable\n```\n\n#### 2.4 字典键的特性\n* 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。\n* 两个重要的点需要记住：\n    1. 不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住\n    ```python\n    >>> dict = {'Name': 'Yang', 'Age': 7, 'Name': '小菜鸟'}\n    >>> print (\"dict['Name']: \", dict['Name'])\n\n    dict['Name']:  小菜鸟\n    ```\n    2. 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行\n    ```python\n    >>> dict = {['Name']: 'Yang', 'Age': 7}\n    >>> print (\"dict['Name']: \", dict['Name'])\n\n    Traceback (most recent call last):\n      File \"test_dict.py\", line 3, in <module>\n        dict = {['Name']: 'Runoob', 'Age': 7}\n    TypeError: unhashable type: 'list'\n    ```\n\n#### 2.5 len(dict) 计算字典元素个数，即键的总数\n\n**语法说明**\n> len(dict)\n\n**参数说明**\n* dict -- 字典对象\n\n**返回值**\n> 该方法返回字典键的总数\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> print(len(dict))\n\n3\n```\n\n#### 2.6 str() 输出字典，以可打印的字符串表示\n\n**语法说明**\n> str(dict)\n\n**参数说明**\n* dict -- 字典对象\n\n**返回值**\n> 该方法返回输出字典，以可打印的字符串表示\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> str(dict)\n\n\"{'Name': 'Yang', 'Class': 'First', 'Age': 7}\"\n```\n\n#### 2.7 type() 返回输入的变量类型，如果变量是字典就返回字典类型\n\n**语法说明**\n> type(variable)\n\n**参数说明**\n* variable -- 变量\n\n**返回值**\n> 该方法返回输入的变量类型\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> type(dict)\n\n<class 'dict'>\n```\n\n#### 2.8 dict.clear() 删除字典内所有元素\n\n**语法说明**\n> dict.clear()\n\n**参数说明**\n* 无\n\n**返回值**\n> 该函数没有任何返回值\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 7}\n>>> print (\"字典长度 : %d\" %  len(dict))\n>>> dict.clear()\n>>> print (\"字典删除后长度 : %d\" %  len(dict))\n\n字典长度 : 2\n字典删除后长度 : 0\n```\n\n#### 2.9 dict.copy() 返回一个字典的浅复制\n\n**语法说明**\n> dict.copy()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个字典的浅复制返回一个字典的浅复制\n\n```python\n>>> dict1 = {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n>>> dict2 = dict1.copy()\n>>> print (\"新复制的字典为 : \",dict2)\n\n新复制的字典为 :  {'Name': 'Yang', 'Age': 7, 'Class': 'First'}\n```\n\n#### 2.10 fromkeys() 函数用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。\n\n**语法说明**\n> dict.fromkeys(seq[, value]))\n\n**参数说明**\n* seq -- 字典键值列表\n* value -- 可选参数, 设置键序列（seq）的值\n\n**返回值**\n> 该方法返回列表\n\n```python\n>>> seq = ('name', 'age', 'sex')\n\n>>> dict = dict.fromkeys(seq)\n>>> print (\"新的字典为 : %s\" %  str(dict))\n\n>>> dict = dict.fromkeys(seq, 10)\n>>> print (\"新的字典为 : %s\" %  str(dict))\n\n新的字典为 : {'name': None, 'age': None, 'sex': None}\n新的字典为 : {'name': 10, 'age': 10, 'sex': 10}\n```\n\n#### 2.11 get() 函数返回指定键的值，如果值不在字典中返回默认值\n\n**语法说明**\n> dict.get(key, default=None)\n\n**参数说明**\n* key -- 字典中要查找的键。\n* default -- 如果指定键的值不存在时，返回该默认值值。\n\n**返回值**\n> 返回指定键的值，如果值不在字典中返回默认值 None\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n>>> print (\"Age 值为 : %s\" %  dict.get('Age'))\n>>> print (\"Sex 值为 : %s\" %  dict.get('Sex', \"NA\"))\n\nAge 值为 : 26\nSex 值为 : NA\n```\n\n#### 2.12 in 操作符用于判断键是否存在于字典中，返回布尔值\n\n**语法说明**\n> key in dict\n\n**参数说明**\n* key -- 要在字典中查找的键\n\n**返回值**\n> 如果键在字典里返回true，否则返回false\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n# 检测键 Age 是否存在\n>>> if  'Age' in dict:\n>>>     print(\"键 Age 存在\")\n>>> else :\n>>>     print(\"键 Age 不存在\")\n\n# 检测键 Sex 是否存在\n>>> if  'Sex' in dict:\n>>>     print(\"键 Sex 存在\")\n>>> else :\n>>>     print(\"键 Sex 不存在\")\n\n键 Age 存在\n键 Sex 不存在\n\n```\n\n#### 2.13 items() 方法以列表返回可遍历的(键, 值) 元组数组\n\n**语法说明**\n> dict.items()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回可遍历的(键, 值) 元组数组\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> print (\"Value : %s\" %  dict.items())\n\nValue : dict_items([('Name', 'Yang'), ('Age', 26)])\n```\n\n#### 2.14 keys() 方法以列表返回一个字典所有的键\n\n**语法说明**\n> dict.keys()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个字典所有的键\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> print (\"字典所有的键为 : %s\" %  dict.keys())\n\n字典所有的键为 : dict_keys(['Age', 'Name'])\n```\n\n#### 2.15 setdefault() 与get()方法类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值\n\n**语法说明**\n> dict.setdefault(key, default=None)\n\n**参数说明**\n* key -- 查找的键值。\n* default -- 键不存在时，设置的默认键值。\n\n**返回值\n> 该方法没有任何返回值\n\n```python\n# 与get()方法类似, 如果键不已经存在于字典中，将会添加键并将值设为默认值。\n>>> dict = {'Name': 'Yang', 'Age': 26}\n\n>>> print (\"Age 键的值为 : %s\" %  dict.setdefault('Age', None))\n>>> print (\"Sex 键的值为 : %s\" %  dict.setdefault('Sex', None))\n>>> print (\"新字典为：\", dict)\n\nAge 键的值为 : 26\nSex 键的值为 : None\n新字典为： {'Name': 'Yang', 'Age': 26, 'Sex': None}\n```\n\n#### 2.16 update() 函数把字典dict2的键/值对更新到dict里\n\n**语法说明**\n> dict.update(dict2)\n\n**参数说明**\n* dict2 -- 添加到指定字典dict里的字典\n\n**返回值**\n> 无\n\n```python\n>>> dict = {'Name': 'Yang', 'Age': 26}\n>>> dict2 = {'Sex': 'female' }\n\n>>> dict.update(dict2)\n>>> print (\"更新字典 dict : \", dict)\n\n更新字典 dict :  {'Sex': 'female', 'Age': 26, 'Name': 'Yang'}\n```\n\n#### 2.17 values() 方法以列表返回字典中的所有值\n\n**语法说明**\n> dict.values()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回字典中的所有值\n\n```python\n>>> dict = {'Sex': 'male', 'Age': 26, 'Name': 'Yang'}\n>>> print (\"字典所有值为 : \",  list(dict.values()))\n\n字典所有值为 :  ['male', 26, 'Yang']\n```\n\n#### 2.18 pop() 方法删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出,否则，返回default值\n\n**语法说明**\n> pop(key[,default])\n\n**参数说明**\n* key: 要删除的键值\n* default: 如果没有 key，返回 default 值\n\n\n**返回值**\n> 返回被删除的值\n\n```python\n>>> site= {'name': '程序员学院', 'alexa': 10000, 'url': 'www.engineer.com'}\n>>> pop_obj=site.pop('name')\n>>> print(pop_obj)\n\n程序员学院\n```\n\n#### 2.19 popitem() 方法随机返回并删除字典中的一对键和值(一般删除末尾对)。\n> 如果字典已经为空，却调用了此方法，就报出KeyError异常。\n\n**语法说明**\n> popitem()\n\n**参数说明**\n* 无\n\n**返回值**\n> 返回一个键值对(key,value)形式\n\n```python\nsite= {'name': '程序员学院', 'alexa': 10000, 'url': 'www.engineer.com'}\npop_obj=site.popitem()\nprint(pop_obj)\nprint(site)\n\n('url', 'www.engineer.com')\n{'name': '程序员学院', 'alexa': 10000}\n```\n\n\n\n","categories":["Python系列"]},{"title":"Python数据类型之元组.md","url":"/2019/11/19/Python数据类型之元组/","content":"\n## 元组类型(tuple)\n\n### 1. 元组介绍\nPython的元组与列表类似，同样可通过索引访问，支持异构，任意嵌套。不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。\n\n#### 1.1 定义方式\n```python\n# 定义：()内可以有多个任意类型的值，逗号分隔\n\n# 定义方法-定义元组\n>>> tup1 = ('physics', 'chemistry', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5 )\n>>> tup3 = \"a\", \"b\", \"c\", \"d\"\n>>> print(tup1)\n>>> print(tup2)\n>>> print(tup3)\n\n('physics', 'chemistry', 1997, 2000)\n(1, 2, 3, 4, 5)\n('a', 'b', 'c', 'd')\n\n# 定义方法-定义空元组\n>>> tup1 = ()\n>>> print(tup1)\n\n()\n\n# 定义方法-元组中只包含一个元素时，需要在元素后面添加逗号\n>>> tup1 = ('yang',)\n>>> print(tup1)\n\n('yang',)\n\n# 定义方法2\n>>> tup1=tuple(('apple', 'banana', 'peach'))\n>>> print(tup1)\n\n('apple', 'banana', 'peach')\n```\n\n------------\n### ★2. 常用元组方法\n#### 2.1 tuple[index] 访问元组中的值\n**语法说明**\n> 使用下标索引来访问列表中的值，下标从0开始计数\n\n```python\n# 使用下标索引来访问列表中的值，下标从0开始计数\n\n>>> tup1 = ('physics', 'chemistry', 1997, 2000)\n>>> tup2 = (1, 2, 3, 4, 5, 6, 7 )\n\n>>> print(\"tup1[0]: \",tup1[0])\n>>> print(\"tup2[1:5]: \",tup2[1:5])\n>>> print(\"tup2[1:]: \",tup2[1:]:)\n>>> print(\"tup2[-2]: \",tup2[-2]:)\n\ntup1[0]: physics\ntup2[1:5]: (2, 3, 4, 5)\ntup2[1:]: (2, 3, 4, 5, 6, 7)\ntup2[-2]: 6\n```\n\n#### 2.2 修改元组\n> 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合\n\n```python\n# 以下修改元组元素操作是非法的。\n# tup1[0] = 100\n\n>>> tup1 = (12, 34.56);\n>>> tup2 = ('abc', 'xyz')\n\n# 创建一个新的元组\n>>> tup3 = tup1 + tup2\n>>> print(tup3)\n\n(12, 34.56, 'abc', 'xyz')\n```\n\n#### 2.3 删除元组\n> 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组\n\n```python\n>>> tup = ('physics', 'chemistry', 1997, 2000)\n>>> print(tup)\n>>> del tup\n>>> print(\"After deleting tup : \",tup)\n\n# 以上实例元组被删除后，输出变量会有异常信息\n('physics', 'chemistry', 1997, 2000)\nAfter deleting tup :\nTraceback (most recent call last):\n  File \"test_deltup.py\", line 9, in <module>\n    print tup;\nNameError: name 'tup' is not defined\n```\n\n#### 2.4 元组运算符\n> 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。\n\n|Python 表达式|结果结果|描述|\n|:----: | :----: | :----: |\n|len((1, 2, 3))|3|计算元素个数|\n|(1, 2, 3) + (4, 5, 6)|(1, 2, 3, 4, 5, 6)|连接|\n|('copy',) * 4|('copy', 'copy', 'copy', 'copy')|复制 |\n|3 in (1, 2, 3)|True|元素是否存在|\n|for x in (1, 2, 3): print x,|1 2 3|迭代|\n\n#### 2.5 无关闭分隔符\n> 任意无符号的对象，以逗号隔开，默认为元组\n\n```python\n>>> tup1 = 1,2,3,4,5\n>>> tup2 = 'A','B','C','D','E'\n>>> print(tup1)\n>>> print(tup2)\n\n(1, 2, 3, 4, 5)\n('A', 'B', 'C', 'D', 'E')\n```\n\n#### 2.6 len() 计算元组元素个数\n**语法说明**\n> len(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回元组中元素个数\n\n```python\n>>> tuple1 = ('Google', 'Baidu', 'Taobao')\n>>> print(len(tuple1))\n\n3\n```\n\n#### 2.7 max() 返回元组中元素最大值\n\n**语法说明**\n> max(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回元组中元素最大值。\n\n```python\n>>> tuple2 = ('5', '4', '8')\n>>> print(max(tuple2))\n\n8\n```\n\n#### 2.8 min() 返回元组中元素最小值\n\n**语法说明**\n> min(tuple)\n\n**参数说明**\n* tuple -- 元组对象\n\n**返回值**\n> 该方法返回值返回元组中元素最小值\n\n```python\n>>> tuple2 = ('5', '4', '8')\n>>> print(min(tuple2))\n\n4\n```\n\n#### 2.9 tuple() 将列表转换为元组\n\n**语法说明**\n> tuple(seq)\n\n**参数说明**\n* seq -- 序列对象，如列表\n\n**返回值**\n> 该方法返回值转换后的元组对象\n\n```python\n>>> list1= ['Google', 'Taobao', 'Facebook', 'Baidu']\n>>> tuple1=tuple(list1)\n>>> print(tuple1)\n\n('Google', 'Taobao', 'Facebook', 'Baidu')\n```","categories":["Python系列"]},{"title":"Python数据类型之列表","url":"/2019/10/30/Python数据类型之列表/","content":"\n## 列表类型(list)\n\n\n### 1. 列表介绍\n列表是我们最以后最常用的数据类型之一，通过列表可以对数据实现最方便的存储、修改等操作。\n\n#### 1.1 定义方式\n```python\n# 定义：[]内可以有多个任意类型的值，逗号分隔\n\n# 定义方法1\n>>> l=['apple','banana','peach']\n>>> print(l)\n['apple', 'banana', 'peach']\n\n# 定义方法2\n>>> l=list(['apple','banana','peach'])\n>>> print(l)\n['apple', 'banana', 'peach']\n```\n\n------------\n\n\n### ★2. 常用列表方法\n#### 2.1 list[index] 访问列表中的值\n**语法说明**\n> 使用下标索引来访问列表中的值，下标从0开始计数\n\n```python\n# 通过下标访问列表中的值，下标从0开始计数\n>>> list1 = ['Google', 'Facebook', 'Baidu', 'Apple']\n>>> list1[0]\n'Google'\n```\n\n#### 2.2 list[index_start：index_end] 切片:取多个元素\n**语法说明**\n> 使用方括号的形式截取字符\n\n```python\n# 通过[]索引截取列表中的元素\n\n# 取下标1至下标4之间的数字，包括1，不包括4\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[1:4]\n['B', 'C', 'D']\n\n# 取下标1至-1的值，不包括-1\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[1:-1]\n['B', 'C', 'D', 'E']\n\n# 取下标0至3的值\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[0:3]\n['A', 'B', 'C']\n\n# 如果是从头取，则和上面例子相同，取下标0至3的值\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[:3]\n['A', 'B', 'C']\n\n# 如果想取最后一个，必须不能写-1，只能这么写\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[3:]\n['D', 'E', 'F']\n\n# 如果不想取最后一个，则要这样写，这样-1就不会被包含了\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[3:-1]\n['D', 'E']\n\n# 后面的2是代表，每隔一个元素，就取一个\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[0::2]\n['A', 'C', 'E']\n\n# 后面的2是代表，每隔一个元素，就取一个\n>>> l = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"]\n>>> l[::2]\n['A', 'C', 'E']\n```\n\n#### 2.3 append() 列表追加\n**语法说明**\n> list.append(obj)\n\n**参数说明**\n* obj -- 添加到列表末尾的对象。\n\n**返回值**\n> 该方法无返回值，但是会修改原来的列表。\n\n```python\n# append()对列表进行追加原色\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l.append(\"Baidu\")\n>>> list1\n[\"Google\", \"Facebook\", \"Taobao\",\"Baidu\"]\n```\n\n#### 2.4 insert() 列表元素插入\n**语法说明**\n> list.insert(index, obj)\n\n**参数说明**\n* index -- 对象obj需要插入的索引位置。\n* obj -- 要插入列表中的对象。\n\n**返回值**\n> 该方法没有返回值，但会在列表指定位置插入对象。\n\n```python\n# insert() 将指定对象插入列表的指定位置。\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l.insert(1, \"Baidu\")\n>>> l\n[\"Google\", \"Baidu\", \"Facebook\", \"Taobao\"]\n```\n\n#### 2.5 列表修改\n**语法说明**\n> list[index] = new_obj\n\n**参数说明**\n* index -- 对象new_obj需要写入的索引位置。\n\n**返回值**\n> 该方法没有返回值，但会在列表指定位置更新对象。\n\n```python\n# 将新对象赋值到指定位置\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\"]\n>>> l[1] = \"Baidu\"\n>>> l\n[\"Google\", \"Baidu\", \"Taobao\"]\n```\n\n#### 2.6 列表元素删除\n**语法说明**\n> del list[index]\n> list.remove(obj)\n> list.pop()\n\n**参数说明**\n* index -- 列表的索引位置。\n* obj -- 列表中的对象。\n\n**返回值**\n> 以上三种方法没有返回值，但会更新列表对元素对象，将指定元素删除\n\n - 2.6.1 del list[index]\n```python\n# del list[index] 删除列表指定位置的元素\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> del l[1]\n>>> l\n[\"Google\",\"Baidu\", \"Taobao\"]\n```\n\n - 2.6.2 list.remove(obj)\n```python\n# list.remove(obj) 删除列表指定对象\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> l.remove(\"Facebook\")\n>>> l\n[\"Google\",\"Baidu\", \"Taobao\"]\n```\n\n - 2.6.3 list.pop()\n```python\n# list.pop() 删除列表中最后一个对象\n\n>>> l=[\"Google\", \"Facebook\", \"Baidu\", \"Taobao\"]\n>>> l.pop()\n>>> l\n[\"Google\", \"Facebook\", \"Baidu\"]\n```\n\n#### 2.7 extend() 列表扩展元素\n**语法说明**\n> list.extend(seq)\n\n**参数说明**\n* seq -- 元素列表。\n\n**返回值**\n> 该方法没有返回值，但会在已存在的列表中添加新的列表内容。\n\n```python\n# extend()用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。\n\n# 将由0至4的新列表l2扩展到l1列表最后\n>>> l1 = [\"Google\", \"Facebook\", \"Taobao\"]\n>>> l2=list(range(5))\n>>> l1.extend(l2)\n>>> l1\n[\"Google\", \"Facebook\", \"Taobao\", 0, 1, 2, 3, 4]\n```\n\n#### 2.8 count() 统计列表中某个元素出现的个数\n**语法说明**\n> list.count(obj)\n\n**参数说明**\n* obj -- 列表中统计的对象。\n\n**返回值**\n> 返回元素在列表中出现的次数。\n\n```python\n# count()用于统计某个元素在列表中出现的次数。\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\", \"Baidu\", \"Google\"]\n>>> l.count(\"Google\")\n2\n\n>>> l=[\"Google\", \"Facebook\", \"Taobao\", \"Baidu\", \"Google\"]\n>>> l.count(\"Facebook\")\n1\n```\n\n#### 2.9 sort() 列表排序\n**语法说明**\n> list.sort([func])\n\n**参数说明**\n* func -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。\n\n**返回值**\n> 该方法没有返回值，但是会对列表的对象进行排序。\n\n```python\n# sort()用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。\n\n# 列表中的元素都是数字，进行排序\n>>> l=[1,2,3,4,5,6,7,8,9]\n>>> l.sort()\n>>> l\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 列表中的元素都是字符串，进行排序\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.sort()\n>>> l\n['Baidu', 'Facebook', 'Google', 'Taobao']\n```\n\n#### 2.10 reverse() 列表翻转\n**语法说明**\n> list.reverse()\n\n**返回值**\n> 该方法没有返回值，但是会对列表的元素进行反向排序。\n\n```python\n# reverse()用于反向列表中元素。\n\n# 将列表中的元素反向排序至列表中\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.reverse()\n>>> l\n['Taobao', 'Facebook', 'Google', 'Baidu']\n```\n\n#### 2.11 index() 获取列表指定元素下标\n**语法说明**\n> list.index(obj)\n\n**参数说明**\n* obj -- 查找的对象。\n\n**返回值**\n> 该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。\n\n```python\n# index()用于从列表中找出某个值第一个匹配项的索引位置。\n\n>>> l=[\"Baidu\",\"Google\",\"Facebook\",\"Taobao\"]\n>>> l.index(\"Taobao\")\n3\n```\n\n#### ☆2.12 copy() 浅拷贝 / copy.deepcopy() 深拷贝\n**语法说明**\n***copy()***\n> list.copy()\n\n***copy.deepcopy()***\n> copy.deepcopy(origin_list)\n\n**参数说明**\n* origin_list表示深拷贝所拷贝的原始列表\n\n**返回值**\n> 返回复制后的新列表。\n\n - 2.12.1 copy() 浅拷贝\n```python\n# copy()用于复制列表，类似于 a[:]\n\n# 将l1列表拷贝至l2列表中，l1与l2两列表元素相同\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = l1.copy()\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n\n# 注意，上述例子中如果在l1原始列表进行更改，l2列表会随之改变，此即为浅拷贝\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = l1.copy()\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n>>> l1[3].append(\"NewComer\")\n>>> l1\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n```\n\n - 2.12.2 copy.deepcopy() 深拷贝\n```python\n# copy.deepcopy()深拷贝，copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。\n\n# 与浅拷贝不同，深拷贝的情况下，如果在l1原始列表进行更改，l2列表不会随之改变，此即为深拷贝\n>>> import copy\n>>> l1=[\"Google\", \"Facebook\", \"Baidu\",[\"Apple\",\"Banana\",\"Peach\"]]\n>>> l2 = copy.deepcopy(l1)\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n>>> l1[3].append(\"NewComer\")\n>>> l1\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach', 'NewComer']]\n>>> l2\n['Google', 'Facebook', 'Baidu', ['Apple', 'Banana', 'Peach']]\n```\n\n - 2.12.3 深浅拷贝原理解析\n* ##### 浅拷贝\n![](/images/post_imgs/shallow.png)\n* ##### 深拷贝\n![](/images/post_imgs/deep.png)\n\n\n","categories":["Python系列"]},{"title":"Python数据类型之字符串类型","url":"/2019/10/24/Python数据类型之字符串类型/","content":"\n## 字符串类型(string)\n\n### 字符串介绍\n#### 定义方式\n在单引号、双引号、三引号内，由一串字符组成\n\n```python   \n#单引号\nname='Elijah'\n\n#双引号\ntitle=\"Python developer\"\n\n#三引号，表示多行的字符串，可以在三引号中自由的使用单引号和双引号\nmessage=\n'''\n立志成为一名\"身体健康\"的'开发者'\n'''\n```\n\n---\n\n### ★常用字符串方法\n#### strip() / lstrip() / rstrip() 去除指定字符串(默认去除空格)\n\n```python\n# strip() 去掉字符串前后的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.strip()\n\"Hello World\"\n\n# lstrip() 去掉字符串左边(left)的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.lstrip()\n\"Hello World   \"\n\n# rstrip() 去掉字符串右边(right)的空格(默认情况下)\n>>> s = \"   Hello World   \"\n>>> s.rstrip()\n\"   Hello World\"\n\n# strip(\"str_args\") 去掉字符串前后的指定字符(传入指定字符参数情况下)\n# lstrip(\"str_args\")与rstrip(\"str_args\")同理\n>>> s = \"***Hello World***\"\n>>> s.strip('*')\n\"Hello World\"\n```\n\n#### startswith() / endswith() 判断字符串开头/结尾\n\n```python\n# startswith(\"str_args\") 判断目标字符串是否以指定字符串开头\n>>> s=\"Hello_World\"\n>>> s.startswith(\"Hello\")\nTrue\n\n>>> s=\"Hello_World\"\n>>> s.startswith(\"ello\")\nFalse\n\n# endswith(\"str_args\") 判断目标字符串是否以指定字符串结尾\n>>> s=\"Hello_World\"\n>>> s.endswith(\"World\")\nTrue\n\n>>> s=\"Hello_World\"\n>>> s.endswith(\"Worl\")\nFalse\n```\n\n\n#### replace() 替换字符串\n**语法说明**\n> str.replace(old, new[, max])\n\n**参数说明**\n* old -- 将被替换的子字符串。\n* new -- 新字符串，用于替换old子字符串\n* max -- 可选字符串, 替换不超过 max 次\n\n```python\n# replace() 替换字符串，传入参数依次为旧字符串、新字符串、替换最大次数\n>>> s=\"Hello World\"\n>>> s.replace(\"World\",\"Python\")\n\"Hello Python\"\n\n>>> s=\"In the apple case, there is a red apple beside the green apple.\"\n>>> s.replace(\"apple\",\"peach\",2)\n\"In the peach case, there is a red peach beside the green apple.\"\n```\n\n#### format() 格式化字符串\n**语法说明**\n>* 格式化字符串的函数 str.format()，它增强了字符串格式化的功能\n>* 基本语法是通过 {} 和 : 来代替以前的 %\n>* format 函数可以接受不限个参数，位置可以不按顺序\n\n```python\n# format() 格式化字符串，不设置指定位置，按默认顺序\n>>>\"{} {}\".format(\"hello\", \"world\")\n'hello world'\n\n# format() 格式化字符串，设置指定位置\n>>> \"{arg_2} {arg_1}\".format(arg_2=\"hello\", arg_1=\"world\")\n'hello world'\n\n# format() 格式化字符串，设置指定位置\n>>> \"{1} {0} {1}\".format(\"hello\", \"world\")\n'world hello world'\n```\n\n - 2.4.1 数字格式化\n> 下表展示了 str.format() 格式化数字的多种方法：\n\n```python\n>>> print(\"{:.2f}\".format(3.1415926));\n3.14\n```\n\n**格式化符号说明**\n\n* '^'、'<'、'>' 分别是居中、左对齐、右对齐，后面带宽度， ':' 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。\n* '+' 表示在正数前显示 '+'，负数前显示 '-'\n* ' '（空格）表示在正数前加空格\n* 'b'、'd'、'o'、'x' 分别是二进制、十进制、八进制、十六进制。\n* 此外我们可以使用大括号 '{}' 来转义大括号，如下实例\n\n```python\n>>> print (\"{} 对应的位置是 {{0}}\".format(\"yang\"))\nyang 对应的位置是 {0}\n```\n\n| 数字| 格式 | 输出| 描述|\n|---|---|---|---|\n| 3.1415926  | {:.2f}           | 3.14      | 保留小数点后两位            |\n| 3.1415926  | {:+.2f}          | +3.14     | 带符号保留小数点后两位       |\n| -1         | {:+.2f}          | -1.00     | 带符号保留小数点后两位       |\n| 2.71828    | {:.0f}           | 3         | 不带小数                    |\n| 5          | {:0>2d}          | 05        | 数字补零 (填充左边, 宽度为2) |\n| 5          | {:x<4d}          | 5xxx      | 数字补x (填充右边, 宽度为4)  |\n| 10         | {:x<4d}          | 10xx      | 数字补x (填充右边, 宽度为4)  |\n| 1000000    | {:,}             | 1,000,000 | 以逗号分隔的数字格式         |\n| 0.25       | {:.2%}           | 25.00%    | 百分比格式                  |\n| 1000000000 | {:.2e}           | 1.00e+09  | 指数记法                    |\n| 13         | {:10d}           | 13        | 右对齐 (默认, 宽度为10)      |\n| 13         | {:<10d}          | 13        | 左对齐 (宽度为10)           |\n| 13         | {:^10d}          | 13        | 中间对齐 (宽度为10)         |\n| 11         |'{:b}'.format(11) | 1011      | 进制                       |\n|            |'{:d}'.format(11) |11         |                            |\n|            |'{:o}'.format(11) |13         |                            |\n|            |'{:x}'.format(11) |b          |                            |\n|            |'{:#x}'.format(11)|0xb        |                            |\n|            |'{:#X}'.format(11)|0xB        |                            ||\n\n#### find() / rfind() 查找字符串位置、index() / rindex() 查找字符串位置、count() 查找字符串出现次数\n\n**语法说明**\n***find()***\n> str.find(str, beg=0, end=len(string))\n\n***index()***\n> str.index(str, beg=0, end=len(string))\n\n***count()***\n> str.count(str, beg= 0,end=len(string))\n\n**参数说明**\n* str -- 指定检索的字符串\n* beg -- 开始索引，默认为0\n* end -- 结束索引，默认为字符串的长度\n\n**返回值**\n***find()***\n> 如果包含子字符串返回开始的索引值，否则返回-1。\n> rfind() 返回字符串最后一次出现的位置，其他属性与find()相同\n\n***index()***\n> 如果包含子字符串返回开始的索引值，否则报异常。\n> rindex() 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，可以指定可选参数[beg:end]设置查找的区间。\n\n***count()***\n> 该方法返回子字符串在字符串中出现的次数,顾头不顾尾,如果不指定范围则查找所有\n\n - find() / rfind() 查找字符串位置\n \n```python\n# find() 查找字符串位置/ rfind()返回字符串最后一次出现的位置，其他属性与find()相同\n\n# 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0\n>>> s='abca'\n>>> s.find('a')\n0\n\n# 从下标1开始，查找在字符串里第一个出现的子串：返回结果3\n>>> s='abca'\n>>> s.find('a',1)\n3\n\n# 查找不到返回-1\n>>> s='abca'\n>>> s.find('3')\n-1\n>>>\n```\n\n - index() / rindex() 查找字符串位置\n \n```python\n# index() 查找字符串位置/ rindex()返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，可以指定可选参数[beg:end]设置查找的区间。\n\n# 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0\n>>> s='abca'\n>>> s.index('a')\n0\n# 从下标1开始，查找在字符串里第一个出现的子串：返回结果3\n>>> s='abca'\n>>> s.index('a',1)\n3\n# 查找不到报异常\n>>> s='abca'\n>>> s.find('3')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: substring not found\n```\n\n - count() 查找字符串出现次数\n \n```python\n# count() 该方法返回子字符串在字符串中出现的次数,顾头不顾尾,如果不指定范围则查找所有。\n\n# 查找a出现的次数，没有指定范围默认查找所有\n>>> s='abca'\n>>> s.count('a')\n2\n\n# 查找a出现的次数，指定范围从1到4,返回1次\n>>> s='abca'\n>>> s.count('a',1,4)\n1\n\n# 查找z出现的次数，没有则返回0次\n>>> s='abca'\n>>> s.count('z')\n0\n```\n\n\n#### split() / rsplit() 切分字符串\n\n**语法说明**\n> str.split(str=\"\", num=string.count(str))\n\n**参数说明**\n* str -- 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。\n* num -- 分割次数。\n\n**返回值**\n> 返回分割后的字符串列表。返回分割后的字符串列表。\n> rsplit()表示从右向左开始切分\n\n```python\n# split() 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 / rsplit() 表示从右向左开始进行切分，其他同split()\n\n# 默认以空格进行分割，也就是下例中的\\n\n>>> s=\"Line1-abcdef \\nLine2-abc \\nLine4-abcd\";\n>>> s.split( )\n['Line1-abcdef', 'Line2-abc', 'Line4-abcd']\n\n# 指定的切片次数为1次，所以后面的两个\\n保留\n>>> s.split(' ', 1 )\n['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd']\n\n# rsplit() 从右向左以'|'字符进行切分，切分次数为1次\n>>> s='a|b|c'\n>>> s.rsplit('|',1)\n['a|b', 'c']\n```\n\n\n#### join() 连接字符串\n**语法说明**\n> str.join(sequence)\n\n**参数说明**\n* sequence -- 要连接的元素序列。\n\n**返回值**\n> 返回通过指定字符连接序列中元素后生成的新字符串。\n\n```python\n# join() 连接字符串\n\n# 将序列seq中的元素'a','b','c'以指定的字符'-'连接生成一个新的字符串。\n>>> s=\"-\"\n>>> seq=(\"a\", \"b\", \"c\")\n>>> s.join(seq)\n\"a-b-c\"\n```\n\n\n#### center() / ljust() / rjust() / zfill() 填充字符串\n**语法说明**\n***center()***\n> str.center(width[, fillchar])\n\n***ljust()***\n> str.ljust(width[, fillchar])\n\n***rjust()***\n> str.rjust(width[, fillchar])\n\n***zfill()***\n> str.zfill(width)\n\n\n**参数说明**\n* width -- 指定字符串长度。\n* fillchar -- 填充字符，默认为空格。\n\n**返回值**\n***center()***\n> 返回一个指定的宽度 width 居中的字符串，如果 width 小于字符串宽度直接返回字符串，否则使用 fillchar 去填充。\n\n***ljust()***\n> 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n***rjust()***\n> 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。\n\n***zfill()***\n> 返回指定长度的字符串。\n\n - center() 填充字符串\n \n```python\n# center() 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。\n\n# 指定字符串长度为40，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.center(40, '*')\n\"**********[www.elijahyang.com]**********\"\n```\n\n - ljust() 填充字符串(左对齐)\n \n```python\n# ljust() 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n# 指定字符串长度为40，左对齐，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.ljust(40, '*')\n\"[www.elijahyang.com]********************\"\n```\n\n - rjust() 填充字符串(右对齐)\n \n```python\n# rjust() 返回一个原字符串右对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。\n\n# 指定字符串长度为40，右对齐，用'*'来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.rjust(40, '*')\n\"********************[www.elijahyang.com]\"\n```\n\n - zfill() 填充字符串(右对齐,填充0)\n \n```python\n# zfill() 返回指定长度的字符串，原字符串右对齐，前面填充0。\n\n# 指定字符串长度为40，右对齐，用0来填充\n>>> s=\"[www.elijahyang.com]\"\n>>> s.zfill(40)\n\"00000000000000000000[www.elijahyang.com]\"\n```\n\n\n#### expandtabs() 把tab转换成空格\n**语法说明**\n> str.join(sequence)\n\n**参数说明**\n* tabsize -- 指定转换字符串中的 tab 符号('\\t')转为空格的字符数。\n\n**返回值**\n> 该方法返回字符串中的 tab 符号('\\t')转为空格后生成的新字符串。\n\n```python\n# expandtabs() 指定转换字符串中的 tab 符号('\\t')转为空格的字符数。\n\n# 将s字符串中\\t转换为空格(默认\\t空格数为8)\n# 实际操作中\\t的默认转换为空格数为1\n>>> s=\"this is\\tstring example\"\n>>> s.expandtabs()\n\"this is string example\"\n\n# 将s字符串中\\t转换为空格(指定\\t空格数为16)\n>>> s=\"this is\\tstring example\"\n>>> s.expandtabs(16)\n\"this is         string example\"\n```\n\n\n#### lower() / upper() 字符串英文大小写转换\n**语法说明**\n> str.lower()\n> str.upper()\n\n**返回值**\n> 返回将字符串中所有大写字符转换为小写后生成的字符串。\n> 返回将字符串中所有大写字符转换为大写后生成的字符串。\n\n - lower() 字符转换为小写\n \n```python\n# lower() 将字符串中所有字符转换为小写\n\n>>> s=\"HELLO WORLD\"\n>>> s.lower()\n\"hello world\"\n```\n\n - upper() 字符转换为大写\n \n```python\n# upper() 将字符串中所有字符转换为大写\n\n>>> s=\"hello world\"\n>>> s.upper()\n\"HELLO WORLD\"\n```\n\n\n#### capitalize() 首字母大写 / swapcase() 大小写翻转 / title() 每个单词的首字母大写\n\n**语法说明**\n> str.capitalize()\n> str.swapcase()\n> str.title()\n\n**返回值**\n***capitalize()***\n> 该方法返回一个首字母大写的字符串。\n\n***swapcase()***\n> 返回大小写字母转换后生成的新字符串。\n\n***title()***\n> 返回\"标题化\"的字符串,就是说所有单词都是以大写开始。\n\n\n - capitalize() 首字母大写\n \n```python\n# capitalize() 首字母大写\n\n>>> s=\"this is string example from yang\"\n>>> s.capitalize()\n\"This is string example from yang\"\n```\n\n - swapcase() 大小写字母互换\n \n```python\n# swapcase() 大小写字母互换\n\n>>> s=\"tHiS Is sTrINg eXaMPle FRoM YaNg\"\n>>> s.swapcase()\n\"ThIs iS StRinG ExAmpLE frOm yAnG\"\n```\n\n - title() 每个单词的首字母大写\n```python\n# title() 每个单词的首字母大写\n\n>>> s=\"this is string example from yang\"\n>>> s.title()\n\"This Is String Example From Yang\"\n```\n\n\n#### maketrans() 字符串对照表翻译\n\n**语法说明**\n> str.maketrans(intab, outtab)\n\n**参数说明**\n* intab -- 字符串中要替代的字符组成的字符串。\n* outtab -- 相应的映射字符的字符串。\n\n**返回值**\n>返回字符串转换后生成的新字符串。\n\n```python\n# maketrans() 用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。\n\n# 用12345来代替原本字符串那种的aeiou字符\n>>> intab = \"aeiou\"\n>>> outtab = \"12345\"\n>>> trantab = str.maketrans(intab, outtab)\n>>> str = \"this is string example\"\n>>> str.translate(trantab)\n\"th3s 3s str3ng 2x1mpl2\"\n```\n\n\n#### len() 字符串长度\n\n**语法说明**\n> len( s )\n\n**参数说明**\n* s -- 对象。\n\n**回值**\n>返回对象长度。\n\n```python\n#  字符串长度\n\n>>> s=\"yang\"\n>>> len(s)\n4\n```\n\n\n#### str[::-1] 字符串翻转*\n\n```python\n# [::-1]通过步进反转\n\n>>> s = 'abcd'\n>>> new_s = s[::-1]\n>>> new_s\n'dcba'\n```\n\n### 其他字符串方法\n#### is数字系列(在python3中)\n\n - isdigt() 判断是否是数字(bytes、unicode)\n > 对于bytes、unicode使用isdigt()方法，返回True，其他返回False\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum1.isdigit()\nTrue\nnum2.isdigit()\nTrue\nnum3.isdigit()\nFalse\nnum4.isdigit()\nFalse\n```\n\n - isdecimal() 判断是否只包含十进制字符(unicode)\n>对于unicode使用isdecimal()方法，返回True，其他返回False\n>bytes类型无isdecimal()方法\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum2.isdecimal()\nTrue\nnum3.isdecimal()\nFalse\nnum4.isdecimal()\nFalse\n```\n\n - isnumeric() 判断是否是否只由数字组成(unicode)\n> 对于unicode使用isnumeric()方法，返回True，其他返回False\n> bytes类型无isnumeric()方法\n\n```python\nnum1=b'4' # bytes\nnum2=u'4' # unicode,python3中无需加u就是unicode\nnum3='四' # 中文数字\nnum4='Ⅳ' # 罗马数字\n\nnum2.isnumeric()\nTrue\nnum3.isnumeric()\nTrue\nnum4.isnumeric()\nTrue\n```\n\n - Tips\n> 以上isdigit() 、 isdecimal() 、 isnumeric() 均不能判断浮点数\n\n\n\n#### is其他系列(在python3中)\n - isalnum() 判断是否由字母和数字组成\n> 字符串至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False\n\n```python\n>>> str = \"yang0827\"\n>>> str.isalnum()\nTrue\n\n>>> str = \"www.baidu.com\"\n>>> str.isalnum()\nFalse\n```\n\n - isalpha() 判断是否只由字母组成\n> 如果字符串至少有一个字符并且所有字符都是字母则返回 True,否则返回 False\n\n```python\n>>> s=\"yang\"\n>>> s.isalpha()\nTrue\n\n>>> s=\"yang example....!!!\"\n>>> s.isalpha()\nFalse\n```\n\n - isidentifier() 判断是否是合法的标识符\n> 如果字符串是合法的标识符则返回 True,否则返回 False\n\n```python\n>>> s=\"_a\"\n>>> s.isidentifier()\nTrue\n\n>>> s=\"中国\"\n>>> s.isidentifier()\nTrue\n\n>>> s=\"3a\"\n>>> s.isidentifier()\nFalse\n```\n\n - islower() 判断是否由小写字母组成\n> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False\n\n```python\n>>> s=\"this is a example\"\n>>> s.islower()\nTrue\n\n>>> s=\"This is a example\"\n>>> s.islower()\nFalse\n```\n\n - isupper() 判断是否由大写字母组成\n> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False\n\n```python\n>>> s=\"THIS IS A EXAMPLE\"\n>>> s.isupper()\nTrue\n\n>>> s=\"This Is A Example\"\n>>> s.isupper()\nFalse\n```\n\n - isspace() 判断是否只由空白字符组成\n> 如果字符串中只包含空格，则返回 True，否则返回 False\n\n```python\n>>> s=\"      \"\n>>> s.isspace()\nTrue\n\n>>> s=\"this is a example\"\n>>> s.isspace()\nFalse\n```\n\n -istitle() 判断是否字符串中所有的单词拼写首字母是否为大写，且其他字母为小写\n> 如果字符串中所有的单词拼写首字母是否为大写，且其他字母为小写则返回 True，否则返回 False\n\n```python\n>>> s=\"This is a example\"\n>>> s.istitle()\nTrue\n\n>>> s=\"This Is A Example\"\n>>> s.istitle()\nFalse\n```","categories":["Python系列"]},{"title":"Python数据类型之布尔类型","url":"/2019/10/13/Python数据类型之布尔类型/","content":"\n## 布尔类型(boolean)\n布尔值只有True和False，同时True对应二进制中1，False对应二进制中0\n\n### 布尔运算\n> 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。\n#### 与运算\n> 只有两个布尔值都为 True 时，计算结果才为 True。\n\n| 值 | 运算符 | 值 | 结果 |\n|:----: | :----: | :----: | :----: |\n| True | and | True | True |\n| True | and | False | False |\n| False| and | True | False |\n| False| and | False | False |\n\n#### 或运算\n>只要有一个布尔值为 True，计算结果就是 True。\n\n| 值 | 运算符 | 值 | 结果 |\n|:----: | :----: | :----: | :----: |\n| True | or | True | True |\n| True | or | False | True |\n| False| or | True | True |\n| False| or | False | False |\n\n#### 非运算\n>把True变为False，或者把False变为True：\n\n| 运算符 | 值 | 结果 |\n| :----: | :----: | :----: |\n| not | True | False |\n| or | False | True |\n\n#### 短路计算\n在Python中，布尔类型还可以与其他数据类型做 and、or和not运算\n\n```python\na = True\nprint a and 'a=T' or 'a=F\n```\n\n计算结果不是布尔类型，而是字符串 'a=T'，这是为什么呢？\n因为Python把0、空字符串''和None看成 False，其他数值和非空字符串都看成 True，所以：\n\n```python\nTrue and 'a=T' 计算结果是 'a=T'\n继续计算 'a=T' or 'a=F' 计算结果还是 'a=T'\n```\n\n要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。\n - 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。\n - 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。\n\n`所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果`","categories":["Python系列"]},{"title":"Python数据类型之数字","url":"/2019/10/11/Python数据类型之数字/","content":"\n## 数字类型(integer)\n\n### 整型(int)\n在32位机器上，整数的位数为32位，取值范围为-2\\*\\*31～2\\*\\*31-1，即-2147483648～2147483647\n在64位系统上，整数的位数为64位，取值范围为-2\\*\\*63～2\\*\\*63-1，即-9223372036854775808～9223372036854775807\n\n### 长整型(long) \n和C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。 \n自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。\n\n```python\n# 在python2.x 中（python3.x中没有长整型的概念）：\n>>> num=2L\n>>> type(num)\n    <type 'long'>\n```\n\n### 浮点型(float)\n浮点数用来处理实数，也就是带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。\n\n### 复数(complex)  \n复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。\n\n\n```python\n>>> x=1-2j\n>>> x.real\n1.0\n>>> x.imag\n-2.0\n```\n\n### 进制转换\n\n```txt\nbin(var) # 把变量转换为2进制\noct(var) # 把变量转换为8进制\nint(var) # 把变量转换为10进制\nhex(var) # 把变量转换为16进制\n```\n\n### 小知识点\n - Python中存在小数字池：`-5 ～ 256，即[-5,257]`\n\nPython对小整数的定义是[-5,257]这些整数对象是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。\n同理，单个字母也是这样的。\n\n在一般情况下当变量被赋值后，内存和变量的关系如下：\n\n```python\n# 方式一\nn1 = 123\nn2 = 123\n```\n![](/images/post_imgs/integer_1.png)\n\n\n```python\n# 方式二\nn1 = 123\nn2 = n1\n```\n\n![](/images/post_imgs/integer_2.png)\n\n\n由于python内的优化机制，不论是2.x还是3.x都存在，在-5~257之间的数，如果使用第一种赋值方式，那么他们依然属于同一块内存\n\n```python\nprint(id(n1)) # 查看变量的内存地址\n```\n\n\n","categories":["Python系列"]},{"title":"python IDE介绍 & 环境搭建","url":"/2019/09/25/python IDE介绍&环境搭建/","content":"\n## Python2.x VS Python3.x\n### 为什么会有Python3.x\n相信但凡接触过python语言的朋友在接触之初会有“到底用python2还是python3？”的纠结。其实我也有这方面的疑问，为什么python的核心团队不能统一一下呢？非要搞个2.x和3.x，而且3.x还不能向下兼容，这中操作让曾经已经用python2.x编写完成的项目情何以堪，还要费神费力去升级成python3.x，到底是什么因素导致必须要重构python核心内容呢？\n通过多方调查，终于在Python的核心成员**Brett Cannon**的文章中略知其中一二。首先，我们先来看以下下面这个字符串表示什么意思？\n```python\n'abcd'\n```\n一目了然，代表由字母'a'、'b'、'c'、'c'组成的字符串，但是，如果你是个python2的使用者，你也可能会说代表ASCII码对应的数值97、98、99、100，至此，大家就会看出问题了，那在python2.x中，字符串默认是以ASCII码的形式呈现的，这样的设计就会产生我们上面这样的歧义。正如python之禅中所说\"there should be one -- and preferably only one -- obvious way to do it\"，对于python的代码，应该做到一种呈现只对应一种可能，而上述例子中显然就违背了这样的原则。而这种歧义的产生，不单单是违背了语言的设计初衷，更严重的是这种歧义会在程序的开发中让人抓狂，因为对于字符串而言，开发者必须时刻清楚的知道它代表的到底是字符串还是二进制的数据，否则对于大型程序而言，后果不堪设想。\n相信上面的内容会让大家清楚Python2.x所存在的重大缺陷，但是我们的问题依然没有得到很好的回答，我们还会抱有疑问“那为什么不在最开始设计的时候就避免出现这种缺陷呢？一定要在之后再做这种不兼容的修复？”，这就要回到python的诞生了，Guido于1989年12月开始对Python进行编码，并于1991年2月首次以开源形式发布。而Unicode标准的第一卷是在1991年10月发布的，这说明python在设计之初并没有所谓的unicode和ASCII编码的问题，但是随着python的应用程度越来越广泛，ASCII码已经不能满足其需要，而且unicode编码的应用和推广也越来越广泛，python2的缺陷也就显得越来越不可调和，最终导致核心团队必须将其升级来修复这个致命的问题。\n多说一句，针对为什么python3不向下兼容的问题，Brett Cannon是这样说的，python的核心团队在设计推广python3的时候以为python社区会针对python2进行bugfix，同时转到python3，但是事实并未如此，核心团队也吃一堑长一智，并保证今后不会再有类似的不可兼容的更新升级了。\n\n\n### 官方对于Python2.x和Python3.x的总结\n**In summary** : Python 2.x is legacy, Python 3.x is the present and future of the language Python 3.0 was released in 2008. The final 2.x version 2.7 release came out in mid-2010, with a statement of extended support for this end-of-life release. The 2.x branch will see no new major releases after that. 3.x is under active development and has already seen over five years of stable releases, including version 3.3 in 2012, 3.4 in 2014, and 3.5 in 2015. This means that all recent standard library improvements, for example, are only available by default in Python 3.x.\n\n**Guido van Rossum** (the original creator of the Python language) decided to clean up Python 2.x properly, with less regard for backwards compatibility than is the case for new releases in the 2.x range. The most drastic improvement is the better Unicode support (with all text strings being Unicode by default) as well as saner bytes/Unicode separation.\n\n**Besides**, several aspects of the core language (such as print and exec being statements, integers using floor division) have been adjusted to be easier for newcomers to learn and to be more consistent with the rest of the language, and old cruft has been removed (for example, all classes are now new-style, \"range()\" returns a memory efficient iterable, not a list as in 2.x).\n\n---\n\n## Python IDE介绍\n### Pycharm\n> http://www.jetbrains.com/pycharm/download/\n\nPycharm是由JetBrains公司推出的一款专门针对python开发者的IDE，秉承JetBrains的一贯风格，Pycharm具有调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制等基本功能。同时Pycharm对于Django、Flask等常用Web框架也做到了很好的支持。需要重点提出的是Pycharm还支持IronPython解释器。\n\n![](/images/post_imgs/pycharm.jpeg)\n\n### Sublime \n> https://www.sublimetext.com/3\n\n'A sophisticated text editor for code, markup and prose.'这是Sublime对自己的定位，不得不说sublime的强大、轻量和便捷。相比Pycharm等其他IDE的庞大，sublime作为一种“记事本”类型的IDE，深受追求简洁的开发者的热爱，同时轻量并不代表功能简单，其拥有的各种插件也是没有找不到，只有想不到。相信只要用过sublime的人就一定不会舍弃他。\n\n![](/images/post_imgs/sublime.jpg)\n\n### Visual Studio Code \n> https://code.visualstudio.com/\n\nVS code也是一款极为优秀的IDE。这款IDE拥有丰富的python扩展工具以便开发者可以更高效的进行项目的开发，包括代码静态分析语法自动不全、科学计算工具，与Jupyter 等工具的集成，重构，单元测试，调试等等。\n\n![](/images/post_imgs/vs_code.png)\n\n### Eclipse + Pydev\n> https://www.eclipse.org/ide/\n\n使用这种搭配的开发者基本上已经是个经验丰富的developer了，或者更明确的说很可能是一名Java开发老手，Eclipse这款IDE更广泛的被众多Java开发者所使用，如果已经习惯了Eclipse的操作，可以配以Pydev进行python项目的开发，可以在Eclipse中点击Help→Install new Software，添加pydev的安装地址：http://pydev.org/updates/，获取python的相关套件。具体操作方法请自行查阅，不过多赘述。\n\n\n### 其他\n当然python作为一种世界的编程语言，更何况现在的发展势头越来越火，IDE作为方便开发者的工具更是必不可少，以上只是介绍了极为有限的几款比较热门的python开发IDE，更多的python开发IDE请参阅：https://wiki.python.org/moin/PythonEditors\n\n---\n\n## Python开发环境搭建\n### 两种python虚拟环境工具介绍\n\n#### virtualenv\n> https://virtualenv.pypa.io/en/latest/#\n\n - 基本介绍\n**virtualenv**是用于创建隔离的Python环境，以达到不同的项目环境互不影响的目的。\n\n - virtualenv安装与使用\n\n```txt\n1、pip安装virtualenv\n>>> pip install virtualenv\n\n2、验证安装是否成功\n>>> virtualenv --version\n\n3、为项目创建隔离的python\n>>> cd  python_project\n>>> virtualenv python_project_env  # 这样是使用默认python解释器创建出来的项目\n\n4、也可以指定python解释器创建项目\n>>> virtualenv -p /usr/bin/python3.7 python3_project_env\n\n5、以上就完成了python虚拟环境的创建，该环境是一个独立的python运行环境，我们在需要使用该环境时可以将其激活\n>>> source python_project_env/bin/activate\n\n6、退出虚拟环境\n>>> deactivate\n\n```\n\n\n#### pipenv\n> https://pypi.org/project/pipenv/\n\n - 基本介绍\n**pipenv** 是 Pipfile 、requests 作者 Kenneth Reitz 写的一个命令行工具，主要包含了Pipfile、pip、click、requests和virtualenv。Pipfile和pipenv本来都是Kenneth Reitz的个人项目，后来贡献给了pypa组织。Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 requirements.txt 文件。\n**Pipfile的基本理念是：**Pipfile 文件是 TOML 格式而不是 requirements.txt 这样的纯文本。一个项目对应一个 Pipfile，支持开发环境与正式环境区分。默认提供 default 和 development 区分。提供版本锁支持，存为 Pipfile.lock。\n\n - pipenv安装与使用\n\n```txt\n1、pip安装pipenv\n>>> pip install pipenv\n\n2、验证安装是否成功\n>>> pipenv --version\n\n3、切换到项目目录\n>>> cd  python_project\n\n4、创建虚拟环境，可以指定用python2 或者 python3作为当前虚拟环境的python版本\n>>> pipenv --two\n>>> pipenv --three\n>>> pipenv --python 3.7  # 也可以指定Python版本来创建虚拟环境\n\n4、激活当前虚拟环境\n>>> pipenv shell\n\n5、在虚拟环境下给项目安装需要的模块，并将其写入到pipfile\n>>> pipenv install django=1.11.11\n\n6、退出虚拟环境\n>>> exit\n\n```\n\n - pipenv其他常用操作\n\n```txt\n1、查看项目位置\n>>> pipenv --where\n\n2、查看虚拟环境位置\n>>> pipenv --venv\n\n3、查看解释器信息\n>>> pipenv --py\n\n4、查看包的依赖结构\n>>> pipenv graph\n\n5、卸载模块\n>>> pipenv uninstall django\n\n6、卸载全部包并从Pipfile中移除\n>>> pipenv uninstall --all\n\n7、检查安全漏洞\n>>> pipenv check\n\n```\n\n### Windows下Python环境搭建\n\n与大多数UNIX系统和服务不同，Windows系统没有预安装Python。为了使Python可用，很多年来CPython 团队已经编译了每一个 [release](https://www.python.org/download/releases/) 的Windows安装程序（MSI 包）。这些安装程序主要用于每个用户单独安装Python时，添加核心解释器和库。安装程序还可以为一台机器的所有用户安装，并且可以为应用程序本地分发提供单独的zip文件。\n\n#### 安装包种类\n> https://www.python.org/downloads/\n\n - 32位/64位Python2.x安装包\n - 32位/64位Python3.x安装包\n - web installer（网络安装包）是一个小的初始化工具，它将在安装过程中，根据需要自动下载所需的组件。\n - offline installer（离线安装包）内含默认安装所需的组件，可选择功能仍需要Internet连接下载\n\n#### 官网下载python安装包\n\n> 此处以安装64位python3.x为例\n\n![](/images/post_imgs/win_installer.png)\n\n如果选择`立即安装`：\n - 不需要管理员权限\n - Python将安装到用户目录中\n - 将根据第一页底部的选项安装\n - 将安装标准库，测试套件，启动器和pip\n - 如果选择将安装目录将添加到 `PATH`\n - 快捷方式仅对当前用户可见\n\n如果选择`自定义安装`：\n - 要安装的功能\n - 安装位置\n - 其他选项或安装后的操作。\n - 如果要安装调试符号或二进制文件，需要使用此选项。\n\n#### ☆无UI安装\n - 要完全隐藏安装程序UI并静默安装Python，可以使用 `/quiet` 选项。\n - 要跳过用户交互但仍然显示进度和错误，可以使用 `/passive` 选项。\n - 可以通过 `/uninstall` 选项立即开始删除Python，即不会显示任何提示。\n - 例如，要以静默方式全局安装默认的Python，使用以下命令:\n\n```python\npython-3.7.4.exe /quiet InstallAllUsers=1 PrependPath=1 Include_test=0\n```\n\n#### 验证安装\n - 在命令行输入`python --version`以验证是否安装成功\n\n![](/images/post_imgs/version.png)\n\n\n### Linux(CentOS7.x)下Python环境搭建\n由于CentOS等大多数Linux发行版中默认安装了python2.7版本，但是对于python开发者而言python3.x的许多特性才是未来，所以本文介绍如何在CentOS7.x操作系统下安装python3.x。\n\n#### 安装依赖包\n - 在CentOS系统中安装python需要 GCC 编译器和 make 编译工具，其包含在 Development tools 软件组中，所以需要安装Development tools 软件组。\n```shell\nsudo yum groupinstall \"Development tools\"\n```\n\n - Python3.x 源文件使用 zlib 格式打包，所以需要安装 zlib 软件包,同时python在编译安装时需要使用 zlib 的头文件和链接库，所以需要安装 zlib 的头文件和链接库 zlib-devel 软件包。\n```shell\nsudo yum -y install zlib zlib-devel\n```\n\n - Python3.x 有个内置模块 ctypes，它是 Python3.x 的外部函数库，需要使用系统外部函数库（libffi）的头文件和链接库，所以需要安装外部函数库（libffi）头文件和链接库 libffi-devel 软件包。\n```shell\nsudo yum -y install libffi-devel\n```\n\n - 同时还需要一些其他python安装需要的模块，在此不一一做解释\n```shell\nsudo yum -y install bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n```\n\n#### 下载安装包解压\n```shell\ncd 安装包下载目录\nwget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tar.xz\ntar -xvJf  Python-3.7.4.tar.xz\n```\n\n#### 编译安装\n```shell\nmkdir /usr/local/python3  # 创建编译安装目录\ncd Python-3.7.4\n./configure --prefix=/usr/local/python3\nmake && make install\n```\n\n#### 创建软链接\n```shell\nln -s /usr/local/python3/bin/python3 /usr/local/bin/python3\nln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3\n```\n\n#### 验证安装\n- 在命令行输入`python --version`以验证是否安装成功\n\n\n### MacOS下Python环境搭建\nMacOS附带Apple预安装的Python2.7。同样，对于python开发者而言，肯定是需要python3.x环境的，那么如果选择从python官网安装较新的 Python 版本，那么Mac上将安装两个不同版本的Python ，因此在使用过程中python解释器的路径与想要执行的python版本一致非常重要。\n\n#### 官网下载python安装包\n> https://www.python.org/downloads/release/python-374/\n\n![](/images/post_imgs/mac-python.jpg)\n\n#### 验证安装\n - 在命令行输入`python --version`以验证是否安装成功\n\n#### 配置环境变量\n - 打开`.bash_profile`\n```shell\nvi ~/.bash_profile\n```\n\n - 添加别名，使python命令指向python3.x解释器\n```shell\nalias python=/usr/local/bin/python3.7\n```\n\n - 生效文件\n```shell\nsource .bash_profile\n```\n","categories":["Python系列"]},{"title":"Go语言起源","url":"/2019/09/22/Go语言起源/","content":"\n## Go语言的前世今生\n### 时代背景\n当今社会主流语言基本都诞生于上世纪90年代或者更早，例如Python(1991)、Java(1995)、C(1972)、C++(1983)、JavaScript(1995)、C#(2001)、PHP(1995)等等，同时我们也需要明白计算机硬件的发展，在2005年4月，英特尔的第一款双核处理器平台包括采用英特尔955X高速芯片组、主频为3.2GHz的英特尔奔腾处理器至尊版840，此款产品的问世标志着一个新时代来临了，那就是双核和多核处理器的时代。我们结合这些标志性的事件来看就不难发现，主流的服务端语言诞生的年代还都是单核年代，也就是说，当时的编程语言还是单核环境下，也就没有我们现在大家耳熟能详的并发编程概念。\n\n[![2019年9月编程语言趋势](/images/post_imgs/trending.png \"2019年9月编程语言趋势\")](https://spectrum.ieee.org/static/interactive-the-top-programming-languages-2019?utm_source=spectrum-hero \"2019年9月编程语言趋势\")\n\n---\n\n### Go语言的诞生\nGo（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。\n罗伯特·格瑞史莫，罗勃·派克（Rob Pike）及肯·汤普逊于2007年9月开始设计Go，谷歌把Go作为一个20%项目开始研发，即让员工抽出本职工作之外时间的20%，投入在该项目上，稍后Ian Lance Taylor、Russ Cox加入项目。Go是基于Inferno操作系统所开发的。Go于2009年11月正式宣布推出，成为开放源代码项目，支持Linux、Mac OS X、Windows等操作系统。\n对比上文所举的编程语言，在Go语言诞生的2007年，那时候已经处于双核时代，这就造就了Go语言在设计之初就考虑到了多核CPU下的程序运行，这也就造就了Go语言天生支持多核环境下编程的天赋技能。\n\n---\n\n### Go语言的主要特性\nGoogle是这样描述Go语言的：“[试图将像Python这样的动态语言的工作开发速度与C或C ++等编译语言的性能和安全性结合起来。在我们的Go to date实验中，典型的构建感觉瞬间完成; 甚至大型二进制文件只需几秒钟即可编译。编译后的代码接近C的速度.Go旨在让您快速移动。我们希望Go成为一种优秀的系统编程语言，支持多处理和面向对象设计的全新轻量化，具有真正的闭包和反射等一些很酷的功能。](https://techcrunch.com/2009/11/10/google-go-language/ \"试图将像Python这样的动态语言的工作开发速度与C或C ++等编译语言的性能和安全性结合起来。在我们的Go to date实验中，典型的构建感觉瞬间完成; 甚至大型二进制文件只需几秒钟即可编译。编译后的代码接近C的速度.Go旨在让您快速移动。我们希望Go成为一种优秀的系统编程语言，支持多处理和面向对象设计的全新轻量化，具有真正的闭包和反射等一些很酷的功能。\")”\n\n#### GO语言的主要特性主要包括\n\n - 并发与协程\n - 基于消息传递的通信方式\n - 丰富实用的内置数据类型\n - 函数多返回值\n - defer机制\n - 反射(reflect)\n - 高性能HTTP Server\n - 工程管理\n - 编程规范\n\n---\n\n### Go语言的应用前景\nGo语言凭借着天生的并发优势，出众的性能以及亲民的语法，迅速的蹿红各类IT领域，在人工智能、云计算开发、容器虚拟化、⼤数据开发、数据分析及科学计算、运维开发、爬虫开发、游戏开发等领域都有着广泛的应用。\n\n以下是应用Go语言的公司：\n![](/images/post_imgs/go_companies.jpg)\n\n","categories":["Go系列"]},{"title":"python语言起源","url":"/2019/09/16/python语言起源/","content":"\n## Python语言的前世今生\n\n### Python的诞生\npython的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范·罗苏姆（中文名字：龟叔）为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。  \n\n（龟叔：2005年加入谷歌至2012年，2013年加入Dropbox直到现在，依然掌握着Python发展的核心方向，被称为仁慈的独裁者）。\n![](/images/post_imgs/Guido_van_Rossum.jpg)\n\n---\n\n### Python版本发展\n - 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。\n - 1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。\n - Granddaddy of Python web frameworks, Zope 1 was released in 1999\n - Python 1.0 - January 1994 增加了 lambda, map, filter and reduce.\n - Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础\n - Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生\n - Python 2.5 - September 19, 2006\n - Python 2.6 - October 1, 2008\n - Python 2.7 - July 3, 2010\n - **In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible**\n - Python 3.0 - December 3, 2008\n - Python 3.1 - June 27, 2009\n - Python 3.2 - February 20, 2011\n - Python 3.3 - September 29, 2012\n - Python 3.4 - March 16, 2014\n - Python 3.5 - September 13, 2015\n - Python 3.6 - December 23, 2016\n - Python 3.7 - June 27, 2018\n\n---\n\n### Python的各类解释器\n - CPython：官方的解释器，也是使用最广的Python解释器。在CPython解释器下有GIL限制，一个CPU同一时刻只能运行一个线程。\n - IPython：是一种比较流行的解释器\n - PyPy：一种专注于执行速度的解释器。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。\n - Jython：运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行，Jython可以直接调用Java的各种函数库。\n - IronPython：和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。\n - ZhPy：周蟒，支持使用繁/简中文语句编写程序的Python语言\n\n---\n\n### Python应用领域\n目前Python主要应用领域：\n - 云计算: 云计算最火的语言， 典型应用OpenStack\n - WEB开发: 众多优秀的WEB框架，众多大型网站均为Python开发，Youtube, Dropbox, 豆瓣等等，典型WEB框架有Django、Flask、Tornado、sanic\n - 科学运算、人工智能: 典型库NumPy, SciPy, Matplotlib, Enthought librarys,pandas\n - 系统运维: 运维人员必备语言\n - 金融：量化交易，金融分析，在金融工程领域，Python不但在用，且用的最多，而且重要性逐年提高。\n - 原因：作为动态语言的Python，语言结构清晰简单，库丰富，成熟稳定，科学计算和统计分析都很牛逼，生产效率远远高于c、c++、java,尤其擅长策略回测\n - 图形GUI: PyQT、WxPython、TkInter\n","categories":["Python系列"]},{"title":"Python系列汇总","url":"/2019/09/16/Python系列/","content":"\n### Python_基础篇\n> 文章若无特别指出均表示python3.x版本下\n\n前提准备\n - 01 - [语言起源](http://elijahyg.github.io/2019/09/16/python%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90/)\n - 02 - [IDE介绍 & 环境搭建](http://elijahyg.github.io/2019/09/25/python%20IDE%E4%BB%8B%E7%BB%8D&%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)\n \n语法基础\n - 01 - 数据类型\n  - [数字类型 Integer](http://elijahyg.github.io/2019/10/11/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%95%B0%E5%AD%97/)\n  - [布尔类型 Boolean](http://elijahyg.github.io/2019/10/13/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/)\n  - [字符串类型 String](http://elijahyg.github.io/2019/10/24/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/)\n  - [列表类型 List](http://elijahyg.github.io/2019/10/30/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/)\n  - [元组类型 Tuple](http://elijahyg.github.io/2019/11/19/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%85%83%E7%BB%84/)\n  - [字典类型 Dict](http://elijahyg.github.io/2019/12/02/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8/)\n  - [集合类型 Set](http://elijahyg.github.io/2019/12/12/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/)\n  - [Py2与Py3字符串类型区别](http://elijahyg.github.io/2019/12/26/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bpy2%E4%B8%8Epy3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB/)\n  - [类型转换内置函数汇总](http://elijahyg.github.io/2020/01/07/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/)\n - 02 - [运算符](http://elijahyg.github.io/2020/01/15/Python%E8%BF%90%E7%AE%97%E7%AC%A6/)\n - 03 - [字符集&编码详解](http://elijahyg.github.io/2020/02/01/Python%E5%AD%97%E7%AC%A6%E9%9B%86&%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/#%E5%AD%97%E7%AC%A6%E9%9B%86-amp-%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3)\n - 04 - [文件操作](http://elijahyg.github.io/2020/02/12/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/)\n \n函数\n - 01 - [初识函数](http://elijahyg.github.io/2020/02/26/Python%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/)\n \n\n模块 & 包\n\n面向对象\n\n异常处理\n\n文件操作\n\n网络编程\n\n并发编程\n\n原理探究\n","categories":["Python系列"]},{"title":"基于Github搭建Hexo个人博客","url":"/2019/09/13/基于Github搭建Hexo个人博客/","content":"### 一、准备工作\n - Github账号\n - nodejs\n - npm\n - git for windows\n\n### 二、创建github仓库\n - 创建以`你的用户名.github.io`的仓库\n\n### 三、域名绑定(可选)\n\n### 四、配置SSH key\n> 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。\n\n - 用git bash执行如下命令,如果提示：No such file or directory 说明你是第一次使用git\n`$ cd ~/. ssh #检查本机已存在的ssh密钥`\n\n - 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -> SSH and GPG keys -> New SSH key；将刚复制的内容粘贴到key那里，title随便填，保存。\n`ssh-keygen -t rsa -C \"邮件地址\"`\n\n - 测试SSH-Key是否设置成功\n\n```txt\n ssh -T git@github.com # 注意邮箱地址不用改\n\n# 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\n# Hi 【用户名】! You’ve successfully authenticated, but GitHub does not provide shell access.\n# 看到这个信息说明SSH已配置成功！\n```\n\n - 配置全局用户名和邮箱\n\n```txt\n$ git config --global user.name \"用户名\" # 你的github用户名，非昵称\n$ git config --global user.email \"邮箱\" # 填写你的github注册邮箱\n```\n\n### 五、Hexo部分\n - 安装Hexo\n\n`npm install -g hexo`\n\n - 初始化Hexo\n\n```txt\ncd /d/workspaces/hexo/ # 工作目录\nhexo init\n```\n\n - 部署、启动服务\n\n```txt\nhexo g # 生成\nhexo s # 启动服务\n```\n\n - 本地预览问题\n\n```txt\nhexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故\n```\n\n### 六、修改Hexo主题\n\n - 官网主题\n`https://hexo.io/themes/`\n\n - 新推荐极简主题\n`https://github.com/aircloud/hexo-theme-aircloud`\n\n - 更换主题(以yilia为例)\n```txt\nhttps://github.com/litten/hexo-theme-yilia\n\n - 进入目录下载主题\ncd /d/workspaces/hexo/\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n - 修改配置文件\n\n```txt\n修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。\n如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。\n```\n\n### 七、上传到github\n - 修改配置文件\n\n```txt\n...\ndeploy:\n  type: git\n  repository: git@github.com:用户名/用户名.github.io.git\n  branch: master\n...\n```\n\n - 安装插件\n\n```txt\n# 部署前还需要安装插件，git bash执行\nnpm install hexo-deployer-git --save\n```\n\n - 提交至Github\n\n```txt\n# 如果一切正常，可以执行hexo d将代码上传至github，之后就可以打开https://用户名.github.io/浏览你的个人博客了\nhexo d\n```\n\n### 八、常用hexo命令\n\n - 常见命令\n\n```txt\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n```\n\n - 缩写\n\n```txt\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n - 组合命令\n\n```txt\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n### 九、写博客\n - 写博客\n```txt\n# 定位到hexo目录，执行下面语句，hexo会帮我们在_posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了\nhexo new 'my-first-blog'\n```\n\n - 一般完整格式如下\n\n```md\n---\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n以下是正文\n```","categories":["其他"]}]